int cv::borderInterpolate( int p
                           int len
                           int borderType )

AutoIt:
    cv.borderInterpolate( $p, $len, $borderType ) -> retval

void cv::copyMakeBorder( _InputArray       src
                         _OutputArray      dst
                         int               top
                         int               bottom
                         int               left
                         int               right
                         int               borderType
                         const cv::Scalar& value = Scalar() )

AutoIt:
    cv.copyMakeBorder( $src, $top, $bottom, $left, $right, $borderType[, $dst[, $value]] ) -> dst

void cv::add( _InputArray  src1
              _InputArray  src2
              _OutputArray dst
              _InputArray  mask = noArray()
              int          dtype = -1 )

AutoIt:
    cv.add( $src1, $src2[, $dst[, $mask[, $dtype]]] ) -> dst

void cv::subtract( _InputArray  src1
                   _InputArray  src2
                   _OutputArray dst
                   _InputArray  mask = noArray()
                   int          dtype = -1 )

AutoIt:
    cv.subtract( $src1, $src2[, $dst[, $mask[, $dtype]]] ) -> dst

void cv::multiply( _InputArray  src1
                   _InputArray  src2
                   _OutputArray dst
                   double       scale = 1
                   int          dtype = -1 )

AutoIt:
    cv.multiply( $src1, $src2[, $dst[, $scale[, $dtype]]] ) -> dst

void cv::divide( _InputArray  src1
                 _InputArray  src2
                 _OutputArray dst
                 double       scale = 1
                 int          dtype = -1 )

AutoIt:
    cv.divide( $src1, $src2[, $dst[, $scale[, $dtype]]] ) -> dst

void cv::divide( double       scale
                 _InputArray  src2
                 _OutputArray dst
                 int          dtype = -1 )

AutoIt:
    cv.divide( $scale, $src2[, $dst[, $dtype]] ) -> dst

void cv::scaleAdd( _InputArray  src1
                   double       alpha
                   _InputArray  src2
                   _OutputArray dst )

AutoIt:
    cv.scaleAdd( $src1, $alpha, $src2[, $dst] ) -> dst

void cv::addWeighted( _InputArray  src1
                      double       alpha
                      _InputArray  src2
                      double       beta
                      double       gamma
                      _OutputArray dst
                      int          dtype = -1 )

AutoIt:
    cv.addWeighted( $src1, $alpha, $src2, $beta, $gamma[, $dst[, $dtype]] ) -> dst

void cv::convertScaleAbs( _InputArray  src
                          _OutputArray dst
                          double       alpha = 1
                          double       beta = 0 )

AutoIt:
    cv.convertScaleAbs( $src[, $dst[, $alpha[, $beta]]] ) -> dst

void cv::convertFp16( _InputArray  src
                      _OutputArray dst )

AutoIt:
    cv.convertFp16( $src[, $dst] ) -> dst

void cv::LUT( _InputArray  src
              _InputArray  lut
              _OutputArray dst )

AutoIt:
    cv.LUT( $src, $lut[, $dst] ) -> dst

cv::Scalar cv::sumElems( _InputArray src )

AutoIt:
    cv.sumElems( $src ) -> retval

int cv::countNonZero( _InputArray src )

AutoIt:
    cv.countNonZero( $src ) -> retval

void cv::findNonZero( _InputArray  src
                      _OutputArray idx )

AutoIt:
    cv.findNonZero( $src[, $idx] ) -> idx

cv::Scalar cv::mean( _InputArray src
                     _InputArray mask = noArray() )

AutoIt:
    cv.mean( $src[, $mask] ) -> retval

void cv::meanStdDev( _InputArray  src
                     _OutputArray mean
                     _OutputArray stddev
                     _InputArray  mask = noArray() )

AutoIt:
    cv.meanStdDev( $src[, $mean[, $stddev[, $mask]]] ) -> mean, stddev

double cv::norm( _InputArray src1
                 int         normType = NORM_L2
                 _InputArray mask = noArray() )

AutoIt:
    cv.norm( $src1[, $normType[, $mask]] ) -> retval

double cv::norm( _InputArray src1
                 _InputArray src2
                 int         normType = NORM_L2
                 _InputArray mask = noArray() )

AutoIt:
    cv.norm( $src1, $src2[, $normType[, $mask]] ) -> retval

double cv::PSNR( _InputArray src1
                 _InputArray src2
                 double      R = 255. )

AutoIt:
    cv.PSNR( $src1, $src2[, $R] ) -> retval

void cv::batchDistance( _InputArray  src1
                        _InputArray  src2
                        _OutputArray dist
                        int          dtype
                        _OutputArray nidx
                        int          normType = NORM_L2
                        int          K = 0
                        _InputArray  mask = noArray()
                        int          update = 0
                        bool         crosscheck = false )

AutoIt:
    cv.batchDistance( $src1, $src2, $dtype[, $dist[, $nidx[, $normType[, $K[, $mask[, $update[, $crosscheck]]]]]]] ) -> dist, nidx

void cv::normalize( _InputArray       src
                    _InputOutputArray dst
                    double            alpha = 1
                    double            beta = 0
                    int               norm_type = NORM_L2
                    int               dtype = -1
                    _InputArray       mask = noArray() )

AutoIt:
    cv.normalize( $src, $dst[, $alpha[, $beta[, $norm_type[, $dtype[, $mask]]]]] ) -> dst

void cv::minMaxLoc( _InputArray src
                    double*     minVal
                    double*     maxVal = 0
                    cv::Point*  minLoc = 0
                    cv::Point*  maxLoc = 0
                    _InputArray mask = noArray() )

AutoIt:
    cv.minMaxLoc( $src[, $mask[, $minVal[, $maxVal[, $minLoc[, $maxLoc]]]]] ) -> minVal, maxVal, minLoc, maxLoc

void cv::reduceArgMin( _InputArray  src
                       _OutputArray dst
                       int          axis
                       bool         lastIndex = false )

AutoIt:
    cv.reduceArgMin( $src, $axis[, $dst[, $lastIndex]] ) -> dst

void cv::reduceArgMax( _InputArray  src
                       _OutputArray dst
                       int          axis
                       bool         lastIndex = false )

AutoIt:
    cv.reduceArgMax( $src, $axis[, $dst[, $lastIndex]] ) -> dst

void cv::reduce( _InputArray  src
                 _OutputArray dst
                 int          dim
                 int          rtype
                 int          dtype = -1 )

AutoIt:
    cv.reduce( $src, $dim, $rtype[, $dst[, $dtype]] ) -> dst

void cv::merge( _InputArray  mv
                _OutputArray dst )

AutoIt:
    cv.merge( $mv[, $dst] ) -> dst

void cv::split( _InputArray  m
                _OutputArray mv )

AutoIt:
    cv.split( $m[, $mv] ) -> mv

void cv::mixChannels( _InputArray             src
                      _InputOutputArray       dst
                      const std::vector<int>& fromTo )

AutoIt:
    cv.mixChannels( $src, $dst, $fromTo ) -> dst

void cv::extractChannel( _InputArray  src
                         _OutputArray dst
                         int          coi )

AutoIt:
    cv.extractChannel( $src, $coi[, $dst] ) -> dst

void cv::insertChannel( _InputArray       src
                        _InputOutputArray dst
                        int               coi )

AutoIt:
    cv.insertChannel( $src, $dst, $coi ) -> dst

void cv::flip( _InputArray  src
               _OutputArray dst
               int          flipCode )

AutoIt:
    cv.flip( $src, $flipCode[, $dst] ) -> dst

void cv::rotate( _InputArray  src
                 _OutputArray dst
                 int          rotateCode )

AutoIt:
    cv.rotate( $src, $rotateCode[, $dst] ) -> dst

void cv::repeat( _InputArray  src
                 int          ny
                 int          nx
                 _OutputArray dst )

AutoIt:
    cv.repeat( $src, $ny, $nx[, $dst] ) -> dst

void cv::hconcat( _InputArray  src
                  _OutputArray dst )

AutoIt:
    cv.hconcat( $src[, $dst] ) -> dst

void cv::vconcat( _InputArray  src
                  _OutputArray dst )

AutoIt:
    cv.vconcat( $src[, $dst] ) -> dst

void cv::bitwise_and( _InputArray  src1
                      _InputArray  src2
                      _OutputArray dst
                      _InputArray  mask = noArray() )

AutoIt:
    cv.bitwise_and( $src1, $src2[, $dst[, $mask]] ) -> dst

void cv::bitwise_or( _InputArray  src1
                     _InputArray  src2
                     _OutputArray dst
                     _InputArray  mask = noArray() )

AutoIt:
    cv.bitwise_or( $src1, $src2[, $dst[, $mask]] ) -> dst

void cv::bitwise_xor( _InputArray  src1
                      _InputArray  src2
                      _OutputArray dst
                      _InputArray  mask = noArray() )

AutoIt:
    cv.bitwise_xor( $src1, $src2[, $dst[, $mask]] ) -> dst

void cv::bitwise_not( _InputArray  src
                      _OutputArray dst
                      _InputArray  mask = noArray() )

AutoIt:
    cv.bitwise_not( $src[, $dst[, $mask]] ) -> dst

void cv::absdiff( _InputArray  src1
                  _InputArray  src2
                  _OutputArray dst )

AutoIt:
    cv.absdiff( $src1, $src2[, $dst] ) -> dst

void cv::copyTo( _InputArray  src
                 _OutputArray dst
                 _InputArray  mask )

AutoIt:
    cv.copyTo( $src, $mask[, $dst] ) -> dst

void cv::inRange( _InputArray  src
                  _InputArray  lowerb
                  _InputArray  upperb
                  _OutputArray dst )

AutoIt:
    cv.inRange( $src, $lowerb, $upperb[, $dst] ) -> dst

void cv::compare( _InputArray  src1
                  _InputArray  src2
                  _OutputArray dst
                  int          cmpop )

AutoIt:
    cv.compare( $src1, $src2, $cmpop[, $dst] ) -> dst

void cv::min( _InputArray  src1
              _InputArray  src2
              _OutputArray dst )

AutoIt:
    cv.min( $src1, $src2[, $dst] ) -> dst

void cv::max( _InputArray  src1
              _InputArray  src2
              _OutputArray dst )

AutoIt:
    cv.max( $src1, $src2[, $dst] ) -> dst

void cv::sqrt( _InputArray  src
               _OutputArray dst )

AutoIt:
    cv.sqrt( $src[, $dst] ) -> dst

void cv::pow( _InputArray  src
              double       power
              _OutputArray dst )

AutoIt:
    cv.pow( $src, $power[, $dst] ) -> dst

void cv::exp( _InputArray  src
              _OutputArray dst )

AutoIt:
    cv.exp( $src[, $dst] ) -> dst

void cv::log( _InputArray  src
              _OutputArray dst )

AutoIt:
    cv.log( $src[, $dst] ) -> dst

void cv::polarToCart( _InputArray  magnitude
                      _InputArray  angle
                      _OutputArray x
                      _OutputArray y
                      bool         angleInDegrees = false )

AutoIt:
    cv.polarToCart( $magnitude, $angle[, $x[, $y[, $angleInDegrees]]] ) -> x, y

void cv::cartToPolar( _InputArray  x
                      _InputArray  y
                      _OutputArray magnitude
                      _OutputArray angle
                      bool         angleInDegrees = false )

AutoIt:
    cv.cartToPolar( $x, $y[, $magnitude[, $angle[, $angleInDegrees]]] ) -> magnitude, angle

void cv::phase( _InputArray  x
                _InputArray  y
                _OutputArray angle
                bool         angleInDegrees = false )

AutoIt:
    cv.phase( $x, $y[, $angle[, $angleInDegrees]] ) -> angle

void cv::magnitude( _InputArray  x
                    _InputArray  y
                    _OutputArray magnitude )

AutoIt:
    cv.magnitude( $x, $y[, $magnitude] ) -> magnitude

bool cv::checkRange( _InputArray a
                     bool        quiet = true
                     cv::Point*  pos = 0
                     double      minVal = -DBL_MAX
                     double      maxVal = DBL_MAX )

AutoIt:
    cv.checkRange( $a[, $quiet[, $minVal[, $maxVal[, $pos]]]] ) -> retval, pos

void cv::patchNaNs( _InputOutputArray a
                    double            val = 0 )

AutoIt:
    cv.patchNaNs( $a[, $val] ) -> a

void cv::gemm( _InputArray  src1
               _InputArray  src2
               double       alpha
               _InputArray  src3
               double       beta
               _OutputArray dst
               int          flags = 0 )

AutoIt:
    cv.gemm( $src1, $src2, $alpha, $src3, $beta[, $dst[, $flags]] ) -> dst

void cv::mulTransposed( _InputArray  src
                        _OutputArray dst
                        bool         aTa
                        _InputArray  delta = noArray()
                        double       scale = 1
                        int          dtype = -1 )

AutoIt:
    cv.mulTransposed( $src, $aTa[, $dst[, $delta[, $scale[, $dtype]]]] ) -> dst

void cv::transpose( _InputArray  src
                    _OutputArray dst )

AutoIt:
    cv.transpose( $src[, $dst] ) -> dst

void cv::transform( _InputArray  src
                    _OutputArray dst
                    _InputArray  m )

AutoIt:
    cv.transform( $src, $m[, $dst] ) -> dst

void cv::perspectiveTransform( _InputArray  src
                               _OutputArray dst
                               _InputArray  m )

AutoIt:
    cv.perspectiveTransform( $src, $m[, $dst] ) -> dst

void cv::completeSymm( _InputOutputArray m
                       bool              lowerToUpper = false )

AutoIt:
    cv.completeSymm( $m[, $lowerToUpper] ) -> m

void cv::setIdentity( _InputOutputArray mtx
                      const cv::Scalar& s = Scalar(1) )

AutoIt:
    cv.setIdentity( $mtx[, $s] ) -> mtx

double cv::determinant( _InputArray mtx )

AutoIt:
    cv.determinant( $mtx ) -> retval

cv::Scalar cv::trace( _InputArray mtx )

AutoIt:
    cv.trace( $mtx ) -> retval

double cv::invert( _InputArray  src
                   _OutputArray dst
                   int          flags = DECOMP_LU )

AutoIt:
    cv.invert( $src[, $dst[, $flags]] ) -> retval, dst

bool cv::solve( _InputArray  src1
                _InputArray  src2
                _OutputArray dst
                int          flags = DECOMP_LU )

AutoIt:
    cv.solve( $src1, $src2[, $dst[, $flags]] ) -> retval, dst

void cv::sort( _InputArray  src
               _OutputArray dst
               int          flags )

AutoIt:
    cv.sort( $src, $flags[, $dst] ) -> dst

void cv::sortIdx( _InputArray  src
                  _OutputArray dst
                  int          flags )

AutoIt:
    cv.sortIdx( $src, $flags[, $dst] ) -> dst

int cv::solveCubic( _InputArray  coeffs
                    _OutputArray roots )

AutoIt:
    cv.solveCubic( $coeffs[, $roots] ) -> retval, roots

double cv::solvePoly( _InputArray  coeffs
                      _OutputArray roots
                      int          maxIters = 300 )

AutoIt:
    cv.solvePoly( $coeffs[, $roots[, $maxIters]] ) -> retval, roots

bool cv::eigen( _InputArray  src
                _OutputArray eigenvalues
                _OutputArray eigenvectors = noArray() )

AutoIt:
    cv.eigen( $src[, $eigenvalues[, $eigenvectors]] ) -> retval, eigenvalues, eigenvectors

void cv::eigenNonSymmetric( _InputArray  src
                            _OutputArray eigenvalues
                            _OutputArray eigenvectors )

AutoIt:
    cv.eigenNonSymmetric( $src[, $eigenvalues[, $eigenvectors]] ) -> eigenvalues, eigenvectors

void cv::calcCovarMatrix( _InputArray       samples
                          _OutputArray      covar
                          _InputOutputArray mean
                          int               flags
                          int               ctype = CV_64F )

AutoIt:
    cv.calcCovarMatrix( $samples, $mean, $flags[, $covar[, $ctype]] ) -> covar, mean

void cv::PCACompute( _InputArray       data
                     _InputOutputArray mean
                     _OutputArray      eigenvectors
                     int               maxComponents = 0 )

AutoIt:
    cv.PCACompute( $data, $mean[, $eigenvectors[, $maxComponents]] ) -> mean, eigenvectors

void cv::PCACompute( _InputArray       data
                     _InputOutputArray mean
                     _OutputArray      eigenvectors
                     double            retainedVariance )

AutoIt:
    cv.PCACompute( $data, $mean, $retainedVariance[, $eigenvectors] ) -> mean, eigenvectors

void cv::PCACompute2( _InputArray       data
                      _InputOutputArray mean
                      _OutputArray      eigenvectors
                      _OutputArray      eigenvalues
                      int               maxComponents = 0 )

AutoIt:
    cv.PCACompute2( $data, $mean[, $eigenvectors[, $eigenvalues[, $maxComponents]]] ) -> mean, eigenvectors, eigenvalues

void cv::PCACompute2( _InputArray       data
                      _InputOutputArray mean
                      _OutputArray      eigenvectors
                      _OutputArray      eigenvalues
                      double            retainedVariance )

AutoIt:
    cv.PCACompute2( $data, $mean, $retainedVariance[, $eigenvectors[, $eigenvalues]] ) -> mean, eigenvectors, eigenvalues

void cv::PCAProject( _InputArray  data
                     _InputArray  mean
                     _InputArray  eigenvectors
                     _OutputArray result )

AutoIt:
    cv.PCAProject( $data, $mean, $eigenvectors[, $result] ) -> result

void cv::PCABackProject( _InputArray  data
                         _InputArray  mean
                         _InputArray  eigenvectors
                         _OutputArray result )

AutoIt:
    cv.PCABackProject( $data, $mean, $eigenvectors[, $result] ) -> result

void cv::SVDecomp( _InputArray  src
                   _OutputArray w
                   _OutputArray u
                   _OutputArray vt
                   int          flags = 0 )

AutoIt:
    cv.SVDecomp( $src[, $w[, $u[, $vt[, $flags]]]] ) -> w, u, vt

void cv::SVBackSubst( _InputArray  w
                      _InputArray  u
                      _InputArray  vt
                      _InputArray  rhs
                      _OutputArray dst )

AutoIt:
    cv.SVBackSubst( $w, $u, $vt, $rhs[, $dst] ) -> dst

double cv::Mahalanobis( _InputArray v1
                        _InputArray v2
                        _InputArray icovar )

AutoIt:
    cv.Mahalanobis( $v1, $v2, $icovar ) -> retval

void cv::dft( _InputArray  src
              _OutputArray dst
              int          flags = 0
              int          nonzeroRows = 0 )

AutoIt:
    cv.dft( $src[, $dst[, $flags[, $nonzeroRows]]] ) -> dst

void cv::idft( _InputArray  src
               _OutputArray dst
               int          flags = 0
               int          nonzeroRows = 0 )

AutoIt:
    cv.idft( $src[, $dst[, $flags[, $nonzeroRows]]] ) -> dst

void cv::dct( _InputArray  src
              _OutputArray dst
              int          flags = 0 )

AutoIt:
    cv.dct( $src[, $dst[, $flags]] ) -> dst

void cv::idct( _InputArray  src
               _OutputArray dst
               int          flags = 0 )

AutoIt:
    cv.idct( $src[, $dst[, $flags]] ) -> dst

void cv::mulSpectrums( _InputArray  a
                       _InputArray  b
                       _OutputArray c
                       int          flags
                       bool         conjB = false )

AutoIt:
    cv.mulSpectrums( $a, $b, $flags[, $c[, $conjB]] ) -> c

int cv::getOptimalDFTSize( int vecsize )

AutoIt:
    cv.getOptimalDFTSize( $vecsize ) -> retval

void cv::setRNGSeed( int seed )

AutoIt:
    cv.setRNGSeed( $seed ) -> None

void cv::randu( _InputOutputArray dst
                _InputArray       low
                _InputArray       high )

AutoIt:
    cv.randu( $dst, $low, $high ) -> dst

void cv::randn( _InputOutputArray dst
                _InputArray       mean
                _InputArray       stddev )

AutoIt:
    cv.randn( $dst, $mean, $stddev ) -> dst

void cv::randShuffle( _InputOutputArray dst
                      double            iterFactor = 1.
                      cv::RNG*          rng = 0 )

AutoIt:
    cv.randShuffle( $dst[, $iterFactor[, $rng]] ) -> dst

double cv::kmeans( _InputArray       data
                   int               K
                   _InputOutputArray bestLabels
                   cv::TermCriteria  criteria
                   int               attempts
                   int               flags
                   _OutputArray      centers = noArray() )

AutoIt:
    cv.kmeans( $data, $K, $bestLabels, $criteria, $attempts, $flags[, $centers] ) -> retval, bestLabels, centers

float cv::cubeRoot( float val )

AutoIt:
    cv.cubeRoot( $val ) -> retval

float cv::fastAtan2( float y
                     float x )

AutoIt:
    cv.fastAtan2( $y, $x ) -> retval

int cv::setLogLevel( int level )

AutoIt:
    cv.setLogLevel( $level ) -> retval

int cv::getLogLevel()

AutoIt:
    cv.getLogLevel() -> retval

int cv::solveLP( _InputArray  Func
                 _InputArray  Constr
                 _OutputArray z )

AutoIt:
    cv.solveLP( $Func, $Constr[, $z] ) -> retval, z

bool cv::haveOpenVX()

AutoIt:
    cv.haveOpenVX() -> retval

bool cv::useOpenVX()

AutoIt:
    cv.useOpenVX() -> retval

void cv::setUseOpenVX( bool flag )

AutoIt:
    cv.setUseOpenVX( $flag ) -> None

void cv::setNumThreads( int nthreads )

AutoIt:
    cv.setNumThreads( $nthreads ) -> None

int cv::getNumThreads()

AutoIt:
    cv.getNumThreads() -> retval

int cv::getThreadNum()

AutoIt:
    cv.getThreadNum() -> retval

std::string cv::getBuildInformation()

AutoIt:
    cv.getBuildInformation() -> retval

std::string cv::getVersionString()

AutoIt:
    cv.getVersionString() -> retval

int cv::getVersionMajor()

AutoIt:
    cv.getVersionMajor() -> retval

int cv::getVersionMinor()

AutoIt:
    cv.getVersionMinor() -> retval

int cv::getVersionRevision()

AutoIt:
    cv.getVersionRevision() -> retval

int64 cv::getTickCount()

AutoIt:
    cv.getTickCount() -> retval

double cv::getTickFrequency()

AutoIt:
    cv.getTickFrequency() -> retval

int64 cv::getCPUTickCount()

AutoIt:
    cv.getCPUTickCount() -> retval

bool cv::checkHardwareSupport( int feature )

AutoIt:
    cv.checkHardwareSupport( $feature ) -> retval

std::string cv::getHardwareFeatureName( int feature )

AutoIt:
    cv.getHardwareFeatureName( $feature ) -> retval

std::string cv::getCPUFeaturesLine()

AutoIt:
    cv.getCPUFeaturesLine() -> retval

int cv::getNumberOfCPUs()

AutoIt:
    cv.getNumberOfCPUs() -> retval

void cv::setUseOptimized( bool onoff )

AutoIt:
    cv.setUseOptimized( $onoff ) -> None

bool cv::useOptimized()

AutoIt:
    cv.useOptimized() -> retval

cv::Ptr<cv::LineSegmentDetector> cv::createLineSegmentDetector( int    refine = LSD_REFINE_STD
                                                                double scale = 0.8
                                                                double sigma_scale = 0.6
                                                                double quant = 2.0
                                                                double ang_th = 22.5
                                                                double log_eps = 0
                                                                double density_th = 0.7
                                                                int    n_bins = 1024 )

AutoIt:
    cv.createLineSegmentDetector( [$refine[, $scale[, $sigma_scale[, $quant[, $ang_th[, $log_eps[, $density_th[, $n_bins]]]]]]]] ) -> retval

cv::Mat cv::getGaussianKernel( int    ksize
                               double sigma
                               int    ktype = CV_64F )

AutoIt:
    cv.getGaussianKernel( $ksize, $sigma[, $ktype] ) -> retval

void cv::getDerivKernels( _OutputArray kx
                          _OutputArray ky
                          int          dx
                          int          dy
                          int          ksize
                          bool         normalize = false
                          int          ktype = CV_32F )

AutoIt:
    cv.getDerivKernels( $dx, $dy, $ksize[, $kx[, $ky[, $normalize[, $ktype]]]] ) -> kx, ky

cv::Mat cv::getGaborKernel( cv::Size ksize
                            double   sigma
                            double   theta
                            double   lambd
                            double   gamma
                            double   psi = CV_PI*0.5
                            int      ktype = CV_64F )

AutoIt:
    cv.getGaborKernel( $ksize, $sigma, $theta, $lambd, $gamma[, $psi[, $ktype]] ) -> retval

cv::Mat cv::getStructuringElement( int       shape
                                   cv::Size  ksize
                                   cv::Point anchor = Point(-1,-1) )

AutoIt:
    cv.getStructuringElement( $shape, $ksize[, $anchor] ) -> retval

void cv::medianBlur( _InputArray  src
                     _OutputArray dst
                     int          ksize )

AutoIt:
    cv.medianBlur( $src, $ksize[, $dst] ) -> dst

void cv::GaussianBlur( _InputArray  src
                       _OutputArray dst
                       cv::Size     ksize
                       double       sigmaX
                       double       sigmaY = 0
                       int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.GaussianBlur( $src, $ksize, $sigmaX[, $dst[, $sigmaY[, $borderType]]] ) -> dst

void cv::bilateralFilter( _InputArray  src
                          _OutputArray dst
                          int          d
                          double       sigmaColor
                          double       sigmaSpace
                          int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.bilateralFilter( $src, $d, $sigmaColor, $sigmaSpace[, $dst[, $borderType]] ) -> dst

void cv::boxFilter( _InputArray  src
                    _OutputArray dst
                    int          ddepth
                    cv::Size     ksize
                    cv::Point    anchor = Point(-1,-1)
                    bool         normalize = true
                    int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.boxFilter( $src, $ddepth, $ksize[, $dst[, $anchor[, $normalize[, $borderType]]]] ) -> dst

void cv::sqrBoxFilter( _InputArray  src
                       _OutputArray dst
                       int          ddepth
                       cv::Size     ksize
                       cv::Point    anchor = Point(-1, -1)
                       bool         normalize = true
                       int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.sqrBoxFilter( $src, $ddepth, $ksize[, $dst[, $anchor[, $normalize[, $borderType]]]] ) -> dst

void cv::blur( _InputArray  src
               _OutputArray dst
               cv::Size     ksize
               cv::Point    anchor = Point(-1,-1)
               int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.blur( $src, $ksize[, $dst[, $anchor[, $borderType]]] ) -> dst

void cv::filter2D( _InputArray  src
                   _OutputArray dst
                   int          ddepth
                   _InputArray  kernel
                   cv::Point    anchor = Point(-1,-1)
                   double       delta = 0
                   int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.filter2D( $src, $ddepth, $kernel[, $dst[, $anchor[, $delta[, $borderType]]]] ) -> dst

void cv::sepFilter2D( _InputArray  src
                      _OutputArray dst
                      int          ddepth
                      _InputArray  kernelX
                      _InputArray  kernelY
                      cv::Point    anchor = Point(-1,-1)
                      double       delta = 0
                      int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.sepFilter2D( $src, $ddepth, $kernelX, $kernelY[, $dst[, $anchor[, $delta[, $borderType]]]] ) -> dst

void cv::Sobel( _InputArray  src
                _OutputArray dst
                int          ddepth
                int          dx
                int          dy
                int          ksize = 3
                double       scale = 1
                double       delta = 0
                int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.Sobel( $src, $ddepth, $dx, $dy[, $dst[, $ksize[, $scale[, $delta[, $borderType]]]]] ) -> dst

void cv::spatialGradient( _InputArray  src
                          _OutputArray dx
                          _OutputArray dy
                          int          ksize = 3
                          int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.spatialGradient( $src[, $dx[, $dy[, $ksize[, $borderType]]]] ) -> dx, dy

void cv::Scharr( _InputArray  src
                 _OutputArray dst
                 int          ddepth
                 int          dx
                 int          dy
                 double       scale = 1
                 double       delta = 0
                 int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.Scharr( $src, $ddepth, $dx, $dy[, $dst[, $scale[, $delta[, $borderType]]]] ) -> dst

void cv::Laplacian( _InputArray  src
                    _OutputArray dst
                    int          ddepth
                    int          ksize = 1
                    double       scale = 1
                    double       delta = 0
                    int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.Laplacian( $src, $ddepth[, $dst[, $ksize[, $scale[, $delta[, $borderType]]]]] ) -> dst

void cv::Canny( _InputArray  image
                _OutputArray edges
                double       threshold1
                double       threshold2
                int          apertureSize = 3
                bool         L2gradient = false )

AutoIt:
    cv.Canny( $image, $threshold1, $threshold2[, $edges[, $apertureSize[, $L2gradient]]] ) -> edges

void cv::Canny( _InputArray  dx
                _InputArray  dy
                _OutputArray edges
                double       threshold1
                double       threshold2
                bool         L2gradient = false )

AutoIt:
    cv.Canny( $dx, $dy, $threshold1, $threshold2[, $edges[, $L2gradient]] ) -> edges

void cv::cornerMinEigenVal( _InputArray  src
                            _OutputArray dst
                            int          blockSize
                            int          ksize = 3
                            int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.cornerMinEigenVal( $src, $blockSize[, $dst[, $ksize[, $borderType]]] ) -> dst

void cv::cornerHarris( _InputArray  src
                       _OutputArray dst
                       int          blockSize
                       int          ksize
                       double       k
                       int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.cornerHarris( $src, $blockSize, $ksize, $k[, $dst[, $borderType]] ) -> dst

void cv::cornerEigenValsAndVecs( _InputArray  src
                                 _OutputArray dst
                                 int          blockSize
                                 int          ksize
                                 int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.cornerEigenValsAndVecs( $src, $blockSize, $ksize[, $dst[, $borderType]] ) -> dst

void cv::preCornerDetect( _InputArray  src
                          _OutputArray dst
                          int          ksize
                          int          borderType = BORDER_DEFAULT )

AutoIt:
    cv.preCornerDetect( $src, $ksize[, $dst[, $borderType]] ) -> dst

void cv::cornerSubPix( _InputArray       image
                       _InputOutputArray corners
                       cv::Size          winSize
                       cv::Size          zeroZone
                       cv::TermCriteria  criteria )

AutoIt:
    cv.cornerSubPix( $image, $corners, $winSize, $zeroZone, $criteria ) -> corners

void cv::goodFeaturesToTrack( _InputArray  image
                              _OutputArray corners
                              int          maxCorners
                              double       qualityLevel
                              double       minDistance
                              _InputArray  mask = noArray()
                              int          blockSize = 3
                              bool         useHarrisDetector = false
                              double       k = 0.04 )

AutoIt:
    cv.goodFeaturesToTrack( $image, $maxCorners, $qualityLevel, $minDistance[, $corners[, $mask[, $blockSize[, $useHarrisDetector[, $k]]]]] ) -> corners

void cv::goodFeaturesToTrack( _InputArray  image
                              _OutputArray corners
                              int          maxCorners
                              double       qualityLevel
                              double       minDistance
                              _InputArray  mask
                              int          blockSize
                              int          gradientSize
                              bool         useHarrisDetector = false
                              double       k = 0.04 )

AutoIt:
    cv.goodFeaturesToTrack( $image, $maxCorners, $qualityLevel, $minDistance, $mask, $blockSize, $gradientSize[, $corners[, $useHarrisDetector[, $k]]] ) -> corners

void cv::goodFeaturesToTrackWithQuality( _InputArray  image
                                         _OutputArray corners
                                         int          maxCorners
                                         double       qualityLevel
                                         double       minDistance
                                         _InputArray  mask
                                         _OutputArray cornersQuality
                                         int          blockSize = 3
                                         int          gradientSize = 3
                                         bool         useHarrisDetector = false
                                         double       k = 0.04 )

AutoIt:
    cv.goodFeaturesToTrackWithQuality( $image, $maxCorners, $qualityLevel, $minDistance, $mask[, $corners[, $cornersQuality[, $blockSize[, $gradientSize[, $useHarrisDetector[, $k]]]]]] ) -> corners, cornersQuality

void cv::HoughLines( _InputArray  image
                     _OutputArray lines
                     double       rho
                     double       theta
                     int          threshold
                     double       srn = 0
                     double       stn = 0
                     double       min_theta = 0
                     double       max_theta = CV_PI )

AutoIt:
    cv.HoughLines( $image, $rho, $theta, $threshold[, $lines[, $srn[, $stn[, $min_theta[, $max_theta]]]]] ) -> lines

void cv::HoughLinesP( _InputArray  image
                      _OutputArray lines
                      double       rho
                      double       theta
                      int          threshold
                      double       minLineLength = 0
                      double       maxLineGap = 0 )

AutoIt:
    cv.HoughLinesP( $image, $rho, $theta, $threshold[, $lines[, $minLineLength[, $maxLineGap]]] ) -> lines

void cv::HoughLinesPointSet( _InputArray  point
                             _OutputArray lines
                             int          lines_max
                             int          threshold
                             double       min_rho
                             double       max_rho
                             double       rho_step
                             double       min_theta
                             double       max_theta
                             double       theta_step )

AutoIt:
    cv.HoughLinesPointSet( $point, $lines_max, $threshold, $min_rho, $max_rho, $rho_step, $min_theta, $max_theta, $theta_step[, $lines] ) -> lines

void cv::HoughCircles( _InputArray  image
                       _OutputArray circles
                       int          method
                       double       dp
                       double       minDist
                       double       param1 = 100
                       double       param2 = 100
                       int          minRadius = 0
                       int          maxRadius = 0 )

AutoIt:
    cv.HoughCircles( $image, $method, $dp, $minDist[, $circles[, $param1[, $param2[, $minRadius[, $maxRadius]]]]] ) -> circles

void cv::erode( _InputArray       src
                _OutputArray      dst
                _InputArray       kernel
                cv::Point         anchor = Point(-1,-1)
                int               iterations = 1
                int               borderType = BORDER_CONSTANT
                const cv::Scalar& borderValue = morphologyDefaultBorderValue() )

AutoIt:
    cv.erode( $src, $kernel[, $dst[, $anchor[, $iterations[, $borderType[, $borderValue]]]]] ) -> dst

void cv::dilate( _InputArray       src
                 _OutputArray      dst
                 _InputArray       kernel
                 cv::Point         anchor = Point(-1,-1)
                 int               iterations = 1
                 int               borderType = BORDER_CONSTANT
                 const cv::Scalar& borderValue = morphologyDefaultBorderValue() )

AutoIt:
    cv.dilate( $src, $kernel[, $dst[, $anchor[, $iterations[, $borderType[, $borderValue]]]]] ) -> dst

void cv::morphologyEx( _InputArray       src
                       _OutputArray      dst
                       int               op
                       _InputArray       kernel
                       cv::Point         anchor = Point(-1,-1)
                       int               iterations = 1
                       int               borderType = BORDER_CONSTANT
                       const cv::Scalar& borderValue = morphologyDefaultBorderValue() )

AutoIt:
    cv.morphologyEx( $src, $op, $kernel[, $dst[, $anchor[, $iterations[, $borderType[, $borderValue]]]]] ) -> dst

void cv::resize( _InputArray  src
                 _OutputArray dst
                 cv::Size     dsize
                 double       fx = 0
                 double       fy = 0
                 int          interpolation = INTER_LINEAR )

AutoIt:
    cv.resize( $src, $dsize[, $dst[, $fx[, $fy[, $interpolation]]]] ) -> dst

void cv::warpAffine( _InputArray       src
                     _OutputArray      dst
                     _InputArray       M
                     cv::Size          dsize
                     int               flags = INTER_LINEAR
                     int               borderMode = BORDER_CONSTANT
                     const cv::Scalar& borderValue = Scalar() )

AutoIt:
    cv.warpAffine( $src, $M, $dsize[, $dst[, $flags[, $borderMode[, $borderValue]]]] ) -> dst

void cv::warpPerspective( _InputArray       src
                          _OutputArray      dst
                          _InputArray       M
                          cv::Size          dsize
                          int               flags = INTER_LINEAR
                          int               borderMode = BORDER_CONSTANT
                          const cv::Scalar& borderValue = Scalar() )

AutoIt:
    cv.warpPerspective( $src, $M, $dsize[, $dst[, $flags[, $borderMode[, $borderValue]]]] ) -> dst

void cv::remap( _InputArray       src
                _OutputArray      dst
                _InputArray       map1
                _InputArray       map2
                int               interpolation
                int               borderMode = BORDER_CONSTANT
                const cv::Scalar& borderValue = Scalar() )

AutoIt:
    cv.remap( $src, $map1, $map2, $interpolation[, $dst[, $borderMode[, $borderValue]]] ) -> dst

void cv::convertMaps( _InputArray  map1
                      _InputArray  map2
                      _OutputArray dstmap1
                      _OutputArray dstmap2
                      int          dstmap1type
                      bool         nninterpolation = false )

AutoIt:
    cv.convertMaps( $map1, $map2, $dstmap1type[, $dstmap1[, $dstmap2[, $nninterpolation]]] ) -> dstmap1, dstmap2

cv::Mat cv::getRotationMatrix2D( cv::Point2f center
                                 double      angle
                                 double      scale )

AutoIt:
    cv.getRotationMatrix2D( $center, $angle, $scale ) -> retval

void cv::invertAffineTransform( _InputArray  M
                                _OutputArray iM )

AutoIt:
    cv.invertAffineTransform( $M[, $iM] ) -> iM

cv::Mat cv::getPerspectiveTransform( _InputArray src
                                     _InputArray dst
                                     int         solveMethod = DECOMP_LU )

AutoIt:
    cv.getPerspectiveTransform( $src, $dst[, $solveMethod] ) -> retval

cv::Mat cv::getAffineTransform( _InputArray src
                                _InputArray dst )

AutoIt:
    cv.getAffineTransform( $src, $dst ) -> retval

void cv::getRectSubPix( _InputArray  image
                        cv::Size     patchSize
                        cv::Point2f  center
                        _OutputArray patch
                        int          patchType = -1 )

AutoIt:
    cv.getRectSubPix( $image, $patchSize, $center[, $patch[, $patchType]] ) -> patch

void cv::logPolar( _InputArray  src
                   _OutputArray dst
                   cv::Point2f  center
                   double       M
                   int          flags )

AutoIt:
    cv.logPolar( $src, $center, $M, $flags[, $dst] ) -> dst

void cv::linearPolar( _InputArray  src
                      _OutputArray dst
                      cv::Point2f  center
                      double       maxRadius
                      int          flags )

AutoIt:
    cv.linearPolar( $src, $center, $maxRadius, $flags[, $dst] ) -> dst

void cv::warpPolar( _InputArray  src
                    _OutputArray dst
                    cv::Size     dsize
                    cv::Point2f  center
                    double       maxRadius
                    int          flags )

AutoIt:
    cv.warpPolar( $src, $dsize, $center, $maxRadius, $flags[, $dst] ) -> dst

void cv::integral3( _InputArray  src
                    _OutputArray sum
                    _OutputArray sqsum
                    _OutputArray tilted
                    int          sdepth = -1
                    int          sqdepth = -1 )

AutoIt:
    cv.integral3( $src[, $sum[, $sqsum[, $tilted[, $sdepth[, $sqdepth]]]]] ) -> sum, sqsum, tilted

void cv::integral( _InputArray  src
                   _OutputArray sum
                   int          sdepth = -1 )

AutoIt:
    cv.integral( $src[, $sum[, $sdepth]] ) -> sum

void cv::integral2( _InputArray  src
                    _OutputArray sum
                    _OutputArray sqsum
                    int          sdepth = -1
                    int          sqdepth = -1 )

AutoIt:
    cv.integral2( $src[, $sum[, $sqsum[, $sdepth[, $sqdepth]]]] ) -> sum, sqsum

void cv::accumulate( _InputArray       src
                     _InputOutputArray dst
                     _InputArray       mask = noArray() )

AutoIt:
    cv.accumulate( $src, $dst[, $mask] ) -> dst

void cv::accumulateSquare( _InputArray       src
                           _InputOutputArray dst
                           _InputArray       mask = noArray() )

AutoIt:
    cv.accumulateSquare( $src, $dst[, $mask] ) -> dst

void cv::accumulateProduct( _InputArray       src1
                            _InputArray       src2
                            _InputOutputArray dst
                            _InputArray       mask = noArray() )

AutoIt:
    cv.accumulateProduct( $src1, $src2, $dst[, $mask] ) -> dst

void cv::accumulateWeighted( _InputArray       src
                             _InputOutputArray dst
                             double            alpha
                             _InputArray       mask = noArray() )

AutoIt:
    cv.accumulateWeighted( $src, $dst, $alpha[, $mask] ) -> dst

cv::Point2d cv::phaseCorrelate( _InputArray src1
                                _InputArray src2
                                _InputArray window = noArray()
                                double*     response = 0 )

AutoIt:
    cv.phaseCorrelate( $src1, $src2[, $window[, $response]] ) -> retval, response

void cv::createHanningWindow( _OutputArray dst
                              cv::Size     winSize
                              int          type )

AutoIt:
    cv.createHanningWindow( $winSize, $type[, $dst] ) -> dst

void cv::divSpectrums( _InputArray  a
                       _InputArray  b
                       _OutputArray c
                       int          flags
                       bool         conjB = false )

AutoIt:
    cv.divSpectrums( $a, $b, $flags[, $c[, $conjB]] ) -> c

double cv::threshold( _InputArray  src
                      _OutputArray dst
                      double       thresh
                      double       maxval
                      int          type )

AutoIt:
    cv.threshold( $src, $thresh, $maxval, $type[, $dst] ) -> retval, dst

void cv::adaptiveThreshold( _InputArray  src
                            _OutputArray dst
                            double       maxValue
                            int          adaptiveMethod
                            int          thresholdType
                            int          blockSize
                            double       C )

AutoIt:
    cv.adaptiveThreshold( $src, $maxValue, $adaptiveMethod, $thresholdType, $blockSize, $C[, $dst] ) -> dst

void cv::pyrDown( _InputArray     src
                  _OutputArray    dst
                  const cv::Size& dstsize = Size()
                  int             borderType = BORDER_DEFAULT )

AutoIt:
    cv.pyrDown( $src[, $dst[, $dstsize[, $borderType]]] ) -> dst

void cv::pyrUp( _InputArray     src
                _OutputArray    dst
                const cv::Size& dstsize = Size()
                int             borderType = BORDER_DEFAULT )

AutoIt:
    cv.pyrUp( $src[, $dst[, $dstsize[, $borderType]]] ) -> dst

void cv::calcHist( _InputArray               images
                   const std::vector<int>&   channels
                   _InputArray               mask
                   _OutputArray              hist
                   const std::vector<int>&   histSize
                   const std::vector<float>& ranges
                   bool                      accumulate = false )

AutoIt:
    cv.calcHist( $images, $channels, $mask, $histSize, $ranges[, $hist[, $accumulate]] ) -> hist

void cv::calcBackProject( _InputArray               images
                          const std::vector<int>&   channels
                          _InputArray               hist
                          _OutputArray              dst
                          const std::vector<float>& ranges
                          double                    scale )

AutoIt:
    cv.calcBackProject( $images, $channels, $hist, $ranges, $scale[, $dst] ) -> dst

double cv::compareHist( _InputArray H1
                        _InputArray H2
                        int         method )

AutoIt:
    cv.compareHist( $H1, $H2, $method ) -> retval

void cv::equalizeHist( _InputArray  src
                       _OutputArray dst )

AutoIt:
    cv.equalizeHist( $src[, $dst] ) -> dst

cv::Ptr<cv::CLAHE> cv::createCLAHE( double   clipLimit = 40.0
                                    cv::Size tileGridSize = Size(8, 8) )

AutoIt:
    cv.createCLAHE( [$clipLimit[, $tileGridSize]] ) -> retval

float cv::EMD( _InputArray    signature1
               _InputArray    signature2
               int            distType
               _InputArray    cost = noArray()
               cv::Ptr<float> lowerBound = Ptr<float>()
               _OutputArray   flow = noArray() )

AutoIt:
    cv.EMD( $signature1, $signature2, $distType[, $cost[, $lowerBound[, $flow]]] ) -> retval, lowerBound, flow

void cv::watershed( _InputArray       image
                    _InputOutputArray markers )

AutoIt:
    cv.watershed( $image, $markers ) -> markers

void cv::pyrMeanShiftFiltering( _InputArray      src
                                _OutputArray     dst
                                double           sp
                                double           sr
                                int              maxLevel = 1
                                cv::TermCriteria termcrit = TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) )

AutoIt:
    cv.pyrMeanShiftFiltering( $src, $sp, $sr[, $dst[, $maxLevel[, $termcrit]]] ) -> dst

void cv::grabCut( _InputArray       img
                  _InputOutputArray mask
                  cv::Rect          rect
                  _InputOutputArray bgdModel
                  _InputOutputArray fgdModel
                  int               iterCount
                  int               mode = GC_EVAL )

AutoIt:
    cv.grabCut( $img, $mask, $rect, $bgdModel, $fgdModel, $iterCount[, $mode] ) -> mask, bgdModel, fgdModel

void cv::distanceTransformWithLabels( _InputArray  src
                                      _OutputArray dst
                                      _OutputArray labels
                                      int          distanceType
                                      int          maskSize
                                      int          labelType = DIST_LABEL_CCOMP )

AutoIt:
    cv.distanceTransformWithLabels( $src, $distanceType, $maskSize[, $dst[, $labels[, $labelType]]] ) -> dst, labels

void cv::distanceTransform( _InputArray  src
                            _OutputArray dst
                            int          distanceType
                            int          maskSize
                            int          dstType = CV_32F )

AutoIt:
    cv.distanceTransform( $src, $distanceType, $maskSize[, $dst[, $dstType]] ) -> dst

int cv::floodFill( _InputOutputArray image
                   _InputOutputArray mask
                   cv::Point         seedPoint
                   cv::Scalar        newVal
                   cv::Rect*         rect = 0
                   cv::Scalar        loDiff = Scalar()
                   cv::Scalar        upDiff = Scalar()
                   int               flags = 4 )

AutoIt:
    cv.floodFill( $image, $mask, $seedPoint, $newVal[, $loDiff[, $upDiff[, $flags[, $rect]]]] ) -> retval, image, mask, rect

void cv::blendLinear( _InputArray  src1
                      _InputArray  src2
                      _InputArray  weights1
                      _InputArray  weights2
                      _OutputArray dst )

AutoIt:
    cv.blendLinear( $src1, $src2, $weights1, $weights2[, $dst] ) -> dst

void cv::cvtColor( _InputArray  src
                   _OutputArray dst
                   int          code
                   int          dstCn = 0 )

AutoIt:
    cv.cvtColor( $src, $code[, $dst[, $dstCn]] ) -> dst

void cv::cvtColorTwoPlane( _InputArray  src1
                           _InputArray  src2
                           _OutputArray dst
                           int          code )

AutoIt:
    cv.cvtColorTwoPlane( $src1, $src2, $code[, $dst] ) -> dst

void cv::demosaicing( _InputArray  src
                      _OutputArray dst
                      int          code
                      int          dstCn = 0 )

AutoIt:
    cv.demosaicing( $src, $code[, $dst[, $dstCn]] ) -> dst

cv::Moments cv::moments( _InputArray array
                         bool        binaryImage = false )

AutoIt:
    cv.moments( $array[, $binaryImage] ) -> retval

void cv::HuMoments( const cv::Moments& m
                    _OutputArray       hu )

AutoIt:
    cv.HuMoments( $m[, $hu] ) -> hu

void cv::matchTemplate( _InputArray  image
                        _InputArray  templ
                        _OutputArray result
                        int          method
                        _InputArray  mask = noArray() )

AutoIt:
    cv.matchTemplate( $image, $templ, $method[, $result[, $mask]] ) -> result

int cv::connectedComponentsWithAlgorithm( _InputArray  image
                                          _OutputArray labels
                                          int          connectivity
                                          int          ltype
                                          int          ccltype )

AutoIt:
    cv.connectedComponentsWithAlgorithm( $image, $connectivity, $ltype, $ccltype[, $labels] ) -> retval, labels

int cv::connectedComponents( _InputArray  image
                             _OutputArray labels
                             int          connectivity = 8
                             int          ltype = CV_32S )

AutoIt:
    cv.connectedComponents( $image[, $labels[, $connectivity[, $ltype]]] ) -> retval, labels

int cv::connectedComponentsWithStatsWithAlgorithm( _InputArray  image
                                                   _OutputArray labels
                                                   _OutputArray stats
                                                   _OutputArray centroids
                                                   int          connectivity
                                                   int          ltype
                                                   int          ccltype )

AutoIt:
    cv.connectedComponentsWithStatsWithAlgorithm( $image, $connectivity, $ltype, $ccltype[, $labels[, $stats[, $centroids]]] ) -> retval, labels, stats, centroids

int cv::connectedComponentsWithStats( _InputArray  image
                                      _OutputArray labels
                                      _OutputArray stats
                                      _OutputArray centroids
                                      int          connectivity = 8
                                      int          ltype = CV_32S )

AutoIt:
    cv.connectedComponentsWithStats( $image[, $labels[, $stats[, $centroids[, $connectivity[, $ltype]]]]] ) -> retval, labels, stats, centroids

void cv::findContours( _InputArray  image
                       _OutputArray contours
                       _OutputArray hierarchy
                       int          mode
                       int          method
                       cv::Point    offset = Point() )

AutoIt:
    cv.findContours( $image, $mode, $method[, $contours[, $hierarchy[, $offset]]] ) -> contours, hierarchy

void cv::approxPolyDP( _InputArray  curve
                       _OutputArray approxCurve
                       double       epsilon
                       bool         closed )

AutoIt:
    cv.approxPolyDP( $curve, $epsilon, $closed[, $approxCurve] ) -> approxCurve

double cv::arcLength( _InputArray curve
                      bool        closed )

AutoIt:
    cv.arcLength( $curve, $closed ) -> retval

cv::Rect cv::boundingRect( _InputArray array )

AutoIt:
    cv.boundingRect( $array ) -> retval

double cv::contourArea( _InputArray contour
                        bool        oriented = false )

AutoIt:
    cv.contourArea( $contour[, $oriented] ) -> retval

cv::RotatedRect cv::minAreaRect( _InputArray points )

AutoIt:
    cv.minAreaRect( $points ) -> retval

void cv::boxPoints( cv::RotatedRect box
                    _OutputArray    points )

AutoIt:
    cv.boxPoints( $box[, $points] ) -> points

void cv::minEnclosingCircle( _InputArray  points
                             cv::Point2f& center
                             float&       radius )

AutoIt:
    cv.minEnclosingCircle( $points[, $center[, $radius]] ) -> center, radius

double cv::minEnclosingTriangle( _InputArray  points
                                 _OutputArray triangle )

AutoIt:
    cv.minEnclosingTriangle( $points[, $triangle] ) -> retval, triangle

double cv::matchShapes( _InputArray contour1
                        _InputArray contour2
                        int         method
                        double      parameter )

AutoIt:
    cv.matchShapes( $contour1, $contour2, $method, $parameter ) -> retval

void cv::convexHull( _InputArray  points
                     _OutputArray hull
                     bool         clockwise = false
                     bool         returnPoints = true )

AutoIt:
    cv.convexHull( $points[, $hull[, $clockwise[, $returnPoints]]] ) -> hull

void cv::convexityDefects( _InputArray  contour
                           _InputArray  convexhull
                           _OutputArray convexityDefects )

AutoIt:
    cv.convexityDefects( $contour, $convexhull[, $convexityDefects] ) -> convexityDefects

bool cv::isContourConvex( _InputArray contour )

AutoIt:
    cv.isContourConvex( $contour ) -> retval

float cv::intersectConvexConvex( _InputArray  p1
                                 _InputArray  p2
                                 _OutputArray p12
                                 bool         handleNested = true )

AutoIt:
    cv.intersectConvexConvex( $p1, $p2[, $p12[, $handleNested]] ) -> retval, p12

cv::RotatedRect cv::fitEllipse( _InputArray points )

AutoIt:
    cv.fitEllipse( $points ) -> retval

cv::RotatedRect cv::fitEllipseAMS( _InputArray points )

AutoIt:
    cv.fitEllipseAMS( $points ) -> retval

cv::RotatedRect cv::fitEllipseDirect( _InputArray points )

AutoIt:
    cv.fitEllipseDirect( $points ) -> retval

void cv::fitLine( _InputArray  points
                  _OutputArray line
                  int          distType
                  double       param
                  double       reps
                  double       aeps )

AutoIt:
    cv.fitLine( $points, $distType, $param, $reps, $aeps[, $line] ) -> line

double cv::pointPolygonTest( _InputArray contour
                             cv::Point2f pt
                             bool        measureDist )

AutoIt:
    cv.pointPolygonTest( $contour, $pt, $measureDist ) -> retval

int cv::rotatedRectangleIntersection( const cv::RotatedRect& rect1
                                      const cv::RotatedRect& rect2
                                      _OutputArray           intersectingRegion )

AutoIt:
    cv.rotatedRectangleIntersection( $rect1, $rect2[, $intersectingRegion] ) -> retval, intersectingRegion

cv::Ptr<cv::GeneralizedHoughBallard> cv::createGeneralizedHoughBallard()

AutoIt:
    cv.createGeneralizedHoughBallard() -> retval

cv::Ptr<cv::GeneralizedHoughGuil> cv::createGeneralizedHoughGuil()

AutoIt:
    cv.createGeneralizedHoughGuil() -> retval

void cv::applyColorMap( _InputArray  src
                        _OutputArray dst
                        int          colormap )

AutoIt:
    cv.applyColorMap( $src, $colormap[, $dst] ) -> dst

void cv::applyColorMap( _InputArray  src
                        _OutputArray dst
                        _InputArray  userColor )

AutoIt:
    cv.applyColorMap( $src, $userColor[, $dst] ) -> dst

void cv::line( _InputOutputArray img
               cv::Point         pt1
               cv::Point         pt2
               const cv::Scalar& color
               int               thickness = 1
               int               lineType = LINE_8
               int               shift = 0 )

AutoIt:
    cv.line( $img, $pt1, $pt2, $color[, $thickness[, $lineType[, $shift]]] ) -> img

void cv::arrowedLine( _InputOutputArray img
                      cv::Point         pt1
                      cv::Point         pt2
                      const cv::Scalar& color
                      int               thickness = 1
                      int               line_type = 8
                      int               shift = 0
                      double            tipLength = 0.1 )

AutoIt:
    cv.arrowedLine( $img, $pt1, $pt2, $color[, $thickness[, $line_type[, $shift[, $tipLength]]]] ) -> img

void cv::rectangle( _InputOutputArray img
                    cv::Point         pt1
                    cv::Point         pt2
                    const cv::Scalar& color
                    int               thickness = 1
                    int               lineType = LINE_8
                    int               shift = 0 )

AutoIt:
    cv.rectangle( $img, $pt1, $pt2, $color[, $thickness[, $lineType[, $shift]]] ) -> img

void cv::rectangle( _InputOutputArray img
                    cv::Rect          rec
                    const cv::Scalar& color
                    int               thickness = 1
                    int               lineType = LINE_8
                    int               shift = 0 )

AutoIt:
    cv.rectangle( $img, $rec, $color[, $thickness[, $lineType[, $shift]]] ) -> img

void cv::circle( _InputOutputArray img
                 cv::Point         center
                 int               radius
                 const cv::Scalar& color
                 int               thickness = 1
                 int               lineType = LINE_8
                 int               shift = 0 )

AutoIt:
    cv.circle( $img, $center, $radius, $color[, $thickness[, $lineType[, $shift]]] ) -> img

void cv::ellipse( _InputOutputArray img
                  cv::Point         center
                  cv::Size          axes
                  double            angle
                  double            startAngle
                  double            endAngle
                  const cv::Scalar& color
                  int               thickness = 1
                  int               lineType = LINE_8
                  int               shift = 0 )

AutoIt:
    cv.ellipse( $img, $center, $axes, $angle, $startAngle, $endAngle, $color[, $thickness[, $lineType[, $shift]]] ) -> img

void cv::ellipse( _InputOutputArray      img
                  const cv::RotatedRect& box
                  const cv::Scalar&      color
                  int                    thickness = 1
                  int                    lineType = LINE_8 )

AutoIt:
    cv.ellipse( $img, $box, $color[, $thickness[, $lineType]] ) -> img

void cv::drawMarker( _InputOutputArray img
                     cv::Point         position
                     const cv::Scalar& color
                     int               markerType = MARKER_CROSS
                     int               markerSize = 20
                     int               thickness = 1
                     int               line_type = 8 )

AutoIt:
    cv.drawMarker( $img, $position, $color[, $markerType[, $markerSize[, $thickness[, $line_type]]]] ) -> img

void cv::fillConvexPoly( _InputOutputArray img
                         _InputArray       points
                         const cv::Scalar& color
                         int               lineType = LINE_8
                         int               shift = 0 )

AutoIt:
    cv.fillConvexPoly( $img, $points, $color[, $lineType[, $shift]] ) -> img

void cv::fillPoly( _InputOutputArray img
                   _InputArray       pts
                   const cv::Scalar& color
                   int               lineType = LINE_8
                   int               shift = 0
                   cv::Point         offset = Point() )

AutoIt:
    cv.fillPoly( $img, $pts, $color[, $lineType[, $shift[, $offset]]] ) -> img

void cv::polylines( _InputOutputArray img
                    _InputArray       pts
                    bool              isClosed
                    const cv::Scalar& color
                    int               thickness = 1
                    int               lineType = LINE_8
                    int               shift = 0 )

AutoIt:
    cv.polylines( $img, $pts, $isClosed, $color[, $thickness[, $lineType[, $shift]]] ) -> img

void cv::drawContours( _InputOutputArray image
                       _InputArray       contours
                       int               contourIdx
                       const cv::Scalar& color
                       int               thickness = 1
                       int               lineType = LINE_8
                       _InputArray       hierarchy = noArray()
                       int               maxLevel = INT_MAX
                       cv::Point         offset = Point() )

AutoIt:
    cv.drawContours( $image, $contours, $contourIdx, $color[, $thickness[, $lineType[, $hierarchy[, $maxLevel[, $offset]]]]] ) -> image

bool cv::clipLine( cv::Rect   imgRect
                   cv::Point& pt1
                   cv::Point& pt2 )

AutoIt:
    cv.clipLine( $imgRect, $pt1, $pt2 ) -> retval, pt1, pt2

void cv::ellipse2Poly( cv::Point               center
                       cv::Size                axes
                       int                     angle
                       int                     arcStart
                       int                     arcEnd
                       int                     delta
                       std::vector<cv::Point>& pts )

AutoIt:
    cv.ellipse2Poly( $center, $axes, $angle, $arcStart, $arcEnd, $delta[, $pts] ) -> pts

void cv::putText( _InputOutputArray  img
                  const std::string& text
                  cv::Point          org
                  int                fontFace
                  double             fontScale
                  cv::Scalar         color
                  int                thickness = 1
                  int                lineType = LINE_8
                  bool               bottomLeftOrigin = false )

AutoIt:
    cv.putText( $img, $text, $org, $fontFace, $fontScale, $color[, $thickness[, $lineType[, $bottomLeftOrigin]]] ) -> img

cv::Size cv::getTextSize( const std::string& text
                          int                fontFace
                          double             fontScale
                          int                thickness
                          int*               baseLine )

AutoIt:
    cv.getTextSize( $text, $fontFace, $fontScale, $thickness[, $baseLine] ) -> retval, baseLine

double cv::getFontScaleFromHeight( const int fontFace
                                   const int pixelHeight
                                   const int thickness = 1 )

AutoIt:
    cv.getFontScaleFromHeight( $fontFace, $pixelHeight[, $thickness] ) -> retval

void cv::HoughLinesWithAccumulator( _InputArray  image
                                    _OutputArray lines
                                    double       rho
                                    double       theta
                                    int          threshold
                                    double       srn = 0
                                    double       stn = 0
                                    double       min_theta = 0
                                    double       max_theta = CV_PI )

AutoIt:
    cv.HoughLinesWithAccumulator( $image, $rho, $theta, $threshold[, $lines[, $srn[, $stn[, $min_theta[, $max_theta]]]]] ) -> lines

void cv::inpaint( _InputArray  src
                  _InputArray  inpaintMask
                  _OutputArray dst
                  double       inpaintRadius
                  int          flags )

AutoIt:
    cv.inpaint( $src, $inpaintMask, $inpaintRadius, $flags[, $dst] ) -> dst

void cv::fastNlMeansDenoising( _InputArray  src
                               _OutputArray dst
                               float        h = 3
                               int          templateWindowSize = 7
                               int          searchWindowSize = 21 )

AutoIt:
    cv.fastNlMeansDenoising( $src[, $dst[, $h[, $templateWindowSize[, $searchWindowSize]]]] ) -> dst

void cv::fastNlMeansDenoising( _InputArray               src
                               _OutputArray              dst
                               const std::vector<float>& h
                               int                       templateWindowSize = 7
                               int                       searchWindowSize = 21
                               int                       normType = NORM_L2 )

AutoIt:
    cv.fastNlMeansDenoising( $src, $h[, $dst[, $templateWindowSize[, $searchWindowSize[, $normType]]]] ) -> dst

void cv::fastNlMeansDenoisingColored( _InputArray  src
                                      _OutputArray dst
                                      float        h = 3
                                      float        hColor = 3
                                      int          templateWindowSize = 7
                                      int          searchWindowSize = 21 )

AutoIt:
    cv.fastNlMeansDenoisingColored( $src[, $dst[, $h[, $hColor[, $templateWindowSize[, $searchWindowSize]]]]] ) -> dst

void cv::fastNlMeansDenoisingMulti( _InputArray  srcImgs
                                    _OutputArray dst
                                    int          imgToDenoiseIndex
                                    int          temporalWindowSize
                                    float        h = 3
                                    int          templateWindowSize = 7
                                    int          searchWindowSize = 21 )

AutoIt:
    cv.fastNlMeansDenoisingMulti( $srcImgs, $imgToDenoiseIndex, $temporalWindowSize[, $dst[, $h[, $templateWindowSize[, $searchWindowSize]]]] ) -> dst

void cv::fastNlMeansDenoisingMulti( _InputArray               srcImgs
                                    _OutputArray              dst
                                    int                       imgToDenoiseIndex
                                    int                       temporalWindowSize
                                    const std::vector<float>& h
                                    int                       templateWindowSize = 7
                                    int                       searchWindowSize = 21
                                    int                       normType = NORM_L2 )

AutoIt:
    cv.fastNlMeansDenoisingMulti( $srcImgs, $imgToDenoiseIndex, $temporalWindowSize, $h[, $dst[, $templateWindowSize[, $searchWindowSize[, $normType]]]] ) -> dst

void cv::fastNlMeansDenoisingColoredMulti( _InputArray  srcImgs
                                           _OutputArray dst
                                           int          imgToDenoiseIndex
                                           int          temporalWindowSize
                                           float        h = 3
                                           float        hColor = 3
                                           int          templateWindowSize = 7
                                           int          searchWindowSize = 21 )

AutoIt:
    cv.fastNlMeansDenoisingColoredMulti( $srcImgs, $imgToDenoiseIndex, $temporalWindowSize[, $dst[, $h[, $hColor[, $templateWindowSize[, $searchWindowSize]]]]] ) -> dst

void cv::denoise_TVL1( const std::vector<cv::Mat>& observations
                       cv::Mat&                    result
                       double                      lambda = 1.0
                       int                         niters = 30 )

AutoIt:
    cv.denoise_TVL1( $observations, $result[, $lambda[, $niters]] ) -> None

cv::Ptr<cv::Tonemap> cv::createTonemap( float gamma = 1.0f )

AutoIt:
    cv.createTonemap( [$gamma] ) -> retval

cv::Ptr<cv::TonemapDrago> cv::createTonemapDrago( float gamma = 1.0f
                                                  float saturation = 1.0f
                                                  float bias = 0.85f )

AutoIt:
    cv.createTonemapDrago( [$gamma[, $saturation[, $bias]]] ) -> retval

cv::Ptr<cv::TonemapReinhard> cv::createTonemapReinhard( float gamma = 1.0f
                                                        float intensity = 0.0f
                                                        float light_adapt = 1.0f
                                                        float color_adapt = 0.0f )

AutoIt:
    cv.createTonemapReinhard( [$gamma[, $intensity[, $light_adapt[, $color_adapt]]]] ) -> retval

cv::Ptr<cv::TonemapMantiuk> cv::createTonemapMantiuk( float gamma = 1.0f
                                                      float scale = 0.7f
                                                      float saturation = 1.0f )

AutoIt:
    cv.createTonemapMantiuk( [$gamma[, $scale[, $saturation]]] ) -> retval

cv::Ptr<cv::AlignMTB> cv::createAlignMTB( int  max_bits = 6
                                          int  exclude_range = 4
                                          bool cut = true )

AutoIt:
    cv.createAlignMTB( [$max_bits[, $exclude_range[, $cut]]] ) -> retval

cv::Ptr<cv::CalibrateDebevec> cv::createCalibrateDebevec( int   samples = 70
                                                          float lambda = 10.0f
                                                          bool  random = false )

AutoIt:
    cv.createCalibrateDebevec( [$samples[, $lambda[, $random]]] ) -> retval

cv::Ptr<cv::CalibrateRobertson> cv::createCalibrateRobertson( int   max_iter = 30
                                                              float threshold = 0.01f )

AutoIt:
    cv.createCalibrateRobertson( [$max_iter[, $threshold]] ) -> retval

cv::Ptr<cv::MergeDebevec> cv::createMergeDebevec()

AutoIt:
    cv.createMergeDebevec() -> retval

cv::Ptr<cv::MergeMertens> cv::createMergeMertens( float contrast_weight = 1.0f
                                                  float saturation_weight = 1.0f
                                                  float exposure_weight = 0.0f )

AutoIt:
    cv.createMergeMertens( [$contrast_weight[, $saturation_weight[, $exposure_weight]]] ) -> retval

cv::Ptr<cv::MergeRobertson> cv::createMergeRobertson()

AutoIt:
    cv.createMergeRobertson() -> retval

void cv::decolor( _InputArray  src
                  _OutputArray grayscale
                  _OutputArray color_boost )

AutoIt:
    cv.decolor( $src[, $grayscale[, $color_boost]] ) -> grayscale, color_boost

void cv::seamlessClone( _InputArray  src
                        _InputArray  dst
                        _InputArray  mask
                        cv::Point    p
                        _OutputArray blend
                        int          flags )

AutoIt:
    cv.seamlessClone( $src, $dst, $mask, $p, $flags[, $blend] ) -> blend

void cv::colorChange( _InputArray  src
                      _InputArray  mask
                      _OutputArray dst
                      float        red_mul = 1.0f
                      float        green_mul = 1.0f
                      float        blue_mul = 1.0f )

AutoIt:
    cv.colorChange( $src, $mask[, $dst[, $red_mul[, $green_mul[, $blue_mul]]]] ) -> dst

void cv::illuminationChange( _InputArray  src
                             _InputArray  mask
                             _OutputArray dst
                             float        alpha = 0.2f
                             float        beta = 0.4f )

AutoIt:
    cv.illuminationChange( $src, $mask[, $dst[, $alpha[, $beta]]] ) -> dst

void cv::textureFlattening( _InputArray  src
                            _InputArray  mask
                            _OutputArray dst
                            float        low_threshold = 30
                            float        high_threshold = 45
                            int          kernel_size = 3 )

AutoIt:
    cv.textureFlattening( $src, $mask[, $dst[, $low_threshold[, $high_threshold[, $kernel_size]]]] ) -> dst

void cv::edgePreservingFilter( _InputArray  src
                               _OutputArray dst
                               int          flags = 1
                               float        sigma_s = 60
                               float        sigma_r = 0.4f )

AutoIt:
    cv.edgePreservingFilter( $src[, $dst[, $flags[, $sigma_s[, $sigma_r]]]] ) -> dst

void cv::detailEnhance( _InputArray  src
                        _OutputArray dst
                        float        sigma_s = 10
                        float        sigma_r = 0.15f )

AutoIt:
    cv.detailEnhance( $src[, $dst[, $sigma_s[, $sigma_r]]] ) -> dst

void cv::pencilSketch( _InputArray  src
                       _OutputArray dst1
                       _OutputArray dst2
                       float        sigma_s = 60
                       float        sigma_r = 0.07f
                       float        shade_factor = 0.02f )

AutoIt:
    cv.pencilSketch( $src[, $dst1[, $dst2[, $sigma_s[, $sigma_r[, $shade_factor]]]]] ) -> dst1, dst2

void cv::stylization( _InputArray  src
                      _OutputArray dst
                      float        sigma_s = 60
                      float        sigma_r = 0.45f )

AutoIt:
    cv.stylization( $src[, $dst[, $sigma_s[, $sigma_r]]] ) -> dst

void cv::drawKeypoints( _InputArray                      image
                        const std::vector<cv::KeyPoint>& keypoints
                        _InputOutputArray                outImage
                        const cv::Scalar&                color = Scalar::all(-1)
                        int                              flags = DrawMatchesFlags::DEFAULT )

AutoIt:
    cv.drawKeypoints( $image, $keypoints, $outImage[, $color[, $flags]] ) -> outImage

void cv::drawMatches( _InputArray                      img1
                      const std::vector<cv::KeyPoint>& keypoints1
                      _InputArray                      img2
                      const std::vector<cv::KeyPoint>& keypoints2
                      const std::vector<cv::DMatch>&   matches1to2
                      _InputOutputArray                outImg
                      const cv::Scalar&                matchColor = Scalar::all(-1)
                      const cv::Scalar&                singlePointColor = Scalar::all(-1)
                      const std::vector<char>&         matchesMask = std::vector<char>()
                      int                              flags = DrawMatchesFlags::DEFAULT )

AutoIt:
    cv.drawMatches( $img1, $keypoints1, $img2, $keypoints2, $matches1to2, $outImg[, $matchColor[, $singlePointColor[, $matchesMask[, $flags]]]] ) -> outImg

void cv::drawMatches( _InputArray                      img1
                      const std::vector<cv::KeyPoint>& keypoints1
                      _InputArray                      img2
                      const std::vector<cv::KeyPoint>& keypoints2
                      const std::vector<cv::DMatch>&   matches1to2
                      _InputOutputArray                outImg
                      const int                        matchesThickness
                      const cv::Scalar&                matchColor = Scalar::all(-1)
                      const cv::Scalar&                singlePointColor = Scalar::all(-1)
                      const std::vector<char>&         matchesMask = std::vector<char>()
                      int                              flags = DrawMatchesFlags::DEFAULT )

AutoIt:
    cv.drawMatches( $img1, $keypoints1, $img2, $keypoints2, $matches1to2, $outImg, $matchesThickness[, $matchColor[, $singlePointColor[, $matchesMask[, $flags]]]] ) -> outImg

void cv::drawMatchesKnn( _InputArray                                 img1
                         const std::vector<cv::KeyPoint>&            keypoints1
                         _InputArray                                 img2
                         const std::vector<cv::KeyPoint>&            keypoints2
                         const std::vector<std::vector<cv::DMatch>>& matches1to2
                         _InputOutputArray                           outImg
                         const cv::Scalar&                           matchColor = Scalar::all(-1)
                         const cv::Scalar&                           singlePointColor = Scalar::all(-1)
                         const std::vector<std::vector<char>>&       matchesMask = std::vector<std::vector<char> >()
                         int                                         flags = DrawMatchesFlags::DEFAULT )

AutoIt:
    cv.drawMatchesKnn( $img1, $keypoints1, $img2, $keypoints2, $matches1to2, $outImg[, $matchColor[, $singlePointColor[, $matchesMask[, $flags]]]] ) -> outImg

cv::Mat cv::imread( const std::string& filename
                    int                flags = IMREAD_COLOR )

AutoIt:
    cv.imread( $filename[, $flags] ) -> retval

bool cv::imreadmulti( const std::string&    filename
                      std::vector<cv::Mat>& mats
                      int                   flags = IMREAD_ANYCOLOR )

AutoIt:
    cv.imreadmulti( $filename[, $flags[, $mats]] ) -> retval, mats

bool cv::imreadmulti( const std::string&    filename
                      std::vector<cv::Mat>& mats
                      int                   start
                      int                   count
                      int                   flags = IMREAD_ANYCOLOR )

AutoIt:
    cv.imreadmulti( $filename, $start, $count[, $flags[, $mats]] ) -> retval, mats

size_t cv::imcount( const std::string& filename
                    int                flags = IMREAD_ANYCOLOR )

AutoIt:
    cv.imcount( $filename[, $flags] ) -> retval

bool cv::imwrite( const std::string&      filename
                  _InputArray             img
                  const std::vector<int>& params = std::vector<int>() )

AutoIt:
    cv.imwrite( $filename, $img[, $params] ) -> retval

bool cv::imwritemulti( const std::string&      filename
                       _InputArray             img
                       const std::vector<int>& params = std::vector<int>() )

AutoIt:
    cv.imwritemulti( $filename, $img[, $params] ) -> retval

cv::Mat cv::imdecode( _InputArray buf
                      int         flags )

AutoIt:
    cv.imdecode( $buf, $flags ) -> retval

bool cv::imencode( const std::string&      ext
                   _InputArray             img
                   std::vector<uchar>&     buf
                   const std::vector<int>& params = std::vector<int>() )

AutoIt:
    cv.imencode( $ext, $img[, $params[, $buf]] ) -> retval, buf

bool cv::haveImageReader( const std::string& filename )

AutoIt:
    cv.haveImageReader( $filename ) -> retval

bool cv::haveImageWriter( const std::string& filename )

AutoIt:
    cv.haveImageWriter( $filename ) -> retval

void cv::Rodrigues( _InputArray  src
                    _OutputArray dst
                    _OutputArray jacobian = noArray() )

AutoIt:
    cv.Rodrigues( $src[, $dst[, $jacobian]] ) -> dst, jacobian

cv::Mat cv::findHomography( _InputArray  srcPoints
                            _InputArray  dstPoints
                            int          method = 0
                            double       ransacReprojThreshold = 3
                            _OutputArray mask = noArray()
                            const int    maxIters = 2000
                            const double confidence = 0.995 )

AutoIt:
    cv.findHomography( $srcPoints, $dstPoints[, $method[, $ransacReprojThreshold[, $mask[, $maxIters[, $confidence]]]]] ) -> retval, mask

cv::Mat cv::findHomography( _InputArray           srcPoints
                            _InputArray           dstPoints
                            _OutputArray          mask
                            const cv::UsacParams& params )

AutoIt:
    cv.findHomography( $srcPoints, $dstPoints, $params[, $mask] ) -> retval, mask

cv::Vec3d cv::RQDecomp3x3( _InputArray  src
                           _OutputArray mtxR
                           _OutputArray mtxQ
                           _OutputArray Qx = noArray()
                           _OutputArray Qy = noArray()
                           _OutputArray Qz = noArray() )

AutoIt:
    cv.RQDecomp3x3( $src[, $mtxR[, $mtxQ[, $Qx[, $Qy[, $Qz]]]]] ) -> retval, mtxR, mtxQ, Qx, Qy, Qz

void cv::decomposeProjectionMatrix( _InputArray  projMatrix
                                    _OutputArray cameraMatrix
                                    _OutputArray rotMatrix
                                    _OutputArray transVect
                                    _OutputArray rotMatrixX = noArray()
                                    _OutputArray rotMatrixY = noArray()
                                    _OutputArray rotMatrixZ = noArray()
                                    _OutputArray eulerAngles = noArray() )

AutoIt:
    cv.decomposeProjectionMatrix( $projMatrix[, $cameraMatrix[, $rotMatrix[, $transVect[, $rotMatrixX[, $rotMatrixY[, $rotMatrixZ[, $eulerAngles]]]]]]] ) -> cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles

void cv::matMulDeriv( _InputArray  A
                      _InputArray  B
                      _OutputArray dABdA
                      _OutputArray dABdB )

AutoIt:
    cv.matMulDeriv( $A, $B[, $dABdA[, $dABdB]] ) -> dABdA, dABdB

void cv::composeRT( _InputArray  rvec1
                    _InputArray  tvec1
                    _InputArray  rvec2
                    _InputArray  tvec2
                    _OutputArray rvec3
                    _OutputArray tvec3
                    _OutputArray dr3dr1 = noArray()
                    _OutputArray dr3dt1 = noArray()
                    _OutputArray dr3dr2 = noArray()
                    _OutputArray dr3dt2 = noArray()
                    _OutputArray dt3dr1 = noArray()
                    _OutputArray dt3dt1 = noArray()
                    _OutputArray dt3dr2 = noArray()
                    _OutputArray dt3dt2 = noArray() )

AutoIt:
    cv.composeRT( $rvec1, $tvec1, $rvec2, $tvec2[, $rvec3[, $tvec3[, $dr3dr1[, $dr3dt1[, $dr3dr2[, $dr3dt2[, $dt3dr1[, $dt3dt1[, $dt3dr2[, $dt3dt2]]]]]]]]]] ) -> rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2

void cv::projectPoints( _InputArray  objectPoints
                        _InputArray  rvec
                        _InputArray  tvec
                        _InputArray  cameraMatrix
                        _InputArray  distCoeffs
                        _OutputArray imagePoints
                        _OutputArray jacobian = noArray()
                        double       aspectRatio = 0 )

AutoIt:
    cv.projectPoints( $objectPoints, $rvec, $tvec, $cameraMatrix, $distCoeffs[, $imagePoints[, $jacobian[, $aspectRatio]]] ) -> imagePoints, jacobian

bool cv::solvePnP( _InputArray  objectPoints
                   _InputArray  imagePoints
                   _InputArray  cameraMatrix
                   _InputArray  distCoeffs
                   _OutputArray rvec
                   _OutputArray tvec
                   bool         useExtrinsicGuess = false
                   int          flags = SOLVEPNP_ITERATIVE )

AutoIt:
    cv.solvePnP( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs[, $rvec[, $tvec[, $useExtrinsicGuess[, $flags]]]] ) -> retval, rvec, tvec

bool cv::solvePnPRansac( _InputArray  objectPoints
                         _InputArray  imagePoints
                         _InputArray  cameraMatrix
                         _InputArray  distCoeffs
                         _OutputArray rvec
                         _OutputArray tvec
                         bool         useExtrinsicGuess = false
                         int          iterationsCount = 100
                         float        reprojectionError = 8.0
                         double       confidence = 0.99
                         _OutputArray inliers = noArray()
                         int          flags = SOLVEPNP_ITERATIVE )

AutoIt:
    cv.solvePnPRansac( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs[, $rvec[, $tvec[, $useExtrinsicGuess[, $iterationsCount[, $reprojectionError[, $confidence[, $inliers[, $flags]]]]]]]] ) -> retval, rvec, tvec, inliers

bool cv::solvePnPRansac( _InputArray           objectPoints
                         _InputArray           imagePoints
                         _InputOutputArray     cameraMatrix
                         _InputArray           distCoeffs
                         _OutputArray          rvec
                         _OutputArray          tvec
                         _OutputArray          inliers
                         const cv::UsacParams& params = UsacParams() )

AutoIt:
    cv.solvePnPRansac( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs[, $rvec[, $tvec[, $inliers[, $params]]]] ) -> retval, cameraMatrix, rvec, tvec, inliers

int cv::solveP3P( _InputArray  objectPoints
                  _InputArray  imagePoints
                  _InputArray  cameraMatrix
                  _InputArray  distCoeffs
                  _OutputArray rvecs
                  _OutputArray tvecs
                  int          flags )

AutoIt:
    cv.solveP3P( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs, $flags[, $rvecs[, $tvecs]] ) -> retval, rvecs, tvecs

void cv::solvePnPRefineLM( _InputArray       objectPoints
                           _InputArray       imagePoints
                           _InputArray       cameraMatrix
                           _InputArray       distCoeffs
                           _InputOutputArray rvec
                           _InputOutputArray tvec
                           cv::TermCriteria  criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON) )

AutoIt:
    cv.solvePnPRefineLM( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs, $rvec, $tvec[, $criteria] ) -> rvec, tvec

void cv::solvePnPRefineVVS( _InputArray       objectPoints
                            _InputArray       imagePoints
                            _InputArray       cameraMatrix
                            _InputArray       distCoeffs
                            _InputOutputArray rvec
                            _InputOutputArray tvec
                            cv::TermCriteria  criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)
                            double            VVSlambda = 1 )

AutoIt:
    cv.solvePnPRefineVVS( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs, $rvec, $tvec[, $criteria[, $VVSlambda]] ) -> rvec, tvec

int cv::solvePnPGeneric( _InputArray  objectPoints
                         _InputArray  imagePoints
                         _InputArray  cameraMatrix
                         _InputArray  distCoeffs
                         _OutputArray rvecs
                         _OutputArray tvecs
                         bool         useExtrinsicGuess = false
                         int          flags = SOLVEPNP_ITERATIVE
                         _InputArray  rvec = noArray()
                         _InputArray  tvec = noArray()
                         _OutputArray reprojectionError = noArray() )

AutoIt:
    cv.solvePnPGeneric( $objectPoints, $imagePoints, $cameraMatrix, $distCoeffs[, $rvecs[, $tvecs[, $useExtrinsicGuess[, $flags[, $rvec[, $tvec[, $reprojectionError]]]]]]] ) -> retval, rvecs, tvecs, reprojectionError

cv::Mat cv::initCameraMatrix2D( _InputArray objectPoints
                                _InputArray imagePoints
                                cv::Size    imageSize
                                double      aspectRatio = 1.0 )

AutoIt:
    cv.initCameraMatrix2D( $objectPoints, $imagePoints, $imageSize[, $aspectRatio] ) -> retval

bool cv::findChessboardCorners( _InputArray  image
                                cv::Size     patternSize
                                _OutputArray corners
                                int          flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE )

AutoIt:
    cv.findChessboardCorners( $image, $patternSize[, $corners[, $flags]] ) -> retval, corners

bool cv::checkChessboard( _InputArray img
                          cv::Size    size )

AutoIt:
    cv.checkChessboard( $img, $size ) -> retval

bool cv::findChessboardCornersSBWithMeta( _InputArray  image
                                          cv::Size     patternSize
                                          _OutputArray corners
                                          int          flags
                                          _OutputArray meta )

AutoIt:
    cv.findChessboardCornersSBWithMeta( $image, $patternSize, $flags[, $corners[, $meta]] ) -> retval, corners, meta

bool cv::findChessboardCornersSB( _InputArray  image
                                  cv::Size     patternSize
                                  _OutputArray corners
                                  int          flags = 0 )

AutoIt:
    cv.findChessboardCornersSB( $image, $patternSize[, $corners[, $flags]] ) -> retval, corners

cv::Scalar cv::estimateChessboardSharpness( _InputArray  image
                                            cv::Size     patternSize
                                            _InputArray  corners
                                            float        rise_distance = 0.8F
                                            bool         vertical = false
                                            _OutputArray sharpness = noArray() )

AutoIt:
    cv.estimateChessboardSharpness( $image, $patternSize, $corners[, $rise_distance[, $vertical[, $sharpness]]] ) -> retval, sharpness

bool cv::find4QuadCornerSubpix( _InputArray       img
                                _InputOutputArray corners
                                cv::Size          region_size )

AutoIt:
    cv.find4QuadCornerSubpix( $img, $corners, $region_size ) -> retval, corners

void cv::drawChessboardCorners( _InputOutputArray image
                                cv::Size          patternSize
                                _InputArray       corners
                                bool              patternWasFound )

AutoIt:
    cv.drawChessboardCorners( $image, $patternSize, $corners, $patternWasFound ) -> image

void cv::drawFrameAxes( _InputOutputArray image
                        _InputArray       cameraMatrix
                        _InputArray       distCoeffs
                        _InputArray       rvec
                        _InputArray       tvec
                        float             length
                        int               thickness = 3 )

AutoIt:
    cv.drawFrameAxes( $image, $cameraMatrix, $distCoeffs, $rvec, $tvec, $length[, $thickness] ) -> image

bool cv::findCirclesGrid( _InputArray                            image
                          cv::Size                               patternSize
                          _OutputArray                           centers
                          int                                    flags
                          const cv::Ptr<cv::Feature2D>&          blobDetector
                          const cv::CirclesGridFinderParameters& parameters )

AutoIt:
    cv.findCirclesGrid( $image, $patternSize, $flags, $blobDetector, $parameters[, $centers] ) -> retval, centers

bool cv::findCirclesGrid( _InputArray                   image
                          cv::Size                      patternSize
                          _OutputArray                  centers
                          int                           flags = CALIB_CB_SYMMETRIC_GRID
                          const cv::Ptr<cv::Feature2D>& blobDetector = SimpleBlobDetector::create() )

AutoIt:
    cv.findCirclesGrid( $image, $patternSize[, $centers[, $flags[, $blobDetector]]] ) -> retval, centers

double cv::calibrateCameraExtended( _InputArray       objectPoints
                                    _InputArray       imagePoints
                                    cv::Size          imageSize
                                    _InputOutputArray cameraMatrix
                                    _InputOutputArray distCoeffs
                                    _OutputArray      rvecs
                                    _OutputArray      tvecs
                                    _OutputArray      stdDeviationsIntrinsics
                                    _OutputArray      stdDeviationsExtrinsics
                                    _OutputArray      perViewErrors
                                    int               flags = 0
                                    cv::TermCriteria  criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) )

AutoIt:
    cv.calibrateCameraExtended( $objectPoints, $imagePoints, $imageSize, $cameraMatrix, $distCoeffs[, $rvecs[, $tvecs[, $stdDeviationsIntrinsics[, $stdDeviationsExtrinsics[, $perViewErrors[, $flags[, $criteria]]]]]]] ) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors

double cv::calibrateCamera( _InputArray       objectPoints
                            _InputArray       imagePoints
                            cv::Size          imageSize
                            _InputOutputArray cameraMatrix
                            _InputOutputArray distCoeffs
                            _OutputArray      rvecs
                            _OutputArray      tvecs
                            int               flags = 0
                            cv::TermCriteria  criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) )

AutoIt:
    cv.calibrateCamera( $objectPoints, $imagePoints, $imageSize, $cameraMatrix, $distCoeffs[, $rvecs[, $tvecs[, $flags[, $criteria]]]] ) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs

double cv::calibrateCameraROExtended( _InputArray       objectPoints
                                      _InputArray       imagePoints
                                      cv::Size          imageSize
                                      int               iFixedPoint
                                      _InputOutputArray cameraMatrix
                                      _InputOutputArray distCoeffs
                                      _OutputArray      rvecs
                                      _OutputArray      tvecs
                                      _OutputArray      newObjPoints
                                      _OutputArray      stdDeviationsIntrinsics
                                      _OutputArray      stdDeviationsExtrinsics
                                      _OutputArray      stdDeviationsObjPoints
                                      _OutputArray      perViewErrors
                                      int               flags = 0
                                      cv::TermCriteria  criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) )

AutoIt:
    cv.calibrateCameraROExtended( $objectPoints, $imagePoints, $imageSize, $iFixedPoint, $cameraMatrix, $distCoeffs[, $rvecs[, $tvecs[, $newObjPoints[, $stdDeviationsIntrinsics[, $stdDeviationsExtrinsics[, $stdDeviationsObjPoints[, $perViewErrors[, $flags[, $criteria]]]]]]]]] ) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors

double cv::calibrateCameraRO( _InputArray       objectPoints
                              _InputArray       imagePoints
                              cv::Size          imageSize
                              int               iFixedPoint
                              _InputOutputArray cameraMatrix
                              _InputOutputArray distCoeffs
                              _OutputArray      rvecs
                              _OutputArray      tvecs
                              _OutputArray      newObjPoints
                              int               flags = 0
                              cv::TermCriteria  criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) )

AutoIt:
    cv.calibrateCameraRO( $objectPoints, $imagePoints, $imageSize, $iFixedPoint, $cameraMatrix, $distCoeffs[, $rvecs[, $tvecs[, $newObjPoints[, $flags[, $criteria]]]]] ) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints

void cv::calibrationMatrixValues( _InputArray  cameraMatrix
                                  cv::Size     imageSize
                                  double       apertureWidth
                                  double       apertureHeight
                                  double&      fovx
                                  double&      fovy
                                  double&      focalLength
                                  cv::Point2d& principalPoint
                                  double&      aspectRatio )

AutoIt:
    cv.calibrationMatrixValues( $cameraMatrix, $imageSize, $apertureWidth, $apertureHeight[, $fovx[, $fovy[, $focalLength[, $principalPoint[, $aspectRatio]]]]] ) -> fovx, fovy, focalLength, principalPoint, aspectRatio

double cv::stereoCalibrateExtended( _InputArray       objectPoints
                                    _InputArray       imagePoints1
                                    _InputArray       imagePoints2
                                    _InputOutputArray cameraMatrix1
                                    _InputOutputArray distCoeffs1
                                    _InputOutputArray cameraMatrix2
                                    _InputOutputArray distCoeffs2
                                    cv::Size          imageSize
                                    _InputOutputArray R
                                    _InputOutputArray T
                                    _OutputArray      E
                                    _OutputArray      F
                                    _OutputArray      perViewErrors
                                    int               flags = CALIB_FIX_INTRINSIC
                                    cv::TermCriteria  criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) )

AutoIt:
    cv.stereoCalibrateExtended( $objectPoints, $imagePoints1, $imagePoints2, $cameraMatrix1, $distCoeffs1, $cameraMatrix2, $distCoeffs2, $imageSize, $R, $T[, $E[, $F[, $perViewErrors[, $flags[, $criteria]]]]] ) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, perViewErrors

double cv::stereoCalibrate( _InputArray       objectPoints
                            _InputArray       imagePoints1
                            _InputArray       imagePoints2
                            _InputOutputArray cameraMatrix1
                            _InputOutputArray distCoeffs1
                            _InputOutputArray cameraMatrix2
                            _InputOutputArray distCoeffs2
                            cv::Size          imageSize
                            _OutputArray      R
                            _OutputArray      T
                            _OutputArray      E
                            _OutputArray      F
                            int               flags = CALIB_FIX_INTRINSIC
                            cv::TermCriteria  criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) )

AutoIt:
    cv.stereoCalibrate( $objectPoints, $imagePoints1, $imagePoints2, $cameraMatrix1, $distCoeffs1, $cameraMatrix2, $distCoeffs2, $imageSize[, $R[, $T[, $E[, $F[, $flags[, $criteria]]]]]] ) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F

void cv::stereoRectify( _InputArray  cameraMatrix1
                        _InputArray  distCoeffs1
                        _InputArray  cameraMatrix2
                        _InputArray  distCoeffs2
                        cv::Size     imageSize
                        _InputArray  R
                        _InputArray  T
                        _OutputArray R1
                        _OutputArray R2
                        _OutputArray P1
                        _OutputArray P2
                        _OutputArray Q
                        int          flags = CALIB_ZERO_DISPARITY
                        double       alpha = -1
                        cv::Size     newImageSize = Size()
                        cv::Rect*    validPixROI1 = 0
                        cv::Rect*    validPixROI2 = 0 )

AutoIt:
    cv.stereoRectify( $cameraMatrix1, $distCoeffs1, $cameraMatrix2, $distCoeffs2, $imageSize, $R, $T[, $R1[, $R2[, $P1[, $P2[, $Q[, $flags[, $alpha[, $newImageSize[, $validPixROI1[, $validPixROI2]]]]]]]]]] ) -> R1, R2, P1, P2, Q, validPixROI1, validPixROI2

bool cv::stereoRectifyUncalibrated( _InputArray  points1
                                    _InputArray  points2
                                    _InputArray  F
                                    cv::Size     imgSize
                                    _OutputArray H1
                                    _OutputArray H2
                                    double       threshold = 5 )

AutoIt:
    cv.stereoRectifyUncalibrated( $points1, $points2, $F, $imgSize[, $H1[, $H2[, $threshold]]] ) -> retval, H1, H2

float cv::rectify3Collinear( _InputArray  cameraMatrix1
                             _InputArray  distCoeffs1
                             _InputArray  cameraMatrix2
                             _InputArray  distCoeffs2
                             _InputArray  cameraMatrix3
                             _InputArray  distCoeffs3
                             _InputArray  imgpt1
                             _InputArray  imgpt3
                             cv::Size     imageSize
                             _InputArray  R12
                             _InputArray  T12
                             _InputArray  R13
                             _InputArray  T13
                             _OutputArray R1
                             _OutputArray R2
                             _OutputArray R3
                             _OutputArray P1
                             _OutputArray P2
                             _OutputArray P3
                             _OutputArray Q
                             double       alpha
                             cv::Size     newImgSize
                             cv::Rect*    roi1
                             cv::Rect*    roi2
                             int          flags )

AutoIt:
    cv.rectify3Collinear( $cameraMatrix1, $distCoeffs1, $cameraMatrix2, $distCoeffs2, $cameraMatrix3, $distCoeffs3, $imgpt1, $imgpt3, $imageSize, $R12, $T12, $R13, $T13, $alpha, $newImgSize, $flags[, $R1[, $R2[, $R3[, $P1[, $P2[, $P3[, $Q[, $roi1[, $roi2]]]]]]]]] ) -> retval, R1, R2, R3, P1, P2, P3, Q, roi1, roi2

cv::Mat cv::getOptimalNewCameraMatrix( _InputArray cameraMatrix
                                       _InputArray distCoeffs
                                       cv::Size    imageSize
                                       double      alpha
                                       cv::Size    newImgSize = Size()
                                       cv::Rect*   validPixROI = 0
                                       bool        centerPrincipalPoint = false )

AutoIt:
    cv.getOptimalNewCameraMatrix( $cameraMatrix, $distCoeffs, $imageSize, $alpha[, $newImgSize[, $centerPrincipalPoint[, $validPixROI]]] ) -> retval, validPixROI

void cv::calibrateHandEye( _InputArray  R_gripper2base
                           _InputArray  t_gripper2base
                           _InputArray  R_target2cam
                           _InputArray  t_target2cam
                           _OutputArray R_cam2gripper
                           _OutputArray t_cam2gripper
                           int          method = CALIB_HAND_EYE_TSAI )

AutoIt:
    cv.calibrateHandEye( $R_gripper2base, $t_gripper2base, $R_target2cam, $t_target2cam[, $R_cam2gripper[, $t_cam2gripper[, $method]]] ) -> R_cam2gripper, t_cam2gripper

void cv::calibrateRobotWorldHandEye( _InputArray  R_world2cam
                                     _InputArray  t_world2cam
                                     _InputArray  R_base2gripper
                                     _InputArray  t_base2gripper
                                     _OutputArray R_base2world
                                     _OutputArray t_base2world
                                     _OutputArray R_gripper2cam
                                     _OutputArray t_gripper2cam
                                     int          method = CALIB_ROBOT_WORLD_HAND_EYE_SHAH )

AutoIt:
    cv.calibrateRobotWorldHandEye( $R_world2cam, $t_world2cam, $R_base2gripper, $t_base2gripper[, $R_base2world[, $t_base2world[, $R_gripper2cam[, $t_gripper2cam[, $method]]]]] ) -> R_base2world, t_base2world, R_gripper2cam, t_gripper2cam

void cv::convertPointsToHomogeneous( _InputArray  src
                                     _OutputArray dst )

AutoIt:
    cv.convertPointsToHomogeneous( $src[, $dst] ) -> dst

void cv::convertPointsFromHomogeneous( _InputArray  src
                                       _OutputArray dst )

AutoIt:
    cv.convertPointsFromHomogeneous( $src[, $dst] ) -> dst

cv::Mat cv::findFundamentalMat( _InputArray  points1
                                _InputArray  points2
                                int          method
                                double       ransacReprojThreshold
                                double       confidence
                                int          maxIters
                                _OutputArray mask = noArray() )

AutoIt:
    cv.findFundamentalMat( $points1, $points2, $method, $ransacReprojThreshold, $confidence, $maxIters[, $mask] ) -> retval, mask

cv::Mat cv::findFundamentalMat( _InputArray  points1
                                _InputArray  points2
                                int          method = FM_RANSAC
                                double       ransacReprojThreshold = 3.
                                double       confidence = 0.99
                                _OutputArray mask = noArray() )

AutoIt:
    cv.findFundamentalMat( $points1, $points2[, $method[, $ransacReprojThreshold[, $confidence[, $mask]]]] ) -> retval, mask

cv::Mat cv::findFundamentalMat( _InputArray           points1
                                _InputArray           points2
                                _OutputArray          mask
                                const cv::UsacParams& params )

AutoIt:
    cv.findFundamentalMat( $points1, $points2, $params[, $mask] ) -> retval, mask

cv::Mat cv::findEssentialMat( _InputArray  points1
                              _InputArray  points2
                              _InputArray  cameraMatrix
                              int          method = RANSAC
                              double       prob = 0.999
                              double       threshold = 1.0
                              int          maxIters = 1000
                              _OutputArray mask = noArray() )

AutoIt:
    cv.findEssentialMat( $points1, $points2, $cameraMatrix[, $method[, $prob[, $threshold[, $maxIters[, $mask]]]]] ) -> retval, mask

cv::Mat cv::findEssentialMat( _InputArray  points1
                              _InputArray  points2
                              double       focal = 1.0
                              cv::Point2d  pp = Point2d(0, 0)
                              int          method = RANSAC
                              double       prob = 0.999
                              double       threshold = 1.0
                              int          maxIters = 1000
                              _OutputArray mask = noArray() )

AutoIt:
    cv.findEssentialMat( $points1, $points2[, $focal[, $pp[, $method[, $prob[, $threshold[, $maxIters[, $mask]]]]]]] ) -> retval, mask

cv::Mat cv::findEssentialMat( _InputArray  points1
                              _InputArray  points2
                              _InputArray  cameraMatrix1
                              _InputArray  distCoeffs1
                              _InputArray  cameraMatrix2
                              _InputArray  distCoeffs2
                              int          method = RANSAC
                              double       prob = 0.999
                              double       threshold = 1.0
                              _OutputArray mask = noArray() )

AutoIt:
    cv.findEssentialMat( $points1, $points2, $cameraMatrix1, $distCoeffs1, $cameraMatrix2, $distCoeffs2[, $method[, $prob[, $threshold[, $mask]]]] ) -> retval, mask

cv::Mat cv::findEssentialMat( _InputArray           points1
                              _InputArray           points2
                              _InputArray           cameraMatrix1
                              _InputArray           cameraMatrix2
                              _InputArray           dist_coeff1
                              _InputArray           dist_coeff2
                              _OutputArray          mask
                              const cv::UsacParams& params )

AutoIt:
    cv.findEssentialMat( $points1, $points2, $cameraMatrix1, $cameraMatrix2, $dist_coeff1, $dist_coeff2, $params[, $mask] ) -> retval, mask

void cv::decomposeEssentialMat( _InputArray  E
                                _OutputArray R1
                                _OutputArray R2
                                _OutputArray t )

AutoIt:
    cv.decomposeEssentialMat( $E[, $R1[, $R2[, $t]]] ) -> R1, R2, t

int cv::recoverPose( _InputArray       points1
                     _InputArray       points2
                     _InputArray       cameraMatrix1
                     _InputArray       distCoeffs1
                     _InputArray       cameraMatrix2
                     _InputArray       distCoeffs2
                     _OutputArray      E
                     _OutputArray      R
                     _OutputArray      t
                     int               method = cv::RANSAC
                     double            prob = 0.999
                     double            threshold = 1.0
                     _InputOutputArray mask = noArray() )

AutoIt:
    cv.recoverPose( $points1, $points2, $cameraMatrix1, $distCoeffs1, $cameraMatrix2, $distCoeffs2[, $E[, $R[, $t[, $method[, $prob[, $threshold[, $mask]]]]]]] ) -> retval, E, R, t, mask

int cv::recoverPose( _InputArray       E
                     _InputArray       points1
                     _InputArray       points2
                     _InputArray       cameraMatrix
                     _OutputArray      R
                     _OutputArray      t
                     _InputOutputArray mask = noArray() )

AutoIt:
    cv.recoverPose( $E, $points1, $points2, $cameraMatrix[, $R[, $t[, $mask]]] ) -> retval, R, t, mask

int cv::recoverPose( _InputArray       E
                     _InputArray       points1
                     _InputArray       points2
                     _OutputArray      R
                     _OutputArray      t
                     double            focal = 1.0
                     cv::Point2d       pp = Point2d(0, 0)
                     _InputOutputArray mask = noArray() )

AutoIt:
    cv.recoverPose( $E, $points1, $points2[, $R[, $t[, $focal[, $pp[, $mask]]]]] ) -> retval, R, t, mask

int cv::recoverPose( _InputArray       E
                     _InputArray       points1
                     _InputArray       points2
                     _InputArray       cameraMatrix
                     _OutputArray      R
                     _OutputArray      t
                     double            distanceThresh
                     _InputOutputArray mask = noArray()
                     _OutputArray      triangulatedPoints = noArray() )

AutoIt:
    cv.recoverPose( $E, $points1, $points2, $cameraMatrix, $distanceThresh[, $R[, $t[, $mask[, $triangulatedPoints]]]] ) -> retval, R, t, mask, triangulatedPoints

void cv::computeCorrespondEpilines( _InputArray  points
                                    int          whichImage
                                    _InputArray  F
                                    _OutputArray lines )

AutoIt:
    cv.computeCorrespondEpilines( $points, $whichImage, $F[, $lines] ) -> lines

void cv::triangulatePoints( _InputArray  projMatr1
                            _InputArray  projMatr2
                            _InputArray  projPoints1
                            _InputArray  projPoints2
                            _OutputArray points4D )

AutoIt:
    cv.triangulatePoints( $projMatr1, $projMatr2, $projPoints1, $projPoints2[, $points4D] ) -> points4D

void cv::correctMatches( _InputArray  F
                         _InputArray  points1
                         _InputArray  points2
                         _OutputArray newPoints1
                         _OutputArray newPoints2 )

AutoIt:
    cv.correctMatches( $F, $points1, $points2[, $newPoints1[, $newPoints2]] ) -> newPoints1, newPoints2

void cv::filterSpeckles( _InputOutputArray img
                         double            newVal
                         int               maxSpeckleSize
                         double            maxDiff
                         _InputOutputArray buf = noArray() )

AutoIt:
    cv.filterSpeckles( $img, $newVal, $maxSpeckleSize, $maxDiff[, $buf] ) -> img, buf

cv::Rect cv::getValidDisparityROI( cv::Rect roi1
                                   cv::Rect roi2
                                   int      minDisparity
                                   int      numberOfDisparities
                                   int      blockSize )

AutoIt:
    cv.getValidDisparityROI( $roi1, $roi2, $minDisparity, $numberOfDisparities, $blockSize ) -> retval

void cv::validateDisparity( _InputOutputArray disparity
                            _InputArray       cost
                            int               minDisparity
                            int               numberOfDisparities
                            int               disp12MaxDisp = 1 )

AutoIt:
    cv.validateDisparity( $disparity, $cost, $minDisparity, $numberOfDisparities[, $disp12MaxDisp] ) -> disparity

void cv::reprojectImageTo3D( _InputArray  disparity
                             _OutputArray _3dImage
                             _InputArray  Q
                             bool         handleMissingValues = false
                             int          ddepth = -1 )

AutoIt:
    cv.reprojectImageTo3D( $disparity, $Q[, $_3dImage[, $handleMissingValues[, $ddepth]]] ) -> _3dImage

double cv::sampsonDistance( _InputArray pt1
                            _InputArray pt2
                            _InputArray F )

AutoIt:
    cv.sampsonDistance( $pt1, $pt2, $F ) -> retval

int cv::estimateAffine3D( _InputArray  src
                          _InputArray  dst
                          _OutputArray out
                          _OutputArray inliers
                          double       ransacThreshold = 3
                          double       confidence = 0.99 )

AutoIt:
    cv.estimateAffine3D( $src, $dst[, $out[, $inliers[, $ransacThreshold[, $confidence]]]] ) -> retval, out, inliers

cv::Mat cv::estimateAffine3D( _InputArray src
                              _InputArray dst
                              double*     scale = nullptr
                              bool        force_rotation = true )

AutoIt:
    cv.estimateAffine3D( $src, $dst[, $force_rotation[, $scale]] ) -> retval, scale

int cv::estimateTranslation3D( _InputArray  src
                               _InputArray  dst
                               _OutputArray out
                               _OutputArray inliers
                               double       ransacThreshold = 3
                               double       confidence = 0.99 )

AutoIt:
    cv.estimateTranslation3D( $src, $dst[, $out[, $inliers[, $ransacThreshold[, $confidence]]]] ) -> retval, out, inliers

cv::Mat cv::estimateAffine2D( _InputArray  from
                              _InputArray  to
                              _OutputArray inliers = noArray()
                              int          method = RANSAC
                              double       ransacReprojThreshold = 3
                              size_t       maxIters = 2000
                              double       confidence = 0.99
                              size_t       refineIters = 10 )

AutoIt:
    cv.estimateAffine2D( $from, $to[, $inliers[, $method[, $ransacReprojThreshold[, $maxIters[, $confidence[, $refineIters]]]]]] ) -> retval, inliers

cv::Mat cv::estimateAffine2D( _InputArray           pts1
                              _InputArray           pts2
                              _OutputArray          inliers
                              const cv::UsacParams& params )

AutoIt:
    cv.estimateAffine2D( $pts1, $pts2, $params[, $inliers] ) -> retval, inliers

cv::Mat cv::estimateAffinePartial2D( _InputArray  from
                                     _InputArray  to
                                     _OutputArray inliers = noArray()
                                     int          method = RANSAC
                                     double       ransacReprojThreshold = 3
                                     size_t       maxIters = 2000
                                     double       confidence = 0.99
                                     size_t       refineIters = 10 )

AutoIt:
    cv.estimateAffinePartial2D( $from, $to[, $inliers[, $method[, $ransacReprojThreshold[, $maxIters[, $confidence[, $refineIters]]]]]] ) -> retval, inliers

int cv::decomposeHomographyMat( _InputArray  H
                                _InputArray  K
                                _OutputArray rotations
                                _OutputArray translations
                                _OutputArray normals )

AutoIt:
    cv.decomposeHomographyMat( $H, $K[, $rotations[, $translations[, $normals]]] ) -> retval, rotations, translations, normals

void cv::filterHomographyDecompByVisibleRefpoints( _InputArray  rotations
                                                   _InputArray  normals
                                                   _InputArray  beforePoints
                                                   _InputArray  afterPoints
                                                   _OutputArray possibleSolutions
                                                   _InputArray  pointsMask = noArray() )

AutoIt:
    cv.filterHomographyDecompByVisibleRefpoints( $rotations, $normals, $beforePoints, $afterPoints[, $possibleSolutions[, $pointsMask]] ) -> possibleSolutions

void cv::undistort( _InputArray  src
                    _OutputArray dst
                    _InputArray  cameraMatrix
                    _InputArray  distCoeffs
                    _InputArray  newCameraMatrix = noArray() )

AutoIt:
    cv.undistort( $src, $cameraMatrix, $distCoeffs[, $dst[, $newCameraMatrix]] ) -> dst

void cv::initUndistortRectifyMap( _InputArray  cameraMatrix
                                  _InputArray  distCoeffs
                                  _InputArray  R
                                  _InputArray  newCameraMatrix
                                  cv::Size     size
                                  int          m1type
                                  _OutputArray map1
                                  _OutputArray map2 )

AutoIt:
    cv.initUndistortRectifyMap( $cameraMatrix, $distCoeffs, $R, $newCameraMatrix, $size, $m1type[, $map1[, $map2]] ) -> map1, map2

void cv::initInverseRectificationMap( _InputArray     cameraMatrix
                                      _InputArray     distCoeffs
                                      _InputArray     R
                                      _InputArray     newCameraMatrix
                                      const cv::Size& size
                                      int             m1type
                                      _OutputArray    map1
                                      _OutputArray    map2 )

AutoIt:
    cv.initInverseRectificationMap( $cameraMatrix, $distCoeffs, $R, $newCameraMatrix, $size, $m1type[, $map1[, $map2]] ) -> map1, map2

cv::Mat cv::getDefaultNewCameraMatrix( _InputArray cameraMatrix
                                       cv::Size    imgsize = Size()
                                       bool        centerPrincipalPoint = false )

AutoIt:
    cv.getDefaultNewCameraMatrix( $cameraMatrix[, $imgsize[, $centerPrincipalPoint]] ) -> retval

void cv::undistortPoints( _InputArray  src
                          _OutputArray dst
                          _InputArray  cameraMatrix
                          _InputArray  distCoeffs
                          _InputArray  R = noArray()
                          _InputArray  P = noArray() )

AutoIt:
    cv.undistortPoints( $src, $cameraMatrix, $distCoeffs[, $dst[, $R[, $P]]] ) -> dst

void cv::undistortPointsIter( _InputArray      src
                              _OutputArray     dst
                              _InputArray      cameraMatrix
                              _InputArray      distCoeffs
                              _InputArray      R
                              _InputArray      P
                              cv::TermCriteria criteria )

AutoIt:
    cv.undistortPointsIter( $src, $cameraMatrix, $distCoeffs, $R, $P, $criteria[, $dst] ) -> dst

void cv::namedWindow( const std::string& winname
                      int                flags = WINDOW_AUTOSIZE )

AutoIt:
    cv.namedWindow( $winname[, $flags] ) -> None

void cv::destroyWindow( const std::string& winname )

AutoIt:
    cv.destroyWindow( $winname ) -> None

void cv::destroyAllWindows()

AutoIt:
    cv.destroyAllWindows() -> None

int cv::startWindowThread()

AutoIt:
    cv.startWindowThread() -> retval

int cv::waitKeyEx( int delay = 0 )

AutoIt:
    cv.waitKeyEx( [$delay] ) -> retval

int cv::waitKey( int delay = 0 )

AutoIt:
    cv.waitKey( [$delay] ) -> retval

int cv::pollKey()

AutoIt:
    cv.pollKey() -> retval

void cv::imshow( const std::string& winname
                 _InputArray        mat )

AutoIt:
    cv.imshow( $winname, $mat ) -> None

void cv::resizeWindow( const std::string& winname
                       int                width
                       int                height )

AutoIt:
    cv.resizeWindow( $winname, $width, $height ) -> None

void cv::resizeWindow( const std::string& winname
                       const cv::Size&    size )

AutoIt:
    cv.resizeWindow( $winname, $size ) -> None

void cv::moveWindow( const std::string& winname
                     int                x
                     int                y )

AutoIt:
    cv.moveWindow( $winname, $x, $y ) -> None

void cv::setWindowProperty( const std::string& winname
                            int                prop_id
                            double             prop_value )

AutoIt:
    cv.setWindowProperty( $winname, $prop_id, $prop_value ) -> None

void cv::setWindowTitle( const std::string& winname
                         const std::string& title )

AutoIt:
    cv.setWindowTitle( $winname, $title ) -> None

double cv::getWindowProperty( const std::string& winname
                              int                prop_id )

AutoIt:
    cv.getWindowProperty( $winname, $prop_id ) -> retval

cv::Rect cv::getWindowImageRect( const std::string& winname )

AutoIt:
    cv.getWindowImageRect( $winname ) -> retval

cv::Rect cv::selectROI( const std::string& windowName
                        _InputArray        img
                        bool               showCrosshair = true
                        bool               fromCenter = false )

AutoIt:
    cv.selectROI( $windowName, $img[, $showCrosshair[, $fromCenter]] ) -> retval

cv::Rect cv::selectROI( _InputArray img
                        bool        showCrosshair = true
                        bool        fromCenter = false )

AutoIt:
    cv.selectROI( $img[, $showCrosshair[, $fromCenter]] ) -> retval

void cv::selectROIs( const std::string&     windowName
                     _InputArray            img
                     std::vector<cv::Rect>& boundingBoxes
                     bool                   showCrosshair = true
                     bool                   fromCenter = false )

AutoIt:
    cv.selectROIs( $windowName, $img[, $showCrosshair[, $fromCenter[, $boundingBoxes]]] ) -> boundingBoxes

int cv::getTrackbarPos( const std::string& trackbarname
                        const std::string& winname )

AutoIt:
    cv.getTrackbarPos( $trackbarname, $winname ) -> retval

void cv::setTrackbarPos( const std::string& trackbarname
                         const std::string& winname
                         int                pos )

AutoIt:
    cv.setTrackbarPos( $trackbarname, $winname, $pos ) -> None

void cv::setTrackbarMax( const std::string& trackbarname
                         const std::string& winname
                         int                maxval )

AutoIt:
    cv.setTrackbarMax( $trackbarname, $winname, $maxval ) -> None

void cv::setTrackbarMin( const std::string& trackbarname
                         const std::string& winname
                         int                minval )

AutoIt:
    cv.setTrackbarMin( $trackbarname, $winname, $minval ) -> None

void cv::addText( const cv::Mat&     img
                  const std::string& text
                  cv::Point          org
                  const std::string& nameFont
                  int                pointSize = -1
                  cv::Scalar         color = Scalar::all(0)
                  int                weight = QT_FONT_NORMAL
                  int                style = QT_STYLE_NORMAL
                  int                spacing = 0 )

AutoIt:
    cv.addText( $img, $text, $org, $nameFont[, $pointSize[, $color[, $weight[, $style[, $spacing]]]]] ) -> None

void cv::displayOverlay( const std::string& winname
                         const std::string& text
                         int                delayms = 0 )

AutoIt:
    cv.displayOverlay( $winname, $text[, $delayms] ) -> None

void cv::displayStatusBar( const std::string& winname
                           const std::string& text
                           int                delayms = 0 )

AutoIt:
    cv.displayStatusBar( $winname, $text[, $delayms] ) -> None

void cv::groupRectangles( std::vector<cv::Rect>& rectList
                          std::vector<int>&      weights
                          int                    groupThreshold
                          double                 eps = 0.2 )

AutoIt:
    cv.groupRectangles( $rectList, $groupThreshold[, $eps[, $weights]] ) -> rectList, weights

cv::Ptr<cv::BackgroundSubtractorMOG2> cv::createBackgroundSubtractorMOG2( int    history = 500
                                                                          double varThreshold = 16
                                                                          bool   detectShadows = true )

AutoIt:
    cv.createBackgroundSubtractorMOG2( [$history[, $varThreshold[, $detectShadows]]] ) -> retval

cv::Ptr<cv::BackgroundSubtractorKNN> cv::createBackgroundSubtractorKNN( int    history = 500
                                                                        double dist2Threshold = 400.0
                                                                        bool   detectShadows = true )

AutoIt:
    cv.createBackgroundSubtractorKNN( [$history[, $dist2Threshold[, $detectShadows]]] ) -> retval

cv::RotatedRect cv::CamShift( _InputArray      probImage
                              cv::Rect&        window
                              cv::TermCriteria criteria )

AutoIt:
    cv.CamShift( $probImage, $window, $criteria ) -> retval, window

int cv::meanShift( _InputArray      probImage
                   cv::Rect&        window
                   cv::TermCriteria criteria )

AutoIt:
    cv.meanShift( $probImage, $window, $criteria ) -> retval, window

int cv::buildOpticalFlowPyramid( _InputArray  img
                                 _OutputArray pyramid
                                 cv::Size     winSize
                                 int          maxLevel
                                 bool         withDerivatives = true
                                 int          pyrBorder = BORDER_REFLECT_101
                                 int          derivBorder = BORDER_CONSTANT
                                 bool         tryReuseInputImage = true )

AutoIt:
    cv.buildOpticalFlowPyramid( $img, $winSize, $maxLevel[, $pyramid[, $withDerivatives[, $pyrBorder[, $derivBorder[, $tryReuseInputImage]]]]] ) -> retval, pyramid

void cv::calcOpticalFlowPyrLK( _InputArray       prevImg
                               _InputArray       nextImg
                               _InputArray       prevPts
                               _InputOutputArray nextPts
                               _OutputArray      status
                               _OutputArray      err
                               cv::Size          winSize = Size(21,21)
                               int               maxLevel = 3
                               cv::TermCriteria  criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)
                               int               flags = 0
                               double            minEigThreshold = 1e-4 )

AutoIt:
    cv.calcOpticalFlowPyrLK( $prevImg, $nextImg, $prevPts, $nextPts[, $status[, $err[, $winSize[, $maxLevel[, $criteria[, $flags[, $minEigThreshold]]]]]]] ) -> nextPts, status, err

void cv::calcOpticalFlowFarneback( _InputArray       prev
                                   _InputArray       next
                                   _InputOutputArray flow
                                   double            pyr_scale
                                   int               levels
                                   int               winsize
                                   int               iterations
                                   int               poly_n
                                   double            poly_sigma
                                   int               flags )

AutoIt:
    cv.calcOpticalFlowFarneback( $prev, $next, $flow, $pyr_scale, $levels, $winsize, $iterations, $poly_n, $poly_sigma, $flags ) -> flow

double cv::computeECC( _InputArray templateImage
                       _InputArray inputImage
                       _InputArray inputMask = noArray() )

AutoIt:
    cv.computeECC( $templateImage, $inputImage[, $inputMask] ) -> retval

double cv::findTransformECC( _InputArray       templateImage
                             _InputArray       inputImage
                             _InputOutputArray warpMatrix
                             int               motionType
                             cv::TermCriteria  criteria
                             _InputArray       inputMask
                             int               gaussFiltSize )

AutoIt:
    cv.findTransformECC( $templateImage, $inputImage, $warpMatrix, $motionType, $criteria, $inputMask, $gaussFiltSize ) -> retval, warpMatrix

double cv::findTransformECC( _InputArray       templateImage
                             _InputArray       inputImage
                             _InputOutputArray warpMatrix
                             int               motionType = MOTION_AFFINE
                             cv::TermCriteria  criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001)
                             _InputArray       inputMask = noArray() )

AutoIt:
    cv.findTransformECC( $templateImage, $inputImage, $warpMatrix[, $motionType[, $criteria[, $inputMask]]] ) -> retval, warpMatrix

cv::Mat cv::readOpticalFlow( const std::string& path )

AutoIt:
    cv.readOpticalFlow( $path ) -> retval

bool cv::writeOpticalFlow( const std::string& path
                           _InputArray        flow )

AutoIt:
    cv.writeOpticalFlow( $path, $flow ) -> retval

cv::GArrayDesc cv::empty_array_desc()

AutoIt:
    cv.empty_array_desc() -> retval

cv::GOpaqueDesc cv::empty_gopaque_desc()

AutoIt:
    cv.empty_gopaque_desc() -> retval

cv::GScalarDesc cv::empty_scalar_desc()

AutoIt:
    cv.empty_scalar_desc() -> retval

void cv::matchTemplateParallel( _InputArray  image
                                _InputArray  templ
                                _OutputArray result
                                int          method
                                _InputArray  mask = noArray() )

AutoIt:
    cv.matchTemplateParallel( $image, $templ, $method[, $result[, $mask]] ) -> result

void cv::searchTemplate( _InputArray             image
                         _InputArray             templ
                         _OutputArray            result
                         _InputArray             mask = noArray()
                         const std::vector<int>& channels = std::vector<int>()
                         const std::vector<int>& ranges = std::vector<int>()
                         const bool              parallel = false )

AutoIt:
    cv.searchTemplate( $image, $templ[, $result[, $mask[, $channels[, $ranges[, $parallel]]]]] ) -> result

cv::Mat cv::createMatFromBitmap( void* ptr
                                 bool  copy = true )

AutoIt:
    cv.createMatFromBitmap( $ptr[, $copy] ) -> retval

_variant_t cv::variant( void* ptr )

AutoIt:
    cv.variant( $ptr ) -> retval

void cv::readMat( cv::FileNode node
                  cv::Mat      mat
                  cv::Mat      default_mat = Mat() )

AutoIt:
    cv.readMat( $node[, $default_mat[, $mat]] ) -> mat

void cv::readInt( cv::FileNode node
                  int          value
                  int          default_value )

AutoIt:
    cv.readInt( $node, $default_value[, $value] ) -> value

void cv::readFloat( cv::FileNode node
                    float        value
                    float        default_value )

AutoIt:
    cv.readFloat( $node, $default_value[, $value] ) -> value

void cv::readDouble( cv::FileNode node
                     double       value
                     double       default_value )

AutoIt:
    cv.readDouble( $node, $default_value[, $value] ) -> value

void cv::readString( cv::FileNode node
                     std::string  value
                     std::string  default_value )

AutoIt:
    cv.readString( $node, $default_value[, $value] ) -> value

void cv::readKeyPoint( cv::FileNode node
                       cv::KeyPoint value
                       cv::KeyPoint default_value )

AutoIt:
    cv.readKeyPoint( $node, $default_value[, $value] ) -> value

void cv::readDMatch( cv::FileNode node
                     cv::DMatch   value
                     cv::DMatch   default_value )

AutoIt:
    cv.readDMatch( $node, $default_value[, $value] ) -> value

bool cv::parallel::setParallelForBackend( const std::string& backendName
                                          bool               propagateNumThreads = true )

AutoIt:
    cv.parallel.setParallelForBackend( $backendName[, $propagateNumThreads] ) -> retval

static cv::RNG cv::RNG::create()

AutoIt:
    cv.RNG.create() -> <cv.RNG object>

static cv::RNG cv::RNG::create( uint64 state )

AutoIt:
    cv.RNG.create( $state ) -> <cv.RNG object>

uint cv::RNG::next()

AutoIt:
    cv.RNG.next() -> retval

int cv::RNG::uniform_int( int a
                          int b )

AutoIt:
    cv.RNG.uniform_int( $a, $b ) -> retval

float cv::RNG::uniform_float( float a
                              float b )

AutoIt:
    cv.RNG.uniform_float( $a, $b ) -> retval

double cv::RNG::uniform_double( double a
                                double b )

AutoIt:
    cv.RNG.uniform_double( $a, $b ) -> retval

void cv::Algorithm::clear()

AutoIt:
    cv.Algorithm.clear() -> None

void cv::Algorithm::write( const cv::Ptr<cv::FileStorage>& fs
                           const std::string&              name = String() )

AutoIt:
    cv.Algorithm.write( $fs[, $name] ) -> None

void cv::Algorithm::read( const cv::FileNode& fn )

AutoIt:
    cv.Algorithm.read( $fn ) -> None

bool cv::Algorithm::empty()

AutoIt:
    cv.Algorithm.empty() -> retval

void cv::Algorithm::save( const std::string& filename )

AutoIt:
    cv.Algorithm.save( $filename ) -> None

std::string cv::Algorithm::getDefaultName()

AutoIt:
    cv.Algorithm.getDefaultName() -> retval

static cv::AsyncArray cv::AsyncArray::create()

AutoIt:
    cv.AsyncArray.create() -> <cv.AsyncArray object>

void cv::AsyncArray::release()

AutoIt:
    cv.AsyncArray.release() -> None

void cv::AsyncArray::get( _OutputArray dst )

AutoIt:
    cv.AsyncArray.get( [$dst] ) -> dst

bool cv::AsyncArray::get( _OutputArray dst
                          double       timeoutNs )

AutoIt:
    cv.AsyncArray.get( $timeoutNs[, $dst] ) -> retval, dst

bool cv::AsyncArray::wait_for( double timeoutNs )

AutoIt:
    cv.AsyncArray.wait_for( $timeoutNs ) -> retval

bool cv::AsyncArray::valid()

AutoIt:
    cv.AsyncArray.valid() -> retval

bool cv::ipp::useIPP()

AutoIt:
    cv.ipp.useIPP() -> retval

void cv::ipp::setUseIPP( bool flag )

AutoIt:
    cv.ipp.setUseIPP( $flag ) -> None

std::string cv::ipp::getIppVersion()

AutoIt:
    cv.ipp.getIppVersion() -> retval

bool cv::ipp::useIPP_NotExact()

AutoIt:
    cv.ipp.useIPP_NotExact() -> retval

void cv::ipp::setUseIPP_NotExact( bool flag )

AutoIt:
    cv.ipp.setUseIPP_NotExact( $flag ) -> None

std::string cv::utils::dumpInputArray( _InputArray argument )

AutoIt:
    cv.utils.dumpInputArray( $argument ) -> retval

std::string cv::utils::dumpInputArrayOfArrays( _InputArray argument )

AutoIt:
    cv.utils.dumpInputArrayOfArrays( $argument ) -> retval

std::string cv::utils::dumpInputOutputArray( _InputOutputArray argument )

AutoIt:
    cv.utils.dumpInputOutputArray( $argument ) -> retval, argument

std::string cv::utils::dumpInputOutputArrayOfArrays( _InputOutputArray argument )

AutoIt:
    cv.utils.dumpInputOutputArrayOfArrays( $argument ) -> retval, argument

std::string cv::utils::dumpBool( bool argument )

AutoIt:
    cv.utils.dumpBool( $argument ) -> retval

std::string cv::utils::dumpInt( int argument )

AutoIt:
    cv.utils.dumpInt( $argument ) -> retval

std::string cv::utils::dumpSizeT( size_t argument )

AutoIt:
    cv.utils.dumpSizeT( $argument ) -> retval

std::string cv::utils::dumpFloat( float argument )

AutoIt:
    cv.utils.dumpFloat( $argument ) -> retval

std::string cv::utils::dumpDouble( double argument )

AutoIt:
    cv.utils.dumpDouble( $argument ) -> retval

std::string cv::utils::dumpCString( const char* argument )

AutoIt:
    cv.utils.dumpCString( $argument ) -> retval

std::string cv::utils::dumpString( const std::string& argument )

AutoIt:
    cv.utils.dumpString( $argument ) -> retval

std::string cv::utils::testOverloadResolution( int              value
                                               const cv::Point& point = Point(42, 24) )

AutoIt:
    cv.utils.testOverloadResolution( $value[, $point] ) -> retval

std::string cv::utils::testOverloadResolution( const cv::Rect& rect )

AutoIt:
    cv.utils.testOverloadResolution( $rect ) -> retval

std::string cv::utils::dumpRect( const cv::Rect& argument )

AutoIt:
    cv.utils.dumpRect( $argument ) -> retval

std::string cv::utils::dumpTermCriteria( const cv::TermCriteria& argument )

AutoIt:
    cv.utils.dumpTermCriteria( $argument ) -> retval

std::string cv::utils::dumpRotatedRect( const cv::RotatedRect& argument )

AutoIt:
    cv.utils.dumpRotatedRect( $argument ) -> retval

cv::RotatedRect cv::utils::testRotatedRect( float x
                                            float y
                                            float w
                                            float h
                                            float angle )

AutoIt:
    cv.utils.testRotatedRect( $x, $y, $w, $h, $angle ) -> retval

std::vector<cv::RotatedRect> cv::utils::testRotatedRectVector( float x
                                                               float y
                                                               float w
                                                               float h
                                                               float angle )

AutoIt:
    cv.utils.testRotatedRectVector( $x, $y, $w, $h, $angle ) -> retval

std::string cv::utils::dumpRange( const cv::Range& argument )

AutoIt:
    cv.utils.dumpRange( $argument ) -> retval

int cv::utils::testOverwriteNativeMethod( int argument )

AutoIt:
    cv.utils.testOverwriteNativeMethod( $argument ) -> retval

std::string cv::utils::testReservedKeywordConversion( int positional_argument
                                                      int lambda = 2
                                                      int from = 3 )

AutoIt:
    cv.utils.testReservedKeywordConversion( $positional_argument[, $lambda[, $from]] ) -> retval

std::string cv::utils::dumpVectorOfInt( const std::vector<int>& vec )

AutoIt:
    cv.utils.dumpVectorOfInt( $vec ) -> retval

std::string cv::utils::dumpVectorOfDouble( const std::vector<double>& vec )

AutoIt:
    cv.utils.dumpVectorOfDouble( $vec ) -> retval

std::string cv::utils::dumpVectorOfRect( const std::vector<cv::Rect>& vec )

AutoIt:
    cv.utils.dumpVectorOfRect( $vec ) -> retval

void cv::utils::generateVectorOfRect( size_t                 len
                                      std::vector<cv::Rect>& vec )

AutoIt:
    cv.utils.generateVectorOfRect( $len[, $vec] ) -> vec

void cv::utils::generateVectorOfInt( size_t            len
                                     std::vector<int>& vec )

AutoIt:
    cv.utils.generateVectorOfInt( $len[, $vec] ) -> vec

void cv::utils::generateVectorOfMat( size_t                len
                                     int                   rows
                                     int                   cols
                                     int                   dtype
                                     std::vector<cv::Mat>& vec )

AutoIt:
    cv.utils.generateVectorOfMat( $len, $rows, $cols, $dtype[, $vec] ) -> vec

void cv::utils::testRaiseGeneralException()

AutoIt:
    cv.utils.testRaiseGeneralException() -> None

cv::AsyncArray cv::utils::testAsyncArray( _InputArray argument )

AutoIt:
    cv.utils.testAsyncArray( $argument ) -> retval

cv::AsyncArray cv::utils::testAsyncException()

AutoIt:
    cv.utils.testAsyncException() -> retval

std::string cv::utils::fs::getCacheDirectoryForDownloads()

AutoIt:
    cv.utils.fs.getCacheDirectoryForDownloads() -> retval

void cv::detail::focalsFromHomography( const cv::Mat& H
                                       double&        f0
                                       double&        f1
                                       bool&          f0_ok
                                       bool&          f1_ok )

AutoIt:
    cv.detail.focalsFromHomography( $H, $f0, $f1, $f0_ok, $f1_ok ) -> None

bool cv::detail::calibrateRotatingCamera( const std::vector<cv::Mat>& Hs
                                          cv::Mat&                    K )

AutoIt:
    cv.detail.calibrateRotatingCamera( $Hs[, $K] ) -> retval, K

void cv::detail::normalizeUsingWeightMap( _InputArray       weight
                                          _InputOutputArray src )

AutoIt:
    cv.detail.normalizeUsingWeightMap( $weight, $src ) -> src

void cv::detail::createWeightMap( _InputArray       mask
                                  float             sharpness
                                  _InputOutputArray weight )

AutoIt:
    cv.detail.createWeightMap( $mask, $sharpness, $weight ) -> weight

void cv::detail::createLaplacePyr( _InputArray            img
                                   int                    num_levels
                                   std::vector<cv::UMat>& pyr )

AutoIt:
    cv.detail.createLaplacePyr( $img, $num_levels, $pyr ) -> pyr

void cv::detail::createLaplacePyrGpu( _InputArray            img
                                      int                    num_levels
                                      std::vector<cv::UMat>& pyr )

AutoIt:
    cv.detail.createLaplacePyrGpu( $img, $num_levels, $pyr ) -> pyr

void cv::detail::restoreImageFromLaplacePyr( std::vector<cv::UMat>& pyr )

AutoIt:
    cv.detail.restoreImageFromLaplacePyr( $pyr ) -> pyr

void cv::detail::restoreImageFromLaplacePyrGpu( std::vector<cv::UMat>& pyr )

AutoIt:
    cv.detail.restoreImageFromLaplacePyrGpu( $pyr ) -> pyr

void cv::detail::computeImageFeatures( const cv::Ptr<cv::Feature2D>&           featuresFinder
                                       _InputArray                             images
                                       std::vector<cv::detail::ImageFeatures>& features
                                       _InputArray                             masks = noArray() )

AutoIt:
    cv.detail.computeImageFeatures( $featuresFinder, $images[, $masks[, $features]] ) -> features

void cv::detail::computeImageFeatures2( const cv::Ptr<cv::Feature2D>& featuresFinder
                                        _InputArray                   image
                                        cv::detail::ImageFeatures&    features
                                        _InputArray                   mask = noArray() )

AutoIt:
    cv.detail.computeImageFeatures2( $featuresFinder, $image[, $mask[, $features]] ) -> features

void cv::detail::waveCorrect( std::vector<cv::Mat>& rmats
                              int                   kind )

AutoIt:
    cv.detail.waveCorrect( $rmats, $kind ) -> rmats

std::string cv::detail::matchesGraphAsString( std::vector<std::string>&             pathes
                                              std::vector<cv::detail::MatchesInfo>& pairwise_matches
                                              float                                 conf_threshold )

AutoIt:
    cv.detail.matchesGraphAsString( $pathes, $pairwise_matches, $conf_threshold ) -> retval

std::vector<int> cv::detail::leaveBiggestComponent( std::vector<cv::detail::ImageFeatures>& features
                                                    std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                                    float                                   conf_threshold )

AutoIt:
    cv.detail.leaveBiggestComponent( $features, $pairwise_matches, $conf_threshold ) -> retval

bool cv::detail::overlapRoi( cv::Point tl1
                             cv::Point tl2
                             cv::Size  sz1
                             cv::Size  sz2
                             cv::Rect& roi )

AutoIt:
    cv.detail.overlapRoi( $tl1, $tl2, $sz1, $sz2, $roi ) -> retval

cv::Rect cv::detail::resultRoi( const std::vector<cv::Point>& corners
                                const std::vector<cv::UMat>&  images )

AutoIt:
    cv.detail.resultRoi( $corners, $images ) -> retval

cv::Rect cv::detail::resultRoi( const std::vector<cv::Point>& corners
                                const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.resultRoi( $corners, $sizes ) -> retval

cv::Rect cv::detail::resultRoiIntersection( const std::vector<cv::Point>& corners
                                            const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.resultRoiIntersection( $corners, $sizes ) -> retval

cv::Point cv::detail::resultTl( const std::vector<cv::Point>& corners )

AutoIt:
    cv.detail.resultTl( $corners ) -> retval

void cv::detail::selectRandomSubset( int               count
                                     int               size
                                     std::vector<int>& subset )

AutoIt:
    cv.detail.selectRandomSubset( $count, $size, $subset ) -> None

int cv::detail::stitchingLogLevel()

AutoIt:
    cv.detail.stitchingLogLevel() -> retval

void cv::cuda::createContinuous( int          rows
                                 int          cols
                                 int          type
                                 _OutputArray arr )

AutoIt:
    cv.cuda.createContinuous( $rows, $cols, $type[, $arr] ) -> arr

void cv::cuda::ensureSizeIsEnough( int          rows
                                   int          cols
                                   int          type
                                   _OutputArray arr )

AutoIt:
    cv.cuda.ensureSizeIsEnough( $rows, $cols, $type[, $arr] ) -> arr

void cv::cuda::setBufferPoolUsage( bool on )

AutoIt:
    cv.cuda.setBufferPoolUsage( $on ) -> None

void cv::cuda::setBufferPoolConfig( int    deviceId
                                    size_t stackSize
                                    int    stackCount )

AutoIt:
    cv.cuda.setBufferPoolConfig( $deviceId, $stackSize, $stackCount ) -> None

void cv::cuda::registerPageLocked( cv::Mat& m )

AutoIt:
    cv.cuda.registerPageLocked( $m ) -> None

void cv::cuda::unregisterPageLocked( cv::Mat& m )

AutoIt:
    cv.cuda.unregisterPageLocked( $m ) -> None

int cv::cuda::getCudaEnabledDeviceCount()

AutoIt:
    cv.cuda.getCudaEnabledDeviceCount() -> retval

void cv::cuda::setDevice( int device )

AutoIt:
    cv.cuda.setDevice( $device ) -> None

int cv::cuda::getDevice()

AutoIt:
    cv.cuda.getDevice() -> retval

void cv::cuda::resetDevice()

AutoIt:
    cv.cuda.resetDevice() -> None

void cv::cuda::printCudaDeviceInfo( int device )

AutoIt:
    cv.cuda.printCudaDeviceInfo( $device ) -> None

void cv::cuda::printShortCudaDeviceInfo( int device )

AutoIt:
    cv.cuda.printShortCudaDeviceInfo( $device ) -> None

static cv::cuda::GpuMat::Allocator* cv::cuda::GpuMat::defaultAllocator()

AutoIt:
    cv.cuda.GpuMat.defaultAllocator() -> retval

static void cv::cuda::GpuMat::setDefaultAllocator( cv::cuda::GpuMat::Allocator* allocator )

AutoIt:
    cv.cuda.GpuMat.setDefaultAllocator( $allocator ) -> None

static cv::cuda::GpuMat cv::cuda::GpuMat::create( cv::cuda::GpuMat::Allocator* allocator = GpuMat::defaultAllocator() )

AutoIt:
    cv.cuda.GpuMat.create( [$allocator] ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( int                          rows
                                                  int                          cols
                                                  int                          type
                                                  cv::cuda::GpuMat::Allocator* allocator = GpuMat::defaultAllocator() )

AutoIt:
    cv.cuda.GpuMat.create( $rows, $cols, $type[, $allocator] ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( cv::Size                     size
                                                  int                          type
                                                  cv::cuda::GpuMat::Allocator* allocator = GpuMat::defaultAllocator() )

AutoIt:
    cv.cuda.GpuMat.create( $size, $type[, $allocator] ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( int                          rows
                                                  int                          cols
                                                  int                          type
                                                  cv::Scalar                   s
                                                  cv::cuda::GpuMat::Allocator* allocator = GpuMat::defaultAllocator() )

AutoIt:
    cv.cuda.GpuMat.create( $rows, $cols, $type, $s[, $allocator] ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( cv::Size                     size
                                                  int                          type
                                                  cv::Scalar                   s
                                                  cv::cuda::GpuMat::Allocator* allocator = GpuMat::defaultAllocator() )

AutoIt:
    cv.cuda.GpuMat.create( $size, $type, $s[, $allocator] ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( const cv::cuda::GpuMat& m )

AutoIt:
    cv.cuda.GpuMat.create( $m ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( const cv::cuda::GpuMat& m
                                                  cv::Range               rowRange
                                                  cv::Range               colRange )

AutoIt:
    cv.cuda.GpuMat.create( $m, $rowRange, $colRange ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( const cv::cuda::GpuMat& m
                                                  cv::Rect                roi )

AutoIt:
    cv.cuda.GpuMat.create( $m, $roi ) -> <cv.cuda.GpuMat object>

static cv::cuda::GpuMat cv::cuda::GpuMat::create( _InputArray                  arr
                                                  cv::cuda::GpuMat::Allocator* allocator = GpuMat::defaultAllocator() )

AutoIt:
    cv.cuda.GpuMat.create( $arr[, $allocator] ) -> <cv.cuda.GpuMat object>

void cv::cuda::GpuMat::create( int rows
                               int cols
                               int type )

AutoIt:
    cv.cuda.GpuMat.create( $rows, $cols, $type ) -> None

void cv::cuda::GpuMat::create( cv::Size size
                               int      type )

AutoIt:
    cv.cuda.GpuMat.create( $size, $type ) -> None

void cv::cuda::GpuMat::swap( cv::cuda::GpuMat& mat )

AutoIt:
    cv.cuda.GpuMat.swap( $mat ) -> None

void cv::cuda::GpuMat::upload( _InputArray arr )

AutoIt:
    cv.cuda.GpuMat.upload( $arr ) -> None

void cv::cuda::GpuMat::upload( _InputArray       arr
                               cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.upload( $arr, $stream ) -> None

void cv::cuda::GpuMat::download( _OutputArray dst )

AutoIt:
    cv.cuda.GpuMat.download( [$dst] ) -> dst

void cv::cuda::GpuMat::download( _OutputArray      dst
                                 cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.download( $stream[, $dst] ) -> dst

cv::cuda::GpuMat cv::cuda::GpuMat::clone()

AutoIt:
    cv.cuda.GpuMat.clone() -> retval

void cv::cuda::GpuMat::copyTo( _OutputArray dst )

AutoIt:
    cv.cuda.GpuMat.copyTo( [$dst] ) -> dst

void cv::cuda::GpuMat::copyTo( _OutputArray      dst
                               cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.copyTo( $stream[, $dst] ) -> dst

void cv::cuda::GpuMat::copyTo( _OutputArray dst
                               _InputArray  mask )

AutoIt:
    cv.cuda.GpuMat.copyTo( $mask[, $dst] ) -> dst

void cv::cuda::GpuMat::copyTo( _OutputArray      dst
                               _InputArray       mask
                               cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.copyTo( $mask, $stream[, $dst] ) -> dst

cv::cuda::GpuMat cv::cuda::GpuMat::setTo( cv::Scalar s )

AutoIt:
    cv.cuda.GpuMat.setTo( $s ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::setTo( cv::Scalar        s
                                          cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.setTo( $s, $stream ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::setTo( cv::Scalar  s
                                          _InputArray mask )

AutoIt:
    cv.cuda.GpuMat.setTo( $s, $mask ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::setTo( cv::Scalar        s
                                          _InputArray       mask
                                          cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.setTo( $s, $mask, $stream ) -> retval

void cv::cuda::GpuMat::convertTo( _OutputArray dst
                                  int          rtype )

AutoIt:
    cv.cuda.GpuMat.convertTo( $rtype[, $dst] ) -> dst

void cv::cuda::GpuMat::convertTo( _OutputArray      dst
                                  int               rtype
                                  cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.convertTo( $rtype, $stream[, $dst] ) -> dst

void cv::cuda::GpuMat::convertTo( _OutputArray dst
                                  int          rtype
                                  double       alpha
                                  double       beta = 0.0 )

AutoIt:
    cv.cuda.GpuMat.convertTo( $rtype, $alpha[, $dst[, $beta]] ) -> dst

void cv::cuda::GpuMat::convertTo( _OutputArray      dst
                                  int               rtype
                                  double            alpha
                                  cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.convertTo( $rtype, $alpha, $stream[, $dst] ) -> dst

void cv::cuda::GpuMat::convertTo( _OutputArray      dst
                                  int               rtype
                                  double            alpha
                                  double            beta
                                  cv::cuda::Stream& stream )

AutoIt:
    cv.cuda.GpuMat.convertTo( $rtype, $alpha, $beta, $stream[, $dst] ) -> dst

void cv::cuda::GpuMat::assignTo( cv::cuda::GpuMat& m
                                 int               type = -1 )

AutoIt:
    cv.cuda.GpuMat.assignTo( $m[, $type] ) -> None

cv::cuda::GpuMat cv::cuda::GpuMat::row( int y )

AutoIt:
    cv.cuda.GpuMat.row( $y ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::col( int x )

AutoIt:
    cv.cuda.GpuMat.col( $x ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::rowRange( int startrow
                                             int endrow )

AutoIt:
    cv.cuda.GpuMat.rowRange( $startrow, $endrow ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::rowRange( cv::Range r )

AutoIt:
    cv.cuda.GpuMat.rowRange( $r ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::colRange( int startcol
                                             int endcol )

AutoIt:
    cv.cuda.GpuMat.colRange( $startcol, $endcol ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::colRange( cv::Range r )

AutoIt:
    cv.cuda.GpuMat.colRange( $r ) -> retval

cv::cuda::GpuMat cv::cuda::GpuMat::reshape( int cn
                                            int rows = 0 )

AutoIt:
    cv.cuda.GpuMat.reshape( $cn[, $rows] ) -> retval

void cv::cuda::GpuMat::locateROI( cv::Size&  wholeSize
                                  cv::Point& ofs )

AutoIt:
    cv.cuda.GpuMat.locateROI( $wholeSize, $ofs ) -> None

cv::cuda::GpuMat cv::cuda::GpuMat::adjustROI( int dtop
                                              int dbottom
                                              int dleft
                                              int dright )

AutoIt:
    cv.cuda.GpuMat.adjustROI( $dtop, $dbottom, $dleft, $dright ) -> retval

bool cv::cuda::GpuMat::isContinuous()

AutoIt:
    cv.cuda.GpuMat.isContinuous() -> retval

size_t cv::cuda::GpuMat::elemSize()

AutoIt:
    cv.cuda.GpuMat.elemSize() -> retval

size_t cv::cuda::GpuMat::elemSize1()

AutoIt:
    cv.cuda.GpuMat.elemSize1() -> retval

int cv::cuda::GpuMat::type()

AutoIt:
    cv.cuda.GpuMat.type() -> retval

int cv::cuda::GpuMat::depth()

AutoIt:
    cv.cuda.GpuMat.depth() -> retval

int cv::cuda::GpuMat::channels()

AutoIt:
    cv.cuda.GpuMat.channels() -> retval

size_t cv::cuda::GpuMat::step1()

AutoIt:
    cv.cuda.GpuMat.step1() -> retval

cv::Size cv::cuda::GpuMat::size()

AutoIt:
    cv.cuda.GpuMat.size() -> retval

bool cv::cuda::GpuMat::empty()

AutoIt:
    cv.cuda.GpuMat.empty() -> retval

void* cv::cuda::GpuMat::cudaPtr()

AutoIt:
    cv.cuda.GpuMat.cudaPtr() -> retval

void cv::cuda::GpuMat::updateContinuityFlag()

AutoIt:
    cv.cuda.GpuMat.updateContinuityFlag() -> None

cv::cuda::GpuMat cv::cuda::BufferPool::getBuffer( int rows
                                                  int cols
                                                  int type )

AutoIt:
    cv.cuda.BufferPool.getBuffer( $rows, $cols, $type ) -> retval

cv::cuda::GpuMat cv::cuda::BufferPool::getBuffer( cv::Size size
                                                  int      type )

AutoIt:
    cv.cuda.BufferPool.getBuffer( $size, $type ) -> retval

cv::Ptr<cv::cuda::GpuMat::Allocator> cv::cuda::BufferPool::getAllocator()

AutoIt:
    cv.cuda.BufferPool.getAllocator() -> retval

static cv::cuda::HostMem cv::cuda::HostMem::create( int alloc_type = HostMem::AllocType::PAGE_LOCKED )

AutoIt:
    cv.cuda.HostMem.create( [$alloc_type] ) -> <cv.cuda.HostMem object>

static cv::cuda::HostMem cv::cuda::HostMem::create( int rows
                                                    int cols
                                                    int type
                                                    int alloc_type = HostMem::AllocType::PAGE_LOCKED )

AutoIt:
    cv.cuda.HostMem.create( $rows, $cols, $type[, $alloc_type] ) -> <cv.cuda.HostMem object>

static cv::cuda::HostMem cv::cuda::HostMem::create( cv::Size size
                                                    int      type
                                                    int      alloc_type = HostMem::AllocType::PAGE_LOCKED )

AutoIt:
    cv.cuda.HostMem.create( $size, $type[, $alloc_type] ) -> <cv.cuda.HostMem object>

static cv::cuda::HostMem cv::cuda::HostMem::create( _InputArray arr
                                                    int         alloc_type = HostMem::AllocType::PAGE_LOCKED )

AutoIt:
    cv.cuda.HostMem.create( $arr[, $alloc_type] ) -> <cv.cuda.HostMem object>

void cv::cuda::HostMem::create( int rows
                                int cols
                                int type )

AutoIt:
    cv.cuda.HostMem.create( $rows, $cols, $type ) -> None

static cv::cuda::HostMem cv::cuda::HostMem::create( cv::cuda::HostMem m )

AutoIt:
    cv.cuda.HostMem.create( $m ) -> <cv.cuda.HostMem object>

void cv::cuda::HostMem::swap( cv::cuda::HostMem& b )

AutoIt:
    cv.cuda.HostMem.swap( $b ) -> None

cv::cuda::HostMem cv::cuda::HostMem::clone()

AutoIt:
    cv.cuda.HostMem.clone() -> retval

cv::cuda::HostMem cv::cuda::HostMem::reshape( int cn
                                              int rows = 0 )

AutoIt:
    cv.cuda.HostMem.reshape( $cn[, $rows] ) -> retval

cv::Mat cv::cuda::HostMem::createMatHeader()

AutoIt:
    cv.cuda.HostMem.createMatHeader() -> retval

bool cv::cuda::HostMem::isContinuous()

AutoIt:
    cv.cuda.HostMem.isContinuous() -> retval

size_t cv::cuda::HostMem::elemSize()

AutoIt:
    cv.cuda.HostMem.elemSize() -> retval

size_t cv::cuda::HostMem::elemSize1()

AutoIt:
    cv.cuda.HostMem.elemSize1() -> retval

int cv::cuda::HostMem::type()

AutoIt:
    cv.cuda.HostMem.type() -> retval

int cv::cuda::HostMem::depth()

AutoIt:
    cv.cuda.HostMem.depth() -> retval

int cv::cuda::HostMem::channels()

AutoIt:
    cv.cuda.HostMem.channels() -> retval

size_t cv::cuda::HostMem::step1()

AutoIt:
    cv.cuda.HostMem.step1() -> retval

cv::Size cv::cuda::HostMem::size()

AutoIt:
    cv.cuda.HostMem.size() -> retval

bool cv::cuda::HostMem::empty()

AutoIt:
    cv.cuda.HostMem.empty() -> retval

static cv::cuda::Stream cv::cuda::Stream::create()

AutoIt:
    cv.cuda.Stream.create() -> <cv.cuda.Stream object>

static cv::cuda::Stream cv::cuda::Stream::create( const cv::Ptr<cv::cuda::GpuMat::Allocator>& allocator )

AutoIt:
    cv.cuda.Stream.create( $allocator ) -> <cv.cuda.Stream object>

static cv::cuda::Stream cv::cuda::Stream::create( const size_t cudaFlags )

AutoIt:
    cv.cuda.Stream.create( $cudaFlags ) -> <cv.cuda.Stream object>

bool cv::cuda::Stream::queryIfComplete()

AutoIt:
    cv.cuda.Stream.queryIfComplete() -> retval

void cv::cuda::Stream::waitForCompletion()

AutoIt:
    cv.cuda.Stream.waitForCompletion() -> None

void cv::cuda::Stream::waitEvent( const cv::cuda::Event& event )

AutoIt:
    cv.cuda.Stream.waitEvent( $event ) -> None

static cv::cuda::Stream cv::cuda::Stream::Null()

AutoIt:
    cv.cuda.Stream.Null() -> retval

void* cv::cuda::Stream::cudaPtr()

AutoIt:
    cv.cuda.Stream.cudaPtr() -> retval

static cv::cuda::Event cv::cuda::Event::create( int flags = Event::CreateFlags::DEFAULT )

AutoIt:
    cv.cuda.Event.create( [$flags] ) -> <cv.cuda.Event object>

void cv::cuda::Event::record( cv::cuda::Stream& stream = Stream::Null() )

AutoIt:
    cv.cuda.Event.record( [$stream] ) -> None

bool cv::cuda::Event::queryIfComplete()

AutoIt:
    cv.cuda.Event.queryIfComplete() -> retval

void cv::cuda::Event::waitForCompletion()

AutoIt:
    cv.cuda.Event.waitForCompletion() -> None

static float cv::cuda::Event::elapsedTime( const cv::cuda::Event& start
                                           const cv::cuda::Event& end )

AutoIt:
    cv.cuda.Event.elapsedTime( $start, $end ) -> retval

static bool cv::cuda::TargetArchs::has( int major
                                        int minor )

AutoIt:
    cv.cuda.TargetArchs.has( $major, $minor ) -> retval

static bool cv::cuda::TargetArchs::hasPtx( int major
                                           int minor )

AutoIt:
    cv.cuda.TargetArchs.hasPtx( $major, $minor ) -> retval

static bool cv::cuda::TargetArchs::hasBin( int major
                                           int minor )

AutoIt:
    cv.cuda.TargetArchs.hasBin( $major, $minor ) -> retval

static bool cv::cuda::TargetArchs::hasEqualOrLessPtx( int major
                                                      int minor )

AutoIt:
    cv.cuda.TargetArchs.hasEqualOrLessPtx( $major, $minor ) -> retval

static bool cv::cuda::TargetArchs::hasEqualOrGreater( int major
                                                      int minor )

AutoIt:
    cv.cuda.TargetArchs.hasEqualOrGreater( $major, $minor ) -> retval

static bool cv::cuda::TargetArchs::hasEqualOrGreaterPtx( int major
                                                         int minor )

AutoIt:
    cv.cuda.TargetArchs.hasEqualOrGreaterPtx( $major, $minor ) -> retval

static bool cv::cuda::TargetArchs::hasEqualOrGreaterBin( int major
                                                         int minor )

AutoIt:
    cv.cuda.TargetArchs.hasEqualOrGreaterBin( $major, $minor ) -> retval

static cv::cuda::DeviceInfo cv::cuda::DeviceInfo::create()

AutoIt:
    cv.cuda.DeviceInfo.create() -> <cv.cuda.DeviceInfo object>

static cv::cuda::DeviceInfo cv::cuda::DeviceInfo::create( int device_id )

AutoIt:
    cv.cuda.DeviceInfo.create( $device_id ) -> <cv.cuda.DeviceInfo object>

int cv::cuda::DeviceInfo::deviceID()

AutoIt:
    cv.cuda.DeviceInfo.deviceID() -> retval

size_t cv::cuda::DeviceInfo::totalGlobalMem()

AutoIt:
    cv.cuda.DeviceInfo.totalGlobalMem() -> retval

size_t cv::cuda::DeviceInfo::sharedMemPerBlock()

AutoIt:
    cv.cuda.DeviceInfo.sharedMemPerBlock() -> retval

int cv::cuda::DeviceInfo::regsPerBlock()

AutoIt:
    cv.cuda.DeviceInfo.regsPerBlock() -> retval

int cv::cuda::DeviceInfo::warpSize()

AutoIt:
    cv.cuda.DeviceInfo.warpSize() -> retval

size_t cv::cuda::DeviceInfo::memPitch()

AutoIt:
    cv.cuda.DeviceInfo.memPitch() -> retval

int cv::cuda::DeviceInfo::maxThreadsPerBlock()

AutoIt:
    cv.cuda.DeviceInfo.maxThreadsPerBlock() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxThreadsDim()

AutoIt:
    cv.cuda.DeviceInfo.maxThreadsDim() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxGridSize()

AutoIt:
    cv.cuda.DeviceInfo.maxGridSize() -> retval

int cv::cuda::DeviceInfo::clockRate()

AutoIt:
    cv.cuda.DeviceInfo.clockRate() -> retval

size_t cv::cuda::DeviceInfo::totalConstMem()

AutoIt:
    cv.cuda.DeviceInfo.totalConstMem() -> retval

int cv::cuda::DeviceInfo::majorVersion()

AutoIt:
    cv.cuda.DeviceInfo.majorVersion() -> retval

int cv::cuda::DeviceInfo::minorVersion()

AutoIt:
    cv.cuda.DeviceInfo.minorVersion() -> retval

size_t cv::cuda::DeviceInfo::textureAlignment()

AutoIt:
    cv.cuda.DeviceInfo.textureAlignment() -> retval

size_t cv::cuda::DeviceInfo::texturePitchAlignment()

AutoIt:
    cv.cuda.DeviceInfo.texturePitchAlignment() -> retval

int cv::cuda::DeviceInfo::multiProcessorCount()

AutoIt:
    cv.cuda.DeviceInfo.multiProcessorCount() -> retval

bool cv::cuda::DeviceInfo::kernelExecTimeoutEnabled()

AutoIt:
    cv.cuda.DeviceInfo.kernelExecTimeoutEnabled() -> retval

bool cv::cuda::DeviceInfo::integrated()

AutoIt:
    cv.cuda.DeviceInfo.integrated() -> retval

bool cv::cuda::DeviceInfo::canMapHostMemory()

AutoIt:
    cv.cuda.DeviceInfo.canMapHostMemory() -> retval

int cv::cuda::DeviceInfo::computeMode()

AutoIt:
    cv.cuda.DeviceInfo.computeMode() -> retval

int cv::cuda::DeviceInfo::maxTexture1D()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture1D() -> retval

int cv::cuda::DeviceInfo::maxTexture1DMipmap()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture1DMipmap() -> retval

int cv::cuda::DeviceInfo::maxTexture1DLinear()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture1DLinear() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxTexture2D()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture2D() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxTexture2DMipmap()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture2DMipmap() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxTexture2DLinear()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture2DLinear() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxTexture2DGather()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture2DGather() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxTexture3D()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture3D() -> retval

int cv::cuda::DeviceInfo::maxTextureCubemap()

AutoIt:
    cv.cuda.DeviceInfo.maxTextureCubemap() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxTexture1DLayered()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture1DLayered() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxTexture2DLayered()

AutoIt:
    cv.cuda.DeviceInfo.maxTexture2DLayered() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxTextureCubemapLayered()

AutoIt:
    cv.cuda.DeviceInfo.maxTextureCubemapLayered() -> retval

int cv::cuda::DeviceInfo::maxSurface1D()

AutoIt:
    cv.cuda.DeviceInfo.maxSurface1D() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxSurface2D()

AutoIt:
    cv.cuda.DeviceInfo.maxSurface2D() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxSurface3D()

AutoIt:
    cv.cuda.DeviceInfo.maxSurface3D() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxSurface1DLayered()

AutoIt:
    cv.cuda.DeviceInfo.maxSurface1DLayered() -> retval

cv::Vec3i cv::cuda::DeviceInfo::maxSurface2DLayered()

AutoIt:
    cv.cuda.DeviceInfo.maxSurface2DLayered() -> retval

int cv::cuda::DeviceInfo::maxSurfaceCubemap()

AutoIt:
    cv.cuda.DeviceInfo.maxSurfaceCubemap() -> retval

cv::Vec2i cv::cuda::DeviceInfo::maxSurfaceCubemapLayered()

AutoIt:
    cv.cuda.DeviceInfo.maxSurfaceCubemapLayered() -> retval

size_t cv::cuda::DeviceInfo::surfaceAlignment()

AutoIt:
    cv.cuda.DeviceInfo.surfaceAlignment() -> retval

bool cv::cuda::DeviceInfo::concurrentKernels()

AutoIt:
    cv.cuda.DeviceInfo.concurrentKernels() -> retval

bool cv::cuda::DeviceInfo::ECCEnabled()

AutoIt:
    cv.cuda.DeviceInfo.ECCEnabled() -> retval

int cv::cuda::DeviceInfo::pciBusID()

AutoIt:
    cv.cuda.DeviceInfo.pciBusID() -> retval

int cv::cuda::DeviceInfo::pciDeviceID()

AutoIt:
    cv.cuda.DeviceInfo.pciDeviceID() -> retval

int cv::cuda::DeviceInfo::pciDomainID()

AutoIt:
    cv.cuda.DeviceInfo.pciDomainID() -> retval

bool cv::cuda::DeviceInfo::tccDriver()

AutoIt:
    cv.cuda.DeviceInfo.tccDriver() -> retval

int cv::cuda::DeviceInfo::asyncEngineCount()

AutoIt:
    cv.cuda.DeviceInfo.asyncEngineCount() -> retval

bool cv::cuda::DeviceInfo::unifiedAddressing()

AutoIt:
    cv.cuda.DeviceInfo.unifiedAddressing() -> retval

int cv::cuda::DeviceInfo::memoryClockRate()

AutoIt:
    cv.cuda.DeviceInfo.memoryClockRate() -> retval

int cv::cuda::DeviceInfo::memoryBusWidth()

AutoIt:
    cv.cuda.DeviceInfo.memoryBusWidth() -> retval

int cv::cuda::DeviceInfo::l2CacheSize()

AutoIt:
    cv.cuda.DeviceInfo.l2CacheSize() -> retval

int cv::cuda::DeviceInfo::maxThreadsPerMultiProcessor()

AutoIt:
    cv.cuda.DeviceInfo.maxThreadsPerMultiProcessor() -> retval

void cv::cuda::DeviceInfo::queryMemory( size_t& totalMemory
                                        size_t& freeMemory )

AutoIt:
    cv.cuda.DeviceInfo.queryMemory( $totalMemory, $freeMemory ) -> None

size_t cv::cuda::DeviceInfo::freeMemory()

AutoIt:
    cv.cuda.DeviceInfo.freeMemory() -> retval

size_t cv::cuda::DeviceInfo::totalMemory()

AutoIt:
    cv.cuda.DeviceInfo.totalMemory() -> retval

bool cv::cuda::DeviceInfo::isCompatible()

AutoIt:
    cv.cuda.DeviceInfo.isCompatible() -> retval

static cv::Mat cv::Mat::create()

AutoIt:
    cv.Mat.create() -> <cv.Mat object>

static cv::Mat cv::Mat::create( int rows
                                int cols
                                int type )

AutoIt:
    cv.Mat.create( $rows, $cols, $type ) -> <cv.Mat object>

static cv::Mat cv::Mat::create( cv::Size size
                                int      type )

AutoIt:
    cv.Mat.create( $size, $type ) -> <cv.Mat object>

static cv::Mat cv::Mat::create( int        rows
                                int        cols
                                int        type
                                cv::Scalar s )

AutoIt:
    cv.Mat.create( $rows, $cols, $type, $s ) -> <cv.Mat object>

static cv::Mat cv::Mat::create( cv::Size   size
                                int        type
                                cv::Scalar s )

AutoIt:
    cv.Mat.create( $size, $type, $s ) -> <cv.Mat object>

static cv::Mat cv::Mat::create( int    rows
                                int    cols
                                int    type
                                void*  data
                                size_t step = cv::Mat::AUTO_STEP )

AutoIt:
    cv.Mat.create( $rows, $cols, $type, $data[, $step] ) -> <cv.Mat object>

static cv::Mat cv::Mat::create( cv::Mat m )

AutoIt:
    cv.Mat.create( $m ) -> <cv.Mat object>

static cv::Mat cv::Mat::create( cv::Mat  src
                                cv::Rect roi )

AutoIt:
    cv.Mat.create( $src, $roi ) -> <cv.Mat object>

cv::Mat cv::Mat::row( int y )

AutoIt:
    cv.Mat.row( $y ) -> retval

cv::Mat cv::Mat::col( int x )

AutoIt:
    cv.Mat.col( $x ) -> retval

cv::Mat cv::Mat::rowRange( int startrow
                           int endrow )

AutoIt:
    cv.Mat.rowRange( $startrow, $endrow ) -> retval

cv::Mat cv::Mat::rowRange( cv::Range r )

AutoIt:
    cv.Mat.rowRange( $r ) -> retval

cv::Mat cv::Mat::colRange( int startcol
                           int endcol )

AutoIt:
    cv.Mat.colRange( $startcol, $endcol ) -> retval

cv::Mat cv::Mat::colRange( cv::Range r )

AutoIt:
    cv.Mat.colRange( $r ) -> retval

bool cv::Mat::isContinuous()

AutoIt:
    cv.Mat.isContinuous() -> retval

bool cv::Mat::isSubmatrix()

AutoIt:
    cv.Mat.isSubmatrix() -> retval

size_t cv::Mat::elemSize()

AutoIt:
    cv.Mat.elemSize() -> retval

size_t cv::Mat::elemSize1()

AutoIt:
    cv.Mat.elemSize1() -> retval

int cv::Mat::type()

AutoIt:
    cv.Mat.type() -> retval

int cv::Mat::depth()

AutoIt:
    cv.Mat.depth() -> retval

int cv::Mat::channels()

AutoIt:
    cv.Mat.channels() -> retval

size_t cv::Mat::step1( int i = 0 )

AutoIt:
    cv.Mat.step1( [$i] ) -> retval

bool cv::Mat::empty()

AutoIt:
    cv.Mat.empty() -> retval

size_t cv::Mat::total()

AutoIt:
    cv.Mat.total() -> retval

size_t cv::Mat::total( int startDim
                       int endDim = INT_MAX )

AutoIt:
    cv.Mat.total( $startDim[, $endDim] ) -> retval

int cv::Mat::checkVector( int elemChannels
                          int depth = -1
                          int requireContinuous = true )

AutoIt:
    cv.Mat.checkVector( $elemChannels[, $depth[, $requireContinuous]] ) -> retval

uchar* cv::Mat::ptr( int y = 0 )

AutoIt:
    cv.Mat.ptr( [$y] ) -> retval

uchar* cv::Mat::ptr( int i0
                     int i1 )

AutoIt:
    cv.Mat.ptr( $i0, $i1 ) -> retval

uchar* cv::Mat::ptr( int i0
                     int i1
                     int i2 )

AutoIt:
    cv.Mat.ptr( $i0, $i1, $i2 ) -> retval

cv::Size cv::Mat::size()

AutoIt:
    cv.Mat.size() -> retval

void cv::Mat::pop_back( size_t value )

AutoIt:
    cv.Mat.pop_back( $value ) -> None

void cv::Mat::push_back( cv::Mat value )

AutoIt:
    cv.Mat.push_back( $value ) -> None

cv::Mat cv::Mat::clone()

AutoIt:
    cv.Mat.clone() -> retval

cv::Mat cv::Mat::copy()

AutoIt:
    cv.Mat.copy() -> retval

void cv::Mat::copyTo( _OutputArray m )

AutoIt:
    cv.Mat.copyTo( [$m] ) -> m

void cv::Mat::copyTo( _OutputArray m
                      _InputArray  mask )

AutoIt:
    cv.Mat.copyTo( $mask[, $m] ) -> m

void cv::Mat::setTo( _InputArray value
                     _InputArray mask = noArray() )

AutoIt:
    cv.Mat.setTo( $value[, $mask] ) -> None

void cv::Mat::convertTo( _OutputArray m
                         int          rtype
                         double       alpha = 1.0
                         double       beta = 0.0 )

AutoIt:
    cv.Mat.convertTo( $rtype[, $m[, $alpha[, $beta]]] ) -> m

cv::Mat cv::Mat::reshape( int cn
                          int rows = 0 )

AutoIt:
    cv.Mat.reshape( $cn[, $rows] ) -> retval

double cv::Mat::dot( _InputArray m )

AutoIt:
    cv.Mat.dot( $m ) -> retval

cv::Mat cv::Mat::cross( _InputArray m )

AutoIt:
    cv.Mat.cross( $m ) -> retval

cv::Mat cv::Mat::diag( int d = 0 )

AutoIt:
    cv.Mat.diag( [$d] ) -> retval

cv::Mat cv::Mat::t()

AutoIt:
    cv.Mat.t() -> retval

void* cv::Mat::convertToBitmap( bool copy = true )

AutoIt:
    cv.Mat.convertToBitmap( [$copy] ) -> retval

cv::Mat cv::Mat::convertToShow( cv::Mat dst = Mat::zeros(this->__self->get()->rows, this->__self->get()->cols, CV_8UC3)
                                bool    toRGB = false )

AutoIt:
    cv.Mat.convertToShow( [$dst[, $toRGB]] ) -> retval, dst

cv::Mat cv::Mat::GdiplusResize( float newWidth
                                float newHeight
                                int   interpolation = 7 )

AutoIt:
    cv.Mat.GdiplusResize( $newWidth, $newHeight[, $interpolation] ) -> retval

_variant_t cv::Mat::PixelSearch( cv::Scalar color
                                 int        left = 0
                                 int        top = 0
                                 int        right = this->__self->get()->cols - 1
                                 int        bottom = this->__self->get()->rows - 1
                                 uchar      shade_variation = 0
                                 int        step = 1 )

AutoIt:
    cv.Mat.PixelSearch( $color[, $left[, $top[, $right[, $bottom[, $shade_variation[, $step]]]]]] ) -> retval

_variant_t cv::Mat::PixelSearch( cv::Scalar color
                                 cv::Rect   rect = Rect(0, 0, this->__self->get()->cols, this->__self->get()->rows)
                                 uchar      shade_variation = 0
                                 int        step = 1 )

AutoIt:
    cv.Mat.PixelSearch( $color[, $rect[, $shade_variation[, $step]]] ) -> retval

size_t cv::Mat::PixelChecksum( int left = 0
                               int top = 0
                               int right = this->__self->get()->cols - 1
                               int bottom = this->__self->get()->rows - 1
                               int step = 1
                               int mode = 0 )

AutoIt:
    cv.Mat.PixelChecksum( [$left[, $top[, $right[, $bottom[, $step[, $mode]]]]]] ) -> retval

size_t cv::Mat::PixelChecksum( cv::Rect rect = Rect(0, 0, this->__self->get()->cols, this->__self->get()->rows)
                               int      step = 1
                               int      mode = 0 )

AutoIt:
    cv.Mat.PixelChecksum( [$rect[, $step[, $mode]]] ) -> retval

static cv::Mat cv::Mat::eye( int rows
                             int cols
                             int type )

AutoIt:
    cv.Mat.eye( $rows, $cols, $type ) -> retval

static cv::Mat cv::Mat::zeros( int rows
                               int cols
                               int type )

AutoIt:
    cv.Mat.zeros( $rows, $cols, $type ) -> retval

static cv::Mat cv::Mat::zeros( cv::Size size
                               int      type )

AutoIt:
    cv.Mat.zeros( $size, $type ) -> retval

static cv::Mat cv::Mat::ones( int rows
                              int cols
                              int type )

AutoIt:
    cv.Mat.ones( $rows, $cols, $type ) -> retval

static cv::Mat cv::Mat::ones( cv::Size size
                              int      type )

AutoIt:
    cv.Mat.ones( $size, $type ) -> retval

static cv::Mat cv::Mat::createFromVec2b( cv::Vec2b vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec2b( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec2b( std::vector<cv::Vec2b> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec2b( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec3b( cv::Vec3b vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec3b( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec3b( std::vector<cv::Vec3b> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec3b( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec4b( cv::Vec4b vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec4b( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec4b( std::vector<cv::Vec4b> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec4b( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec2s( cv::Vec2s vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec2s( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec2s( std::vector<cv::Vec2s> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec2s( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec3s( cv::Vec3s vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec3s( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec3s( std::vector<cv::Vec3s> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec3s( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec4s( cv::Vec4s vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec4s( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec4s( std::vector<cv::Vec4s> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec4s( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec2w( cv::Vec2w vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec2w( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec2w( std::vector<cv::Vec2w> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec2w( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec3w( cv::Vec3w vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec3w( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec3w( std::vector<cv::Vec3w> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec3w( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec4w( cv::Vec4w vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec4w( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec4w( std::vector<cv::Vec4w> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec4w( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec2i( cv::Vec2i vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec2i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec2i( std::vector<cv::Vec2i> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec2i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec3i( cv::Vec3i vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec3i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec3i( std::vector<cv::Vec3i> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec3i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec4i( cv::Vec4i vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec4i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec4i( std::vector<cv::Vec4i> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec4i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec6i( cv::Vec6i vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec6i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec6i( std::vector<cv::Vec6i> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec6i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec8i( cv::Vec8i vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec8i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec8i( std::vector<cv::Vec8i> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec8i( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec2f( cv::Vec2f vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec2f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec2f( std::vector<cv::Vec2f> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec2f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec3f( cv::Vec3f vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec3f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec3f( std::vector<cv::Vec3f> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec3f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec4f( cv::Vec4f vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec4f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec4f( std::vector<cv::Vec4f> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec4f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec6f( cv::Vec6f vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec6f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec6f( std::vector<cv::Vec6f> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec6f( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec2d( cv::Vec2d vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec2d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec2d( std::vector<cv::Vec2d> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec2d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec3d( cv::Vec3d vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec3d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec3d( std::vector<cv::Vec3d> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec3d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec4d( cv::Vec4d vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec4d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec4d( std::vector<cv::Vec4d> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec4d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVec6d( cv::Vec6d vec
                                         bool      copyData = true )

AutoIt:
    cv.Mat.createFromVec6d( $vec[, $copyData] ) -> <cv.Mat object>

static cv::Mat cv::Mat::createFromVectorOfVec6d( std::vector<cv::Vec6d> vec
                                                 bool                   copyData = true )

AutoIt:
    cv.Mat.createFromVectorOfVec6d( $vec[, $copyData] ) -> <cv.Mat object>

cv::Point2d cv::Mat::Point_at( int i0 )

AutoIt:
    cv.Mat.Point_at( $i0 ) -> retval

cv::Point2d cv::Mat::Point_at( int row
                               int col )

AutoIt:
    cv.Mat.Point_at( $row, $col ) -> retval

cv::Point2d cv::Mat::Point_at( int i0
                               int i1
                               int i2 )

AutoIt:
    cv.Mat.Point_at( $i0, $i1, $i2 ) -> retval

cv::Point2d cv::Mat::Point_at( cv::Point pt )

AutoIt:
    cv.Mat.Point_at( $pt ) -> retval

double cv::Mat::at( int i0 )

AutoIt:
    cv.Mat.at( $i0 ) -> retval

double cv::Mat::at( int row
                    int col )

AutoIt:
    cv.Mat.at( $row, $col ) -> retval

double cv::Mat::at( int i0
                    int i1
                    int i2 )

AutoIt:
    cv.Mat.at( $i0, $i1, $i2 ) -> retval

double cv::Mat::at( cv::Point pt )

AutoIt:
    cv.Mat.at( $pt ) -> retval

void cv::Mat::set_at( int    i0
                      double value )

AutoIt:
    cv.Mat.set_at( $i0, $value ) -> None

void cv::Mat::set_at( int    row
                      int    col
                      double value )

AutoIt:
    cv.Mat.set_at( $row, $col, $value ) -> None

void cv::Mat::set_at( int    i0
                      int    i1
                      int    i2
                      double value )

AutoIt:
    cv.Mat.set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::set_at( cv::Point pt
                      double    value )

AutoIt:
    cv.Mat.set_at( $pt, $value ) -> None

double cv::Mat::get_Item( int i0 )

AutoIt:
    cv.Mat.Item( $i0 ) -> retval
    cv.Mat( $i0 ) -> retval

double cv::Mat::get_Item( int row
                          int col )

AutoIt:
    cv.Mat.Item( $row, $col ) -> retval
    cv.Mat( $row, $col ) -> retval

double cv::Mat::get_Item( int i0
                          int i1
                          int i2 )

AutoIt:
    cv.Mat.Item( $i0, $i1, $i2 ) -> retval
    cv.Mat( $i0, $i1, $i2 ) -> retval

double cv::Mat::get_Item( cv::Point pt )

AutoIt:
    cv.Mat.Item( $pt ) -> retval
    cv.Mat( $pt ) -> retval

int cv::Mat::int_at( int i0 )

AutoIt:
    cv.Mat.int_at( $i0 ) -> retval

int cv::Mat::int_at( int row
                     int col )

AutoIt:
    cv.Mat.int_at( $row, $col ) -> retval

int cv::Mat::int_at( int i0
                     int i1
                     int i2 )

AutoIt:
    cv.Mat.int_at( $i0, $i1, $i2 ) -> retval

int cv::Mat::int_at( cv::Point pt )

AutoIt:
    cv.Mat.int_at( $pt ) -> retval

void cv::Mat::int_set_at( int i0
                          int value )

AutoIt:
    cv.Mat.int_set_at( $i0, $value ) -> None

void cv::Mat::int_set_at( int row
                          int col
                          int value )

AutoIt:
    cv.Mat.int_set_at( $row, $col, $value ) -> None

void cv::Mat::int_set_at( int i0
                          int i1
                          int i2
                          int value )

AutoIt:
    cv.Mat.int_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::int_set_at( cv::Point pt
                          int       value )

AutoIt:
    cv.Mat.int_set_at( $pt, $value ) -> None

float cv::Mat::float_at( int i0 )

AutoIt:
    cv.Mat.float_at( $i0 ) -> retval

float cv::Mat::float_at( int row
                         int col )

AutoIt:
    cv.Mat.float_at( $row, $col ) -> retval

float cv::Mat::float_at( int i0
                         int i1
                         int i2 )

AutoIt:
    cv.Mat.float_at( $i0, $i1, $i2 ) -> retval

float cv::Mat::float_at( cv::Point pt )

AutoIt:
    cv.Mat.float_at( $pt ) -> retval

void cv::Mat::float_set_at( int   i0
                            float value )

AutoIt:
    cv.Mat.float_set_at( $i0, $value ) -> None

void cv::Mat::float_set_at( int   row
                            int   col
                            float value )

AutoIt:
    cv.Mat.float_set_at( $row, $col, $value ) -> None

void cv::Mat::float_set_at( int   i0
                            int   i1
                            int   i2
                            float value )

AutoIt:
    cv.Mat.float_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::float_set_at( cv::Point pt
                            float     value )

AutoIt:
    cv.Mat.float_set_at( $pt, $value ) -> None

double cv::Mat::double_at( int i0 )

AutoIt:
    cv.Mat.double_at( $i0 ) -> retval

double cv::Mat::double_at( int row
                           int col )

AutoIt:
    cv.Mat.double_at( $row, $col ) -> retval

double cv::Mat::double_at( int i0
                           int i1
                           int i2 )

AutoIt:
    cv.Mat.double_at( $i0, $i1, $i2 ) -> retval

double cv::Mat::double_at( cv::Point pt )

AutoIt:
    cv.Mat.double_at( $pt ) -> retval

void cv::Mat::double_set_at( int    i0
                             double value )

AutoIt:
    cv.Mat.double_set_at( $i0, $value ) -> None

void cv::Mat::double_set_at( int    row
                             int    col
                             double value )

AutoIt:
    cv.Mat.double_set_at( $row, $col, $value ) -> None

void cv::Mat::double_set_at( int    i0
                             int    i1
                             int    i2
                             double value )

AutoIt:
    cv.Mat.double_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::double_set_at( cv::Point pt
                             double    value )

AutoIt:
    cv.Mat.double_set_at( $pt, $value ) -> None

cv::Vec2b cv::Mat::Vec2b_at( int i0 )

AutoIt:
    cv.Mat.Vec2b_at( $i0 ) -> retval

cv::Vec2b cv::Mat::Vec2b_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec2b_at( $row, $col ) -> retval

cv::Vec2b cv::Mat::Vec2b_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec2b_at( $i0, $i1, $i2 ) -> retval

cv::Vec2b cv::Mat::Vec2b_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec2b_at( $pt ) -> retval

void cv::Mat::Vec2b_set_at( int       i0
                            cv::Vec2b value )

AutoIt:
    cv.Mat.Vec2b_set_at( $i0, $value ) -> None

void cv::Mat::Vec2b_set_at( int       row
                            int       col
                            cv::Vec2b value )

AutoIt:
    cv.Mat.Vec2b_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec2b_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec2b value )

AutoIt:
    cv.Mat.Vec2b_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec2b_set_at( cv::Point pt
                            cv::Vec2b value )

AutoIt:
    cv.Mat.Vec2b_set_at( $pt, $value ) -> None

cv::Vec3b cv::Mat::Vec3b_at( int i0 )

AutoIt:
    cv.Mat.Vec3b_at( $i0 ) -> retval

cv::Vec3b cv::Mat::Vec3b_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec3b_at( $row, $col ) -> retval

cv::Vec3b cv::Mat::Vec3b_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec3b_at( $i0, $i1, $i2 ) -> retval

cv::Vec3b cv::Mat::Vec3b_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec3b_at( $pt ) -> retval

void cv::Mat::Vec3b_set_at( int       i0
                            cv::Vec3b value )

AutoIt:
    cv.Mat.Vec3b_set_at( $i0, $value ) -> None

void cv::Mat::Vec3b_set_at( int       row
                            int       col
                            cv::Vec3b value )

AutoIt:
    cv.Mat.Vec3b_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec3b_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec3b value )

AutoIt:
    cv.Mat.Vec3b_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec3b_set_at( cv::Point pt
                            cv::Vec3b value )

AutoIt:
    cv.Mat.Vec3b_set_at( $pt, $value ) -> None

cv::Vec4b cv::Mat::Vec4b_at( int i0 )

AutoIt:
    cv.Mat.Vec4b_at( $i0 ) -> retval

cv::Vec4b cv::Mat::Vec4b_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec4b_at( $row, $col ) -> retval

cv::Vec4b cv::Mat::Vec4b_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec4b_at( $i0, $i1, $i2 ) -> retval

cv::Vec4b cv::Mat::Vec4b_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec4b_at( $pt ) -> retval

void cv::Mat::Vec4b_set_at( int       i0
                            cv::Vec4b value )

AutoIt:
    cv.Mat.Vec4b_set_at( $i0, $value ) -> None

void cv::Mat::Vec4b_set_at( int       row
                            int       col
                            cv::Vec4b value )

AutoIt:
    cv.Mat.Vec4b_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec4b_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec4b value )

AutoIt:
    cv.Mat.Vec4b_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec4b_set_at( cv::Point pt
                            cv::Vec4b value )

AutoIt:
    cv.Mat.Vec4b_set_at( $pt, $value ) -> None

cv::Vec2s cv::Mat::Vec2s_at( int i0 )

AutoIt:
    cv.Mat.Vec2s_at( $i0 ) -> retval

cv::Vec2s cv::Mat::Vec2s_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec2s_at( $row, $col ) -> retval

cv::Vec2s cv::Mat::Vec2s_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec2s_at( $i0, $i1, $i2 ) -> retval

cv::Vec2s cv::Mat::Vec2s_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec2s_at( $pt ) -> retval

void cv::Mat::Vec2s_set_at( int       i0
                            cv::Vec2s value )

AutoIt:
    cv.Mat.Vec2s_set_at( $i0, $value ) -> None

void cv::Mat::Vec2s_set_at( int       row
                            int       col
                            cv::Vec2s value )

AutoIt:
    cv.Mat.Vec2s_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec2s_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec2s value )

AutoIt:
    cv.Mat.Vec2s_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec2s_set_at( cv::Point pt
                            cv::Vec2s value )

AutoIt:
    cv.Mat.Vec2s_set_at( $pt, $value ) -> None

cv::Vec3s cv::Mat::Vec3s_at( int i0 )

AutoIt:
    cv.Mat.Vec3s_at( $i0 ) -> retval

cv::Vec3s cv::Mat::Vec3s_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec3s_at( $row, $col ) -> retval

cv::Vec3s cv::Mat::Vec3s_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec3s_at( $i0, $i1, $i2 ) -> retval

cv::Vec3s cv::Mat::Vec3s_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec3s_at( $pt ) -> retval

void cv::Mat::Vec3s_set_at( int       i0
                            cv::Vec3s value )

AutoIt:
    cv.Mat.Vec3s_set_at( $i0, $value ) -> None

void cv::Mat::Vec3s_set_at( int       row
                            int       col
                            cv::Vec3s value )

AutoIt:
    cv.Mat.Vec3s_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec3s_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec3s value )

AutoIt:
    cv.Mat.Vec3s_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec3s_set_at( cv::Point pt
                            cv::Vec3s value )

AutoIt:
    cv.Mat.Vec3s_set_at( $pt, $value ) -> None

cv::Vec4s cv::Mat::Vec4s_at( int i0 )

AutoIt:
    cv.Mat.Vec4s_at( $i0 ) -> retval

cv::Vec4s cv::Mat::Vec4s_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec4s_at( $row, $col ) -> retval

cv::Vec4s cv::Mat::Vec4s_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec4s_at( $i0, $i1, $i2 ) -> retval

cv::Vec4s cv::Mat::Vec4s_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec4s_at( $pt ) -> retval

void cv::Mat::Vec4s_set_at( int       i0
                            cv::Vec4s value )

AutoIt:
    cv.Mat.Vec4s_set_at( $i0, $value ) -> None

void cv::Mat::Vec4s_set_at( int       row
                            int       col
                            cv::Vec4s value )

AutoIt:
    cv.Mat.Vec4s_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec4s_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec4s value )

AutoIt:
    cv.Mat.Vec4s_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec4s_set_at( cv::Point pt
                            cv::Vec4s value )

AutoIt:
    cv.Mat.Vec4s_set_at( $pt, $value ) -> None

cv::Vec2w cv::Mat::Vec2w_at( int i0 )

AutoIt:
    cv.Mat.Vec2w_at( $i0 ) -> retval

cv::Vec2w cv::Mat::Vec2w_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec2w_at( $row, $col ) -> retval

cv::Vec2w cv::Mat::Vec2w_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec2w_at( $i0, $i1, $i2 ) -> retval

cv::Vec2w cv::Mat::Vec2w_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec2w_at( $pt ) -> retval

void cv::Mat::Vec2w_set_at( int       i0
                            cv::Vec2w value )

AutoIt:
    cv.Mat.Vec2w_set_at( $i0, $value ) -> None

void cv::Mat::Vec2w_set_at( int       row
                            int       col
                            cv::Vec2w value )

AutoIt:
    cv.Mat.Vec2w_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec2w_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec2w value )

AutoIt:
    cv.Mat.Vec2w_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec2w_set_at( cv::Point pt
                            cv::Vec2w value )

AutoIt:
    cv.Mat.Vec2w_set_at( $pt, $value ) -> None

cv::Vec3w cv::Mat::Vec3w_at( int i0 )

AutoIt:
    cv.Mat.Vec3w_at( $i0 ) -> retval

cv::Vec3w cv::Mat::Vec3w_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec3w_at( $row, $col ) -> retval

cv::Vec3w cv::Mat::Vec3w_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec3w_at( $i0, $i1, $i2 ) -> retval

cv::Vec3w cv::Mat::Vec3w_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec3w_at( $pt ) -> retval

void cv::Mat::Vec3w_set_at( int       i0
                            cv::Vec3w value )

AutoIt:
    cv.Mat.Vec3w_set_at( $i0, $value ) -> None

void cv::Mat::Vec3w_set_at( int       row
                            int       col
                            cv::Vec3w value )

AutoIt:
    cv.Mat.Vec3w_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec3w_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec3w value )

AutoIt:
    cv.Mat.Vec3w_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec3w_set_at( cv::Point pt
                            cv::Vec3w value )

AutoIt:
    cv.Mat.Vec3w_set_at( $pt, $value ) -> None

cv::Vec4w cv::Mat::Vec4w_at( int i0 )

AutoIt:
    cv.Mat.Vec4w_at( $i0 ) -> retval

cv::Vec4w cv::Mat::Vec4w_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec4w_at( $row, $col ) -> retval

cv::Vec4w cv::Mat::Vec4w_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec4w_at( $i0, $i1, $i2 ) -> retval

cv::Vec4w cv::Mat::Vec4w_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec4w_at( $pt ) -> retval

void cv::Mat::Vec4w_set_at( int       i0
                            cv::Vec4w value )

AutoIt:
    cv.Mat.Vec4w_set_at( $i0, $value ) -> None

void cv::Mat::Vec4w_set_at( int       row
                            int       col
                            cv::Vec4w value )

AutoIt:
    cv.Mat.Vec4w_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec4w_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec4w value )

AutoIt:
    cv.Mat.Vec4w_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec4w_set_at( cv::Point pt
                            cv::Vec4w value )

AutoIt:
    cv.Mat.Vec4w_set_at( $pt, $value ) -> None

cv::Vec2i cv::Mat::Vec2i_at( int i0 )

AutoIt:
    cv.Mat.Vec2i_at( $i0 ) -> retval

cv::Vec2i cv::Mat::Vec2i_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec2i_at( $row, $col ) -> retval

cv::Vec2i cv::Mat::Vec2i_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec2i_at( $i0, $i1, $i2 ) -> retval

cv::Vec2i cv::Mat::Vec2i_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec2i_at( $pt ) -> retval

void cv::Mat::Vec2i_set_at( int       i0
                            cv::Vec2i value )

AutoIt:
    cv.Mat.Vec2i_set_at( $i0, $value ) -> None

void cv::Mat::Vec2i_set_at( int       row
                            int       col
                            cv::Vec2i value )

AutoIt:
    cv.Mat.Vec2i_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec2i_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec2i value )

AutoIt:
    cv.Mat.Vec2i_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec2i_set_at( cv::Point pt
                            cv::Vec2i value )

AutoIt:
    cv.Mat.Vec2i_set_at( $pt, $value ) -> None

cv::Vec3i cv::Mat::Vec3i_at( int i0 )

AutoIt:
    cv.Mat.Vec3i_at( $i0 ) -> retval

cv::Vec3i cv::Mat::Vec3i_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec3i_at( $row, $col ) -> retval

cv::Vec3i cv::Mat::Vec3i_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec3i_at( $i0, $i1, $i2 ) -> retval

cv::Vec3i cv::Mat::Vec3i_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec3i_at( $pt ) -> retval

void cv::Mat::Vec3i_set_at( int       i0
                            cv::Vec3i value )

AutoIt:
    cv.Mat.Vec3i_set_at( $i0, $value ) -> None

void cv::Mat::Vec3i_set_at( int       row
                            int       col
                            cv::Vec3i value )

AutoIt:
    cv.Mat.Vec3i_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec3i_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec3i value )

AutoIt:
    cv.Mat.Vec3i_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec3i_set_at( cv::Point pt
                            cv::Vec3i value )

AutoIt:
    cv.Mat.Vec3i_set_at( $pt, $value ) -> None

cv::Vec4i cv::Mat::Vec4i_at( int i0 )

AutoIt:
    cv.Mat.Vec4i_at( $i0 ) -> retval

cv::Vec4i cv::Mat::Vec4i_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec4i_at( $row, $col ) -> retval

cv::Vec4i cv::Mat::Vec4i_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec4i_at( $i0, $i1, $i2 ) -> retval

cv::Vec4i cv::Mat::Vec4i_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec4i_at( $pt ) -> retval

void cv::Mat::Vec4i_set_at( int       i0
                            cv::Vec4i value )

AutoIt:
    cv.Mat.Vec4i_set_at( $i0, $value ) -> None

void cv::Mat::Vec4i_set_at( int       row
                            int       col
                            cv::Vec4i value )

AutoIt:
    cv.Mat.Vec4i_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec4i_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec4i value )

AutoIt:
    cv.Mat.Vec4i_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec4i_set_at( cv::Point pt
                            cv::Vec4i value )

AutoIt:
    cv.Mat.Vec4i_set_at( $pt, $value ) -> None

cv::Vec6i cv::Mat::Vec6i_at( int i0 )

AutoIt:
    cv.Mat.Vec6i_at( $i0 ) -> retval

cv::Vec6i cv::Mat::Vec6i_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec6i_at( $row, $col ) -> retval

cv::Vec6i cv::Mat::Vec6i_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec6i_at( $i0, $i1, $i2 ) -> retval

cv::Vec6i cv::Mat::Vec6i_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec6i_at( $pt ) -> retval

void cv::Mat::Vec6i_set_at( int       i0
                            cv::Vec6i value )

AutoIt:
    cv.Mat.Vec6i_set_at( $i0, $value ) -> None

void cv::Mat::Vec6i_set_at( int       row
                            int       col
                            cv::Vec6i value )

AutoIt:
    cv.Mat.Vec6i_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec6i_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec6i value )

AutoIt:
    cv.Mat.Vec6i_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec6i_set_at( cv::Point pt
                            cv::Vec6i value )

AutoIt:
    cv.Mat.Vec6i_set_at( $pt, $value ) -> None

cv::Vec8i cv::Mat::Vec8i_at( int i0 )

AutoIt:
    cv.Mat.Vec8i_at( $i0 ) -> retval

cv::Vec8i cv::Mat::Vec8i_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec8i_at( $row, $col ) -> retval

cv::Vec8i cv::Mat::Vec8i_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec8i_at( $i0, $i1, $i2 ) -> retval

cv::Vec8i cv::Mat::Vec8i_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec8i_at( $pt ) -> retval

void cv::Mat::Vec8i_set_at( int       i0
                            cv::Vec8i value )

AutoIt:
    cv.Mat.Vec8i_set_at( $i0, $value ) -> None

void cv::Mat::Vec8i_set_at( int       row
                            int       col
                            cv::Vec8i value )

AutoIt:
    cv.Mat.Vec8i_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec8i_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec8i value )

AutoIt:
    cv.Mat.Vec8i_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec8i_set_at( cv::Point pt
                            cv::Vec8i value )

AutoIt:
    cv.Mat.Vec8i_set_at( $pt, $value ) -> None

cv::Vec2f cv::Mat::Vec2f_at( int i0 )

AutoIt:
    cv.Mat.Vec2f_at( $i0 ) -> retval

cv::Vec2f cv::Mat::Vec2f_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec2f_at( $row, $col ) -> retval

cv::Vec2f cv::Mat::Vec2f_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec2f_at( $i0, $i1, $i2 ) -> retval

cv::Vec2f cv::Mat::Vec2f_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec2f_at( $pt ) -> retval

void cv::Mat::Vec2f_set_at( int       i0
                            cv::Vec2f value )

AutoIt:
    cv.Mat.Vec2f_set_at( $i0, $value ) -> None

void cv::Mat::Vec2f_set_at( int       row
                            int       col
                            cv::Vec2f value )

AutoIt:
    cv.Mat.Vec2f_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec2f_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec2f value )

AutoIt:
    cv.Mat.Vec2f_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec2f_set_at( cv::Point pt
                            cv::Vec2f value )

AutoIt:
    cv.Mat.Vec2f_set_at( $pt, $value ) -> None

cv::Vec3f cv::Mat::Vec3f_at( int i0 )

AutoIt:
    cv.Mat.Vec3f_at( $i0 ) -> retval

cv::Vec3f cv::Mat::Vec3f_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec3f_at( $row, $col ) -> retval

cv::Vec3f cv::Mat::Vec3f_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec3f_at( $i0, $i1, $i2 ) -> retval

cv::Vec3f cv::Mat::Vec3f_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec3f_at( $pt ) -> retval

void cv::Mat::Vec3f_set_at( int       i0
                            cv::Vec3f value )

AutoIt:
    cv.Mat.Vec3f_set_at( $i0, $value ) -> None

void cv::Mat::Vec3f_set_at( int       row
                            int       col
                            cv::Vec3f value )

AutoIt:
    cv.Mat.Vec3f_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec3f_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec3f value )

AutoIt:
    cv.Mat.Vec3f_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec3f_set_at( cv::Point pt
                            cv::Vec3f value )

AutoIt:
    cv.Mat.Vec3f_set_at( $pt, $value ) -> None

cv::Vec4f cv::Mat::Vec4f_at( int i0 )

AutoIt:
    cv.Mat.Vec4f_at( $i0 ) -> retval

cv::Vec4f cv::Mat::Vec4f_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec4f_at( $row, $col ) -> retval

cv::Vec4f cv::Mat::Vec4f_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec4f_at( $i0, $i1, $i2 ) -> retval

cv::Vec4f cv::Mat::Vec4f_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec4f_at( $pt ) -> retval

void cv::Mat::Vec4f_set_at( int       i0
                            cv::Vec4f value )

AutoIt:
    cv.Mat.Vec4f_set_at( $i0, $value ) -> None

void cv::Mat::Vec4f_set_at( int       row
                            int       col
                            cv::Vec4f value )

AutoIt:
    cv.Mat.Vec4f_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec4f_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec4f value )

AutoIt:
    cv.Mat.Vec4f_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec4f_set_at( cv::Point pt
                            cv::Vec4f value )

AutoIt:
    cv.Mat.Vec4f_set_at( $pt, $value ) -> None

cv::Vec6f cv::Mat::Vec6f_at( int i0 )

AutoIt:
    cv.Mat.Vec6f_at( $i0 ) -> retval

cv::Vec6f cv::Mat::Vec6f_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec6f_at( $row, $col ) -> retval

cv::Vec6f cv::Mat::Vec6f_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec6f_at( $i0, $i1, $i2 ) -> retval

cv::Vec6f cv::Mat::Vec6f_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec6f_at( $pt ) -> retval

void cv::Mat::Vec6f_set_at( int       i0
                            cv::Vec6f value )

AutoIt:
    cv.Mat.Vec6f_set_at( $i0, $value ) -> None

void cv::Mat::Vec6f_set_at( int       row
                            int       col
                            cv::Vec6f value )

AutoIt:
    cv.Mat.Vec6f_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec6f_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec6f value )

AutoIt:
    cv.Mat.Vec6f_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec6f_set_at( cv::Point pt
                            cv::Vec6f value )

AutoIt:
    cv.Mat.Vec6f_set_at( $pt, $value ) -> None

cv::Vec2d cv::Mat::Vec2d_at( int i0 )

AutoIt:
    cv.Mat.Vec2d_at( $i0 ) -> retval

cv::Vec2d cv::Mat::Vec2d_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec2d_at( $row, $col ) -> retval

cv::Vec2d cv::Mat::Vec2d_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec2d_at( $i0, $i1, $i2 ) -> retval

cv::Vec2d cv::Mat::Vec2d_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec2d_at( $pt ) -> retval

void cv::Mat::Vec2d_set_at( int       i0
                            cv::Vec2d value )

AutoIt:
    cv.Mat.Vec2d_set_at( $i0, $value ) -> None

void cv::Mat::Vec2d_set_at( int       row
                            int       col
                            cv::Vec2d value )

AutoIt:
    cv.Mat.Vec2d_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec2d_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec2d value )

AutoIt:
    cv.Mat.Vec2d_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec2d_set_at( cv::Point pt
                            cv::Vec2d value )

AutoIt:
    cv.Mat.Vec2d_set_at( $pt, $value ) -> None

cv::Vec3d cv::Mat::Vec3d_at( int i0 )

AutoIt:
    cv.Mat.Vec3d_at( $i0 ) -> retval

cv::Vec3d cv::Mat::Vec3d_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec3d_at( $row, $col ) -> retval

cv::Vec3d cv::Mat::Vec3d_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec3d_at( $i0, $i1, $i2 ) -> retval

cv::Vec3d cv::Mat::Vec3d_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec3d_at( $pt ) -> retval

void cv::Mat::Vec3d_set_at( int       i0
                            cv::Vec3d value )

AutoIt:
    cv.Mat.Vec3d_set_at( $i0, $value ) -> None

void cv::Mat::Vec3d_set_at( int       row
                            int       col
                            cv::Vec3d value )

AutoIt:
    cv.Mat.Vec3d_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec3d_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec3d value )

AutoIt:
    cv.Mat.Vec3d_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec3d_set_at( cv::Point pt
                            cv::Vec3d value )

AutoIt:
    cv.Mat.Vec3d_set_at( $pt, $value ) -> None

cv::Vec4d cv::Mat::Vec4d_at( int i0 )

AutoIt:
    cv.Mat.Vec4d_at( $i0 ) -> retval

cv::Vec4d cv::Mat::Vec4d_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec4d_at( $row, $col ) -> retval

cv::Vec4d cv::Mat::Vec4d_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec4d_at( $i0, $i1, $i2 ) -> retval

cv::Vec4d cv::Mat::Vec4d_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec4d_at( $pt ) -> retval

void cv::Mat::Vec4d_set_at( int       i0
                            cv::Vec4d value )

AutoIt:
    cv.Mat.Vec4d_set_at( $i0, $value ) -> None

void cv::Mat::Vec4d_set_at( int       row
                            int       col
                            cv::Vec4d value )

AutoIt:
    cv.Mat.Vec4d_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec4d_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec4d value )

AutoIt:
    cv.Mat.Vec4d_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec4d_set_at( cv::Point pt
                            cv::Vec4d value )

AutoIt:
    cv.Mat.Vec4d_set_at( $pt, $value ) -> None

cv::Vec6d cv::Mat::Vec6d_at( int i0 )

AutoIt:
    cv.Mat.Vec6d_at( $i0 ) -> retval

cv::Vec6d cv::Mat::Vec6d_at( int row
                             int col )

AutoIt:
    cv.Mat.Vec6d_at( $row, $col ) -> retval

cv::Vec6d cv::Mat::Vec6d_at( int i0
                             int i1
                             int i2 )

AutoIt:
    cv.Mat.Vec6d_at( $i0, $i1, $i2 ) -> retval

cv::Vec6d cv::Mat::Vec6d_at( cv::Point pt )

AutoIt:
    cv.Mat.Vec6d_at( $pt ) -> retval

void cv::Mat::Vec6d_set_at( int       i0
                            cv::Vec6d value )

AutoIt:
    cv.Mat.Vec6d_set_at( $i0, $value ) -> None

void cv::Mat::Vec6d_set_at( int       row
                            int       col
                            cv::Vec6d value )

AutoIt:
    cv.Mat.Vec6d_set_at( $row, $col, $value ) -> None

void cv::Mat::Vec6d_set_at( int       i0
                            int       i1
                            int       i2
                            cv::Vec6d value )

AutoIt:
    cv.Mat.Vec6d_set_at( $i0, $i1, $i2, $value ) -> None

void cv::Mat::Vec6d_set_at( cv::Point pt
                            cv::Vec6d value )

AutoIt:
    cv.Mat.Vec6d_set_at( $pt, $value ) -> None

static cv::UMat cv::UMat::create()

AutoIt:
    cv.UMat.create() -> <cv.UMat object>

static cv::UMat cv::UMat::create( cv::UMat m )

AutoIt:
    cv.UMat.create( $m ) -> <cv.UMat object>

static cv::UMat cv::UMat::create( int usageFlags = cv::USAGE_DEFAULT )

AutoIt:
    cv.UMat.create( [$usageFlags] ) -> <cv.UMat object>

static cv::UMat cv::UMat::create( int rows
                                  int cols
                                  int type
                                  int usageFlags = cv::USAGE_DEFAULT )

AutoIt:
    cv.UMat.create( $rows, $cols, $type[, $usageFlags] ) -> <cv.UMat object>

static cv::UMat cv::UMat::create( int        rows
                                  int        cols
                                  int        type
                                  cv::Scalar s
                                  int        usageFlags = cv::USAGE_DEFAULT )

AutoIt:
    cv.UMat.create( $rows, $cols, $type, $s[, $usageFlags] ) -> <cv.UMat object>

cv::Mat cv::UMat::getMat( int access )

AutoIt:
    cv.UMat.getMat( $access ) -> retval

bool cv::ocl::haveOpenCL()

AutoIt:
    cv.ocl.haveOpenCL() -> retval

bool cv::ocl::useOpenCL()

AutoIt:
    cv.ocl.useOpenCL() -> retval

bool cv::ocl::haveAmdBlas()

AutoIt:
    cv.ocl.haveAmdBlas() -> retval

bool cv::ocl::haveAmdFft()

AutoIt:
    cv.ocl.haveAmdFft() -> retval

void cv::ocl::setUseOpenCL( bool flag )

AutoIt:
    cv.ocl.setUseOpenCL( $flag ) -> None

void cv::ocl::finish()

AutoIt:
    cv.ocl.finish() -> None

static cv::ocl::Device cv::ocl::Device::create()

AutoIt:
    cv.ocl.Device.create() -> <cv.ocl.Device object>

std::string cv::ocl::Device::name()

AutoIt:
    cv.ocl.Device.name() -> retval

std::string cv::ocl::Device::extensions()

AutoIt:
    cv.ocl.Device.extensions() -> retval

bool cv::ocl::Device::isExtensionSupported( const std::string& extensionName )

AutoIt:
    cv.ocl.Device.isExtensionSupported( $extensionName ) -> retval

std::string cv::ocl::Device::version()

AutoIt:
    cv.ocl.Device.version() -> retval

std::string cv::ocl::Device::vendorName()

AutoIt:
    cv.ocl.Device.vendorName() -> retval

std::string cv::ocl::Device::OpenCL_C_Version()

AutoIt:
    cv.ocl.Device.OpenCL_C_Version() -> retval

std::string cv::ocl::Device::OpenCLVersion()

AutoIt:
    cv.ocl.Device.OpenCLVersion() -> retval

int cv::ocl::Device::deviceVersionMajor()

AutoIt:
    cv.ocl.Device.deviceVersionMajor() -> retval

int cv::ocl::Device::deviceVersionMinor()

AutoIt:
    cv.ocl.Device.deviceVersionMinor() -> retval

std::string cv::ocl::Device::driverVersion()

AutoIt:
    cv.ocl.Device.driverVersion() -> retval

int cv::ocl::Device::type()

AutoIt:
    cv.ocl.Device.type() -> retval

int cv::ocl::Device::addressBits()

AutoIt:
    cv.ocl.Device.addressBits() -> retval

bool cv::ocl::Device::available()

AutoIt:
    cv.ocl.Device.available() -> retval

bool cv::ocl::Device::compilerAvailable()

AutoIt:
    cv.ocl.Device.compilerAvailable() -> retval

bool cv::ocl::Device::linkerAvailable()

AutoIt:
    cv.ocl.Device.linkerAvailable() -> retval

int cv::ocl::Device::doubleFPConfig()

AutoIt:
    cv.ocl.Device.doubleFPConfig() -> retval

int cv::ocl::Device::singleFPConfig()

AutoIt:
    cv.ocl.Device.singleFPConfig() -> retval

int cv::ocl::Device::halfFPConfig()

AutoIt:
    cv.ocl.Device.halfFPConfig() -> retval

bool cv::ocl::Device::endianLittle()

AutoIt:
    cv.ocl.Device.endianLittle() -> retval

bool cv::ocl::Device::errorCorrectionSupport()

AutoIt:
    cv.ocl.Device.errorCorrectionSupport() -> retval

int cv::ocl::Device::executionCapabilities()

AutoIt:
    cv.ocl.Device.executionCapabilities() -> retval

size_t cv::ocl::Device::globalMemCacheSize()

AutoIt:
    cv.ocl.Device.globalMemCacheSize() -> retval

int cv::ocl::Device::globalMemCacheType()

AutoIt:
    cv.ocl.Device.globalMemCacheType() -> retval

int cv::ocl::Device::globalMemCacheLineSize()

AutoIt:
    cv.ocl.Device.globalMemCacheLineSize() -> retval

size_t cv::ocl::Device::globalMemSize()

AutoIt:
    cv.ocl.Device.globalMemSize() -> retval

size_t cv::ocl::Device::localMemSize()

AutoIt:
    cv.ocl.Device.localMemSize() -> retval

int cv::ocl::Device::localMemType()

AutoIt:
    cv.ocl.Device.localMemType() -> retval

bool cv::ocl::Device::hostUnifiedMemory()

AutoIt:
    cv.ocl.Device.hostUnifiedMemory() -> retval

bool cv::ocl::Device::imageSupport()

AutoIt:
    cv.ocl.Device.imageSupport() -> retval

bool cv::ocl::Device::imageFromBufferSupport()

AutoIt:
    cv.ocl.Device.imageFromBufferSupport() -> retval

bool cv::ocl::Device::intelSubgroupsSupport()

AutoIt:
    cv.ocl.Device.intelSubgroupsSupport() -> retval

size_t cv::ocl::Device::image2DMaxWidth()

AutoIt:
    cv.ocl.Device.image2DMaxWidth() -> retval

size_t cv::ocl::Device::image2DMaxHeight()

AutoIt:
    cv.ocl.Device.image2DMaxHeight() -> retval

size_t cv::ocl::Device::image3DMaxWidth()

AutoIt:
    cv.ocl.Device.image3DMaxWidth() -> retval

size_t cv::ocl::Device::image3DMaxHeight()

AutoIt:
    cv.ocl.Device.image3DMaxHeight() -> retval

size_t cv::ocl::Device::image3DMaxDepth()

AutoIt:
    cv.ocl.Device.image3DMaxDepth() -> retval

size_t cv::ocl::Device::imageMaxBufferSize()

AutoIt:
    cv.ocl.Device.imageMaxBufferSize() -> retval

size_t cv::ocl::Device::imageMaxArraySize()

AutoIt:
    cv.ocl.Device.imageMaxArraySize() -> retval

int cv::ocl::Device::vendorID()

AutoIt:
    cv.ocl.Device.vendorID() -> retval

bool cv::ocl::Device::isAMD()

AutoIt:
    cv.ocl.Device.isAMD() -> retval

bool cv::ocl::Device::isIntel()

AutoIt:
    cv.ocl.Device.isIntel() -> retval

bool cv::ocl::Device::isNVidia()

AutoIt:
    cv.ocl.Device.isNVidia() -> retval

int cv::ocl::Device::maxClockFrequency()

AutoIt:
    cv.ocl.Device.maxClockFrequency() -> retval

int cv::ocl::Device::maxComputeUnits()

AutoIt:
    cv.ocl.Device.maxComputeUnits() -> retval

int cv::ocl::Device::maxConstantArgs()

AutoIt:
    cv.ocl.Device.maxConstantArgs() -> retval

size_t cv::ocl::Device::maxConstantBufferSize()

AutoIt:
    cv.ocl.Device.maxConstantBufferSize() -> retval

size_t cv::ocl::Device::maxMemAllocSize()

AutoIt:
    cv.ocl.Device.maxMemAllocSize() -> retval

size_t cv::ocl::Device::maxParameterSize()

AutoIt:
    cv.ocl.Device.maxParameterSize() -> retval

int cv::ocl::Device::maxReadImageArgs()

AutoIt:
    cv.ocl.Device.maxReadImageArgs() -> retval

int cv::ocl::Device::maxWriteImageArgs()

AutoIt:
    cv.ocl.Device.maxWriteImageArgs() -> retval

int cv::ocl::Device::maxSamplers()

AutoIt:
    cv.ocl.Device.maxSamplers() -> retval

size_t cv::ocl::Device::maxWorkGroupSize()

AutoIt:
    cv.ocl.Device.maxWorkGroupSize() -> retval

int cv::ocl::Device::maxWorkItemDims()

AutoIt:
    cv.ocl.Device.maxWorkItemDims() -> retval

int cv::ocl::Device::memBaseAddrAlign()

AutoIt:
    cv.ocl.Device.memBaseAddrAlign() -> retval

int cv::ocl::Device::nativeVectorWidthChar()

AutoIt:
    cv.ocl.Device.nativeVectorWidthChar() -> retval

int cv::ocl::Device::nativeVectorWidthShort()

AutoIt:
    cv.ocl.Device.nativeVectorWidthShort() -> retval

int cv::ocl::Device::nativeVectorWidthInt()

AutoIt:
    cv.ocl.Device.nativeVectorWidthInt() -> retval

int cv::ocl::Device::nativeVectorWidthLong()

AutoIt:
    cv.ocl.Device.nativeVectorWidthLong() -> retval

int cv::ocl::Device::nativeVectorWidthFloat()

AutoIt:
    cv.ocl.Device.nativeVectorWidthFloat() -> retval

int cv::ocl::Device::nativeVectorWidthDouble()

AutoIt:
    cv.ocl.Device.nativeVectorWidthDouble() -> retval

int cv::ocl::Device::nativeVectorWidthHalf()

AutoIt:
    cv.ocl.Device.nativeVectorWidthHalf() -> retval

int cv::ocl::Device::preferredVectorWidthChar()

AutoIt:
    cv.ocl.Device.preferredVectorWidthChar() -> retval

int cv::ocl::Device::preferredVectorWidthShort()

AutoIt:
    cv.ocl.Device.preferredVectorWidthShort() -> retval

int cv::ocl::Device::preferredVectorWidthInt()

AutoIt:
    cv.ocl.Device.preferredVectorWidthInt() -> retval

int cv::ocl::Device::preferredVectorWidthLong()

AutoIt:
    cv.ocl.Device.preferredVectorWidthLong() -> retval

int cv::ocl::Device::preferredVectorWidthFloat()

AutoIt:
    cv.ocl.Device.preferredVectorWidthFloat() -> retval

int cv::ocl::Device::preferredVectorWidthDouble()

AutoIt:
    cv.ocl.Device.preferredVectorWidthDouble() -> retval

int cv::ocl::Device::preferredVectorWidthHalf()

AutoIt:
    cv.ocl.Device.preferredVectorWidthHalf() -> retval

size_t cv::ocl::Device::printfBufferSize()

AutoIt:
    cv.ocl.Device.printfBufferSize() -> retval

size_t cv::ocl::Device::profilingTimerResolution()

AutoIt:
    cv.ocl.Device.profilingTimerResolution() -> retval

static cv::ocl::Device cv::ocl::Device::getDefault()

AutoIt:
    cv.ocl.Device.getDefault() -> retval

static cv::FileStorage cv::FileStorage::create()

AutoIt:
    cv.FileStorage.create() -> <cv.FileStorage object>

static cv::FileStorage cv::FileStorage::create( const std::string& filename
                                                int                flags
                                                const std::string& encoding = String() )

AutoIt:
    cv.FileStorage.create( $filename, $flags[, $encoding] ) -> <cv.FileStorage object>

bool cv::FileStorage::open( const std::string& filename
                            int                flags
                            const std::string& encoding = String() )

AutoIt:
    cv.FileStorage.open( $filename, $flags[, $encoding] ) -> retval

bool cv::FileStorage::isOpened()

AutoIt:
    cv.FileStorage.isOpened() -> retval

void cv::FileStorage::release()

AutoIt:
    cv.FileStorage.release() -> None

std::string cv::FileStorage::releaseAndGetString()

AutoIt:
    cv.FileStorage.releaseAndGetString() -> retval

cv::FileNode cv::FileStorage::getFirstTopLevelNode()

AutoIt:
    cv.FileStorage.getFirstTopLevelNode() -> retval

cv::FileNode cv::FileStorage::root( int streamidx = 0 )

AutoIt:
    cv.FileStorage.root( [$streamidx] ) -> retval

cv::FileNode cv::FileStorage::getNode( const char* nodename )

AutoIt:
    cv.FileStorage.getNode( $nodename ) -> retval

void cv::FileStorage::write( const std::string& name
                             int                val )

AutoIt:
    cv.FileStorage.write( $name, $val ) -> None

void cv::FileStorage::write( const std::string& name
                             double             val )

AutoIt:
    cv.FileStorage.write( $name, $val ) -> None

void cv::FileStorage::write( const std::string& name
                             const std::string& val )

AutoIt:
    cv.FileStorage.write( $name, $val ) -> None

void cv::FileStorage::write( const std::string& name
                             const cv::Mat&     val )

AutoIt:
    cv.FileStorage.write( $name, $val ) -> None

void cv::FileStorage::write( const std::string&              name
                             const std::vector<std::string>& val )

AutoIt:
    cv.FileStorage.write( $name, $val ) -> None

void cv::FileStorage::writeComment( const std::string& comment
                                    bool               append = false )

AutoIt:
    cv.FileStorage.writeComment( $comment[, $append] ) -> None

void cv::FileStorage::startWriteStruct( const std::string& name
                                        int                flags
                                        const std::string& typeName = String() )

AutoIt:
    cv.FileStorage.startWriteStruct( $name, $flags[, $typeName] ) -> None

void cv::FileStorage::endWriteStruct()

AutoIt:
    cv.FileStorage.endWriteStruct() -> None

int cv::FileStorage::getFormat()

AutoIt:
    cv.FileStorage.getFormat() -> retval

static cv::FileNode cv::FileNode::create()

AutoIt:
    cv.FileNode.create() -> <cv.FileNode object>

cv::FileNode cv::FileNode::getNode( const char* nodename )

AutoIt:
    cv.FileNode.getNode( $nodename ) -> retval

cv::FileNode cv::FileNode::at( int i )

AutoIt:
    cv.FileNode.at( $i ) -> retval

std::vector<std::string> cv::FileNode::keys()

AutoIt:
    cv.FileNode.keys() -> retval

int cv::FileNode::type()

AutoIt:
    cv.FileNode.type() -> retval

bool cv::FileNode::empty()

AutoIt:
    cv.FileNode.empty() -> retval

bool cv::FileNode::isNone()

AutoIt:
    cv.FileNode.isNone() -> retval

bool cv::FileNode::isSeq()

AutoIt:
    cv.FileNode.isSeq() -> retval

bool cv::FileNode::isMap()

AutoIt:
    cv.FileNode.isMap() -> retval

bool cv::FileNode::isInt()

AutoIt:
    cv.FileNode.isInt() -> retval

bool cv::FileNode::isReal()

AutoIt:
    cv.FileNode.isReal() -> retval

bool cv::FileNode::isString()

AutoIt:
    cv.FileNode.isString() -> retval

bool cv::FileNode::isNamed()

AutoIt:
    cv.FileNode.isNamed() -> retval

std::string cv::FileNode::name()

AutoIt:
    cv.FileNode.name() -> retval

size_t cv::FileNode::size()

AutoIt:
    cv.FileNode.size() -> retval

size_t cv::FileNode::rawSize()

AutoIt:
    cv.FileNode.rawSize() -> retval

double cv::FileNode::real()

AutoIt:
    cv.FileNode.real() -> retval

std::string cv::FileNode::string()

AutoIt:
    cv.FileNode.string() -> retval

cv::Mat cv::FileNode::mat()

AutoIt:
    cv.FileNode.mat() -> retval

static cv::KeyPoint cv::KeyPoint::create()

AutoIt:
    cv.KeyPoint.create() -> <cv.KeyPoint object>

static cv::KeyPoint cv::KeyPoint::create( float x
                                          float y
                                          float size
                                          float angle = -1
                                          float response = 0
                                          int   octave = 0
                                          int   class_id = -1 )

AutoIt:
    cv.KeyPoint.create( $x, $y, $size[, $angle[, $response[, $octave[, $class_id]]]] ) -> <cv.KeyPoint object>

static void cv::KeyPoint::convert( const std::vector<cv::KeyPoint>& keypoints
                                   std::vector<cv::Point2f>&        points2f
                                   const std::vector<int>&          keypointIndexes = std::vector<int>() )

AutoIt:
    cv.KeyPoint.convert( $keypoints[, $keypointIndexes[, $points2f]] ) -> points2f

static void cv::KeyPoint::convert( const std::vector<cv::Point2f>& points2f
                                   std::vector<cv::KeyPoint>&      keypoints
                                   float                           size = 1
                                   float                           response = 1
                                   int                             octave = 0
                                   int                             class_id = -1 )

AutoIt:
    cv.KeyPoint.convert( $points2f[, $size[, $response[, $octave[, $class_id[, $keypoints]]]]] ) -> keypoints

static float cv::KeyPoint::overlap( const cv::KeyPoint& kp1
                                    const cv::KeyPoint& kp2 )

AutoIt:
    cv.KeyPoint.overlap( $kp1, $kp2 ) -> retval

static cv::DMatch cv::DMatch::create()

AutoIt:
    cv.DMatch.create() -> <cv.DMatch object>

static cv::DMatch cv::DMatch::create( int   _queryIdx
                                      int   _trainIdx
                                      float _distance )

AutoIt:
    cv.DMatch.create( $_queryIdx, $_trainIdx, $_distance ) -> <cv.DMatch object>

static cv::DMatch cv::DMatch::create( int   _queryIdx
                                      int   _trainIdx
                                      int   _imgIdx
                                      float _distance )

AutoIt:
    cv.DMatch.create( $_queryIdx, $_trainIdx, $_imgIdx, $_distance ) -> <cv.DMatch object>

static cv::TermCriteria cv::TermCriteria::create()

AutoIt:
    cv.TermCriteria.create() -> <cv.TermCriteria object>

static cv::TickMeter cv::TickMeter::create()

AutoIt:
    cv.TickMeter.create() -> <cv.TickMeter object>

void cv::TickMeter::start()

AutoIt:
    cv.TickMeter.start() -> None

void cv::TickMeter::stop()

AutoIt:
    cv.TickMeter.stop() -> None

int64 cv::TickMeter::getTimeTicks()

AutoIt:
    cv.TickMeter.getTimeTicks() -> retval

double cv::TickMeter::getTimeMicro()

AutoIt:
    cv.TickMeter.getTimeMicro() -> retval

double cv::TickMeter::getTimeMilli()

AutoIt:
    cv.TickMeter.getTimeMilli() -> retval

double cv::TickMeter::getTimeSec()

AutoIt:
    cv.TickMeter.getTimeSec() -> retval

int64 cv::TickMeter::getCounter()

AutoIt:
    cv.TickMeter.getCounter() -> retval

double cv::TickMeter::getFPS()

AutoIt:
    cv.TickMeter.getFPS() -> retval

double cv::TickMeter::getAvgTimeSec()

AutoIt:
    cv.TickMeter.getAvgTimeSec() -> retval

double cv::TickMeter::getAvgTimeMilli()

AutoIt:
    cv.TickMeter.getAvgTimeMilli() -> retval

void cv::TickMeter::reset()

AutoIt:
    cv.TickMeter.reset() -> None

std::string cv::samples::findFile( const std::string& relative_path
                                   bool               required = true
                                   bool               silentMode = false )

AutoIt:
    cv.samples.findFile( $relative_path[, $required[, $silentMode]] ) -> retval

std::string cv::samples::findFileOrKeep( const std::string& relative_path
                                         bool               silentMode = false )

AutoIt:
    cv.samples.findFileOrKeep( $relative_path[, $silentMode] ) -> retval

void cv::samples::addSamplesDataSearchPath( const std::string& path )

AutoIt:
    cv.samples.addSamplesDataSearchPath( $path ) -> None

void cv::samples::addSamplesDataSearchSubDirectory( const std::string& subdir )

AutoIt:
    cv.samples.addSamplesDataSearchSubDirectory( $subdir ) -> None

static cv::flann::Index cv::flann::Index::create()

AutoIt:
    cv.flann.Index.create() -> <cv.flann.Index object>

static cv::flann::Index cv::flann::Index::create( _InputArray        features
                                                  const IndexParams& params
                                                  int                distType = cvflann::FLANN_DIST_L2 )

AutoIt:
    cv.flann.Index.create( $features, $params[, $distType] ) -> <cv.flann.Index object>

void cv::flann::Index::build( _InputArray        features
                              const IndexParams& params
                              int                distType = cvflann::FLANN_DIST_L2 )

AutoIt:
    cv.flann.Index.build( $features, $params[, $distType] ) -> None

void cv::flann::Index::knnSearch( _InputArray         query
                                  _OutputArray        indices
                                  _OutputArray        dists
                                  int                 knn
                                  const SearchParams& params = SearchParams() )

AutoIt:
    cv.flann.Index.knnSearch( $query, $knn[, $indices[, $dists[, $params]]] ) -> indices, dists

int cv::flann::Index::radiusSearch( _InputArray         query
                                    _OutputArray        indices
                                    _OutputArray        dists
                                    double              radius
                                    int                 maxResults
                                    const SearchParams& params = SearchParams() )

AutoIt:
    cv.flann.Index.radiusSearch( $query, $radius, $maxResults[, $indices[, $dists[, $params]]] ) -> retval, indices, dists

void cv::flann::Index::save( const std::string& filename )

AutoIt:
    cv.flann.Index.save( $filename ) -> None

bool cv::flann::Index::load( _InputArray        features
                             const std::string& filename )

AutoIt:
    cv.flann.Index.load( $features, $filename ) -> retval

void cv::flann::Index::release()

AutoIt:
    cv.flann.Index.release() -> None

int cv::flann::Index::getDistance()

AutoIt:
    cv.flann.Index.getDistance() -> retval

int cv::flann::Index::getAlgorithm()

AutoIt:
    cv.flann.Index.getAlgorithm() -> retval

void cv::GeneralizedHough::setTemplate( _InputArray templ
                                        cv::Point   templCenter = Point(-1, -1) )

AutoIt:
    cv.GeneralizedHough.setTemplate( $templ[, $templCenter] ) -> None

void cv::GeneralizedHough::setTemplate( _InputArray edges
                                        _InputArray dx
                                        _InputArray dy
                                        cv::Point   templCenter = Point(-1, -1) )

AutoIt:
    cv.GeneralizedHough.setTemplate( $edges, $dx, $dy[, $templCenter] ) -> None

void cv::GeneralizedHough::detect( _InputArray  image
                                   _OutputArray positions
                                   _OutputArray votes = noArray() )

AutoIt:
    cv.GeneralizedHough.detect( $image[, $positions[, $votes]] ) -> positions, votes

void cv::GeneralizedHough::detect( _InputArray  edges
                                   _InputArray  dx
                                   _InputArray  dy
                                   _OutputArray positions
                                   _OutputArray votes = noArray() )

AutoIt:
    cv.GeneralizedHough.detect( $edges, $dx, $dy[, $positions[, $votes]] ) -> positions, votes

void cv::GeneralizedHough::setCannyLowThresh( int cannyLowThresh )

AutoIt:
    cv.GeneralizedHough.setCannyLowThresh( $cannyLowThresh ) -> None

int cv::GeneralizedHough::getCannyLowThresh()

AutoIt:
    cv.GeneralizedHough.getCannyLowThresh() -> retval

void cv::GeneralizedHough::setCannyHighThresh( int cannyHighThresh )

AutoIt:
    cv.GeneralizedHough.setCannyHighThresh( $cannyHighThresh ) -> None

int cv::GeneralizedHough::getCannyHighThresh()

AutoIt:
    cv.GeneralizedHough.getCannyHighThresh() -> retval

void cv::GeneralizedHough::setMinDist( double minDist )

AutoIt:
    cv.GeneralizedHough.setMinDist( $minDist ) -> None

double cv::GeneralizedHough::getMinDist()

AutoIt:
    cv.GeneralizedHough.getMinDist() -> retval

void cv::GeneralizedHough::setDp( double dp )

AutoIt:
    cv.GeneralizedHough.setDp( $dp ) -> None

double cv::GeneralizedHough::getDp()

AutoIt:
    cv.GeneralizedHough.getDp() -> retval

void cv::GeneralizedHough::setMaxBufferSize( int maxBufferSize )

AutoIt:
    cv.GeneralizedHough.setMaxBufferSize( $maxBufferSize ) -> None

int cv::GeneralizedHough::getMaxBufferSize()

AutoIt:
    cv.GeneralizedHough.getMaxBufferSize() -> retval

void cv::GeneralizedHough::clear()

AutoIt:
    cv.GeneralizedHough.clear() -> None

void cv::GeneralizedHough::write( const cv::Ptr<cv::FileStorage>& fs
                                  const std::string&              name = String() )

AutoIt:
    cv.GeneralizedHough.write( $fs[, $name] ) -> None

void cv::GeneralizedHough::read( const cv::FileNode& fn )

AutoIt:
    cv.GeneralizedHough.read( $fn ) -> None

bool cv::GeneralizedHough::empty()

AutoIt:
    cv.GeneralizedHough.empty() -> retval

void cv::GeneralizedHough::save( const std::string& filename )

AutoIt:
    cv.GeneralizedHough.save( $filename ) -> None

std::string cv::GeneralizedHough::getDefaultName()

AutoIt:
    cv.GeneralizedHough.getDefaultName() -> retval

void cv::GeneralizedHoughBallard::setLevels( int levels )

AutoIt:
    cv.GeneralizedHoughBallard.setLevels( $levels ) -> None

int cv::GeneralizedHoughBallard::getLevels()

AutoIt:
    cv.GeneralizedHoughBallard.getLevels() -> retval

void cv::GeneralizedHoughBallard::setVotesThreshold( int votesThreshold )

AutoIt:
    cv.GeneralizedHoughBallard.setVotesThreshold( $votesThreshold ) -> None

int cv::GeneralizedHoughBallard::getVotesThreshold()

AutoIt:
    cv.GeneralizedHoughBallard.getVotesThreshold() -> retval

void cv::GeneralizedHoughBallard::setTemplate( _InputArray templ
                                               cv::Point   templCenter = Point(-1, -1) )

AutoIt:
    cv.GeneralizedHoughBallard.setTemplate( $templ[, $templCenter] ) -> None

void cv::GeneralizedHoughBallard::setTemplate( _InputArray edges
                                               _InputArray dx
                                               _InputArray dy
                                               cv::Point   templCenter = Point(-1, -1) )

AutoIt:
    cv.GeneralizedHoughBallard.setTemplate( $edges, $dx, $dy[, $templCenter] ) -> None

void cv::GeneralizedHoughBallard::detect( _InputArray  image
                                          _OutputArray positions
                                          _OutputArray votes = noArray() )

AutoIt:
    cv.GeneralizedHoughBallard.detect( $image[, $positions[, $votes]] ) -> positions, votes

void cv::GeneralizedHoughBallard::detect( _InputArray  edges
                                          _InputArray  dx
                                          _InputArray  dy
                                          _OutputArray positions
                                          _OutputArray votes = noArray() )

AutoIt:
    cv.GeneralizedHoughBallard.detect( $edges, $dx, $dy[, $positions[, $votes]] ) -> positions, votes

void cv::GeneralizedHoughBallard::setCannyLowThresh( int cannyLowThresh )

AutoIt:
    cv.GeneralizedHoughBallard.setCannyLowThresh( $cannyLowThresh ) -> None

int cv::GeneralizedHoughBallard::getCannyLowThresh()

AutoIt:
    cv.GeneralizedHoughBallard.getCannyLowThresh() -> retval

void cv::GeneralizedHoughBallard::setCannyHighThresh( int cannyHighThresh )

AutoIt:
    cv.GeneralizedHoughBallard.setCannyHighThresh( $cannyHighThresh ) -> None

int cv::GeneralizedHoughBallard::getCannyHighThresh()

AutoIt:
    cv.GeneralizedHoughBallard.getCannyHighThresh() -> retval

void cv::GeneralizedHoughBallard::setMinDist( double minDist )

AutoIt:
    cv.GeneralizedHoughBallard.setMinDist( $minDist ) -> None

double cv::GeneralizedHoughBallard::getMinDist()

AutoIt:
    cv.GeneralizedHoughBallard.getMinDist() -> retval

void cv::GeneralizedHoughBallard::setDp( double dp )

AutoIt:
    cv.GeneralizedHoughBallard.setDp( $dp ) -> None

double cv::GeneralizedHoughBallard::getDp()

AutoIt:
    cv.GeneralizedHoughBallard.getDp() -> retval

void cv::GeneralizedHoughBallard::setMaxBufferSize( int maxBufferSize )

AutoIt:
    cv.GeneralizedHoughBallard.setMaxBufferSize( $maxBufferSize ) -> None

int cv::GeneralizedHoughBallard::getMaxBufferSize()

AutoIt:
    cv.GeneralizedHoughBallard.getMaxBufferSize() -> retval

void cv::GeneralizedHoughBallard::clear()

AutoIt:
    cv.GeneralizedHoughBallard.clear() -> None

void cv::GeneralizedHoughBallard::write( const cv::Ptr<cv::FileStorage>& fs
                                         const std::string&              name = String() )

AutoIt:
    cv.GeneralizedHoughBallard.write( $fs[, $name] ) -> None

void cv::GeneralizedHoughBallard::read( const cv::FileNode& fn )

AutoIt:
    cv.GeneralizedHoughBallard.read( $fn ) -> None

bool cv::GeneralizedHoughBallard::empty()

AutoIt:
    cv.GeneralizedHoughBallard.empty() -> retval

void cv::GeneralizedHoughBallard::save( const std::string& filename )

AutoIt:
    cv.GeneralizedHoughBallard.save( $filename ) -> None

std::string cv::GeneralizedHoughBallard::getDefaultName()

AutoIt:
    cv.GeneralizedHoughBallard.getDefaultName() -> retval

void cv::GeneralizedHoughGuil::setXi( double xi )

AutoIt:
    cv.GeneralizedHoughGuil.setXi( $xi ) -> None

double cv::GeneralizedHoughGuil::getXi()

AutoIt:
    cv.GeneralizedHoughGuil.getXi() -> retval

void cv::GeneralizedHoughGuil::setLevels( int levels )

AutoIt:
    cv.GeneralizedHoughGuil.setLevels( $levels ) -> None

int cv::GeneralizedHoughGuil::getLevels()

AutoIt:
    cv.GeneralizedHoughGuil.getLevels() -> retval

void cv::GeneralizedHoughGuil::setAngleEpsilon( double angleEpsilon )

AutoIt:
    cv.GeneralizedHoughGuil.setAngleEpsilon( $angleEpsilon ) -> None

double cv::GeneralizedHoughGuil::getAngleEpsilon()

AutoIt:
    cv.GeneralizedHoughGuil.getAngleEpsilon() -> retval

void cv::GeneralizedHoughGuil::setMinAngle( double minAngle )

AutoIt:
    cv.GeneralizedHoughGuil.setMinAngle( $minAngle ) -> None

double cv::GeneralizedHoughGuil::getMinAngle()

AutoIt:
    cv.GeneralizedHoughGuil.getMinAngle() -> retval

void cv::GeneralizedHoughGuil::setMaxAngle( double maxAngle )

AutoIt:
    cv.GeneralizedHoughGuil.setMaxAngle( $maxAngle ) -> None

double cv::GeneralizedHoughGuil::getMaxAngle()

AutoIt:
    cv.GeneralizedHoughGuil.getMaxAngle() -> retval

void cv::GeneralizedHoughGuil::setAngleStep( double angleStep )

AutoIt:
    cv.GeneralizedHoughGuil.setAngleStep( $angleStep ) -> None

double cv::GeneralizedHoughGuil::getAngleStep()

AutoIt:
    cv.GeneralizedHoughGuil.getAngleStep() -> retval

void cv::GeneralizedHoughGuil::setAngleThresh( int angleThresh )

AutoIt:
    cv.GeneralizedHoughGuil.setAngleThresh( $angleThresh ) -> None

int cv::GeneralizedHoughGuil::getAngleThresh()

AutoIt:
    cv.GeneralizedHoughGuil.getAngleThresh() -> retval

void cv::GeneralizedHoughGuil::setMinScale( double minScale )

AutoIt:
    cv.GeneralizedHoughGuil.setMinScale( $minScale ) -> None

double cv::GeneralizedHoughGuil::getMinScale()

AutoIt:
    cv.GeneralizedHoughGuil.getMinScale() -> retval

void cv::GeneralizedHoughGuil::setMaxScale( double maxScale )

AutoIt:
    cv.GeneralizedHoughGuil.setMaxScale( $maxScale ) -> None

double cv::GeneralizedHoughGuil::getMaxScale()

AutoIt:
    cv.GeneralizedHoughGuil.getMaxScale() -> retval

void cv::GeneralizedHoughGuil::setScaleStep( double scaleStep )

AutoIt:
    cv.GeneralizedHoughGuil.setScaleStep( $scaleStep ) -> None

double cv::GeneralizedHoughGuil::getScaleStep()

AutoIt:
    cv.GeneralizedHoughGuil.getScaleStep() -> retval

void cv::GeneralizedHoughGuil::setScaleThresh( int scaleThresh )

AutoIt:
    cv.GeneralizedHoughGuil.setScaleThresh( $scaleThresh ) -> None

int cv::GeneralizedHoughGuil::getScaleThresh()

AutoIt:
    cv.GeneralizedHoughGuil.getScaleThresh() -> retval

void cv::GeneralizedHoughGuil::setPosThresh( int posThresh )

AutoIt:
    cv.GeneralizedHoughGuil.setPosThresh( $posThresh ) -> None

int cv::GeneralizedHoughGuil::getPosThresh()

AutoIt:
    cv.GeneralizedHoughGuil.getPosThresh() -> retval

void cv::GeneralizedHoughGuil::setTemplate( _InputArray templ
                                            cv::Point   templCenter = Point(-1, -1) )

AutoIt:
    cv.GeneralizedHoughGuil.setTemplate( $templ[, $templCenter] ) -> None

void cv::GeneralizedHoughGuil::setTemplate( _InputArray edges
                                            _InputArray dx
                                            _InputArray dy
                                            cv::Point   templCenter = Point(-1, -1) )

AutoIt:
    cv.GeneralizedHoughGuil.setTemplate( $edges, $dx, $dy[, $templCenter] ) -> None

void cv::GeneralizedHoughGuil::detect( _InputArray  image
                                       _OutputArray positions
                                       _OutputArray votes = noArray() )

AutoIt:
    cv.GeneralizedHoughGuil.detect( $image[, $positions[, $votes]] ) -> positions, votes

void cv::GeneralizedHoughGuil::detect( _InputArray  edges
                                       _InputArray  dx
                                       _InputArray  dy
                                       _OutputArray positions
                                       _OutputArray votes = noArray() )

AutoIt:
    cv.GeneralizedHoughGuil.detect( $edges, $dx, $dy[, $positions[, $votes]] ) -> positions, votes

void cv::GeneralizedHoughGuil::setCannyLowThresh( int cannyLowThresh )

AutoIt:
    cv.GeneralizedHoughGuil.setCannyLowThresh( $cannyLowThresh ) -> None

int cv::GeneralizedHoughGuil::getCannyLowThresh()

AutoIt:
    cv.GeneralizedHoughGuil.getCannyLowThresh() -> retval

void cv::GeneralizedHoughGuil::setCannyHighThresh( int cannyHighThresh )

AutoIt:
    cv.GeneralizedHoughGuil.setCannyHighThresh( $cannyHighThresh ) -> None

int cv::GeneralizedHoughGuil::getCannyHighThresh()

AutoIt:
    cv.GeneralizedHoughGuil.getCannyHighThresh() -> retval

void cv::GeneralizedHoughGuil::setMinDist( double minDist )

AutoIt:
    cv.GeneralizedHoughGuil.setMinDist( $minDist ) -> None

double cv::GeneralizedHoughGuil::getMinDist()

AutoIt:
    cv.GeneralizedHoughGuil.getMinDist() -> retval

void cv::GeneralizedHoughGuil::setDp( double dp )

AutoIt:
    cv.GeneralizedHoughGuil.setDp( $dp ) -> None

double cv::GeneralizedHoughGuil::getDp()

AutoIt:
    cv.GeneralizedHoughGuil.getDp() -> retval

void cv::GeneralizedHoughGuil::setMaxBufferSize( int maxBufferSize )

AutoIt:
    cv.GeneralizedHoughGuil.setMaxBufferSize( $maxBufferSize ) -> None

int cv::GeneralizedHoughGuil::getMaxBufferSize()

AutoIt:
    cv.GeneralizedHoughGuil.getMaxBufferSize() -> retval

void cv::GeneralizedHoughGuil::clear()

AutoIt:
    cv.GeneralizedHoughGuil.clear() -> None

void cv::GeneralizedHoughGuil::write( const cv::Ptr<cv::FileStorage>& fs
                                      const std::string&              name = String() )

AutoIt:
    cv.GeneralizedHoughGuil.write( $fs[, $name] ) -> None

void cv::GeneralizedHoughGuil::read( const cv::FileNode& fn )

AutoIt:
    cv.GeneralizedHoughGuil.read( $fn ) -> None

bool cv::GeneralizedHoughGuil::empty()

AutoIt:
    cv.GeneralizedHoughGuil.empty() -> retval

void cv::GeneralizedHoughGuil::save( const std::string& filename )

AutoIt:
    cv.GeneralizedHoughGuil.save( $filename ) -> None

std::string cv::GeneralizedHoughGuil::getDefaultName()

AutoIt:
    cv.GeneralizedHoughGuil.getDefaultName() -> retval

void cv::CLAHE::apply( _InputArray  src
                       _OutputArray dst )

AutoIt:
    cv.CLAHE.apply( $src[, $dst] ) -> dst

void cv::CLAHE::setClipLimit( double clipLimit )

AutoIt:
    cv.CLAHE.setClipLimit( $clipLimit ) -> None

double cv::CLAHE::getClipLimit()

AutoIt:
    cv.CLAHE.getClipLimit() -> retval

void cv::CLAHE::setTilesGridSize( cv::Size tileGridSize )

AutoIt:
    cv.CLAHE.setTilesGridSize( $tileGridSize ) -> None

cv::Size cv::CLAHE::getTilesGridSize()

AutoIt:
    cv.CLAHE.getTilesGridSize() -> retval

void cv::CLAHE::collectGarbage()

AutoIt:
    cv.CLAHE.collectGarbage() -> None

void cv::CLAHE::clear()

AutoIt:
    cv.CLAHE.clear() -> None

void cv::CLAHE::write( const cv::Ptr<cv::FileStorage>& fs
                       const std::string&              name = String() )

AutoIt:
    cv.CLAHE.write( $fs[, $name] ) -> None

void cv::CLAHE::read( const cv::FileNode& fn )

AutoIt:
    cv.CLAHE.read( $fn ) -> None

bool cv::CLAHE::empty()

AutoIt:
    cv.CLAHE.empty() -> retval

void cv::CLAHE::save( const std::string& filename )

AutoIt:
    cv.CLAHE.save( $filename ) -> None

std::string cv::CLAHE::getDefaultName()

AutoIt:
    cv.CLAHE.getDefaultName() -> retval

static cv::Subdiv2D cv::Subdiv2D::create()

AutoIt:
    cv.Subdiv2D.create() -> <cv.Subdiv2D object>

static cv::Subdiv2D cv::Subdiv2D::create( cv::Rect rect )

AutoIt:
    cv.Subdiv2D.create( $rect ) -> <cv.Subdiv2D object>

void cv::Subdiv2D::initDelaunay( cv::Rect rect )

AutoIt:
    cv.Subdiv2D.initDelaunay( $rect ) -> None

int cv::Subdiv2D::insert( cv::Point2f pt )

AutoIt:
    cv.Subdiv2D.insert( $pt ) -> retval

void cv::Subdiv2D::insert( const std::vector<cv::Point2f>& ptvec )

AutoIt:
    cv.Subdiv2D.insert( $ptvec ) -> None

int cv::Subdiv2D::locate( cv::Point2f pt
                          int&        edge
                          int&        vertex )

AutoIt:
    cv.Subdiv2D.locate( $pt[, $edge[, $vertex]] ) -> retval, edge, vertex

int cv::Subdiv2D::findNearest( cv::Point2f  pt
                               cv::Point2f* nearestPt = 0 )

AutoIt:
    cv.Subdiv2D.findNearest( $pt[, $nearestPt] ) -> retval, nearestPt

void cv::Subdiv2D::getEdgeList( std::vector<cv::Vec4f>& edgeList )

AutoIt:
    cv.Subdiv2D.getEdgeList( [$edgeList] ) -> edgeList

void cv::Subdiv2D::getLeadingEdgeList( std::vector<int>& leadingEdgeList )

AutoIt:
    cv.Subdiv2D.getLeadingEdgeList( [$leadingEdgeList] ) -> leadingEdgeList

void cv::Subdiv2D::getTriangleList( std::vector<cv::Vec6f>& triangleList )

AutoIt:
    cv.Subdiv2D.getTriangleList( [$triangleList] ) -> triangleList

void cv::Subdiv2D::getVoronoiFacetList( const std::vector<int>&                idx
                                        std::vector<std::vector<cv::Point2f>>& facetList
                                        std::vector<cv::Point2f>&              facetCenters )

AutoIt:
    cv.Subdiv2D.getVoronoiFacetList( $idx[, $facetList[, $facetCenters]] ) -> facetList, facetCenters

cv::Point2f cv::Subdiv2D::getVertex( int  vertex
                                     int* firstEdge = 0 )

AutoIt:
    cv.Subdiv2D.getVertex( $vertex[, $firstEdge] ) -> retval, firstEdge

int cv::Subdiv2D::getEdge( int edge
                           int nextEdgeType )

AutoIt:
    cv.Subdiv2D.getEdge( $edge, $nextEdgeType ) -> retval

int cv::Subdiv2D::nextEdge( int edge )

AutoIt:
    cv.Subdiv2D.nextEdge( $edge ) -> retval

int cv::Subdiv2D::rotateEdge( int edge
                              int rotate )

AutoIt:
    cv.Subdiv2D.rotateEdge( $edge, $rotate ) -> retval

int cv::Subdiv2D::symEdge( int edge )

AutoIt:
    cv.Subdiv2D.symEdge( $edge ) -> retval

int cv::Subdiv2D::edgeOrg( int          edge
                           cv::Point2f* orgpt = 0 )

AutoIt:
    cv.Subdiv2D.edgeOrg( $edge[, $orgpt] ) -> retval, orgpt

int cv::Subdiv2D::edgeDst( int          edge
                           cv::Point2f* dstpt = 0 )

AutoIt:
    cv.Subdiv2D.edgeDst( $edge[, $dstpt] ) -> retval, dstpt

void cv::LineSegmentDetector::detect( _InputArray  image
                                      _OutputArray lines
                                      _OutputArray width = noArray()
                                      _OutputArray prec = noArray()
                                      _OutputArray nfa = noArray() )

AutoIt:
    cv.LineSegmentDetector.detect( $image[, $lines[, $width[, $prec[, $nfa]]]] ) -> lines, width, prec, nfa

void cv::LineSegmentDetector::drawSegments( _InputOutputArray image
                                            _InputArray       lines )

AutoIt:
    cv.LineSegmentDetector.drawSegments( $image, $lines ) -> image

int cv::LineSegmentDetector::compareSegments( const cv::Size&   size
                                              _InputArray       lines1
                                              _InputArray       lines2
                                              _InputOutputArray image = noArray() )

AutoIt:
    cv.LineSegmentDetector.compareSegments( $size, $lines1, $lines2[, $image] ) -> retval, image

void cv::LineSegmentDetector::clear()

AutoIt:
    cv.LineSegmentDetector.clear() -> None

void cv::LineSegmentDetector::write( const cv::Ptr<cv::FileStorage>& fs
                                     const std::string&              name = String() )

AutoIt:
    cv.LineSegmentDetector.write( $fs[, $name] ) -> None

void cv::LineSegmentDetector::read( const cv::FileNode& fn )

AutoIt:
    cv.LineSegmentDetector.read( $fn ) -> None

bool cv::LineSegmentDetector::empty()

AutoIt:
    cv.LineSegmentDetector.empty() -> retval

void cv::LineSegmentDetector::save( const std::string& filename )

AutoIt:
    cv.LineSegmentDetector.save( $filename ) -> None

std::string cv::LineSegmentDetector::getDefaultName()

AutoIt:
    cv.LineSegmentDetector.getDefaultName() -> retval

static cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::create()

AutoIt:
    cv.segmentation.IntelligentScissorsMB.create() -> <cv.segmentation.IntelligentScissorsMB object>

cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::setWeights( float weight_non_edge
                                                                                             float weight_gradient_direction
                                                                                             float weight_gradient_magnitude )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.setWeights( $weight_non_edge, $weight_gradient_direction, $weight_gradient_magnitude ) -> retval

cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::setGradientMagnitudeMaxLimit( float gradient_magnitude_threshold_max = 0.0f )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.setGradientMagnitudeMaxLimit( [$gradient_magnitude_threshold_max] ) -> retval

cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::setEdgeFeatureZeroCrossingParameters( float gradient_magnitude_min_value = 0.0f )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.setEdgeFeatureZeroCrossingParameters( [$gradient_magnitude_min_value] ) -> retval

cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::setEdgeFeatureCannyParameters( double threshold1
                                                                                                                double threshold2
                                                                                                                int    apertureSize = 3
                                                                                                                bool   L2gradient = false )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters( $threshold1, $threshold2[, $apertureSize[, $L2gradient]] ) -> retval

cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::applyImage( _InputArray image )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.applyImage( $image ) -> retval

cv::segmentation::IntelligentScissorsMB cv::segmentation::IntelligentScissorsMB::applyImageFeatures( _InputArray non_edge
                                                                                                     _InputArray gradient_direction
                                                                                                     _InputArray gradient_magnitude
                                                                                                     _InputArray image = noArray() )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.applyImageFeatures( $non_edge, $gradient_direction, $gradient_magnitude[, $image] ) -> retval

void cv::segmentation::IntelligentScissorsMB::buildMap( const cv::Point& sourcePt )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.buildMap( $sourcePt ) -> None

void cv::segmentation::IntelligentScissorsMB::getContour( const cv::Point& targetPt
                                                          _OutputArray     contour
                                                          bool             backward = false )

AutoIt:
    cv.segmentation.IntelligentScissorsMB.getContour( $targetPt[, $contour[, $backward]] ) -> contour

static cv::Ptr<cv::ml::ParamGrid> cv::ml::ParamGrid::create( double minVal = 0.
                                                             double maxVal = 0.
                                                             double logstep = 1. )

AutoIt:
    cv.ml.ParamGrid.create( [$minVal[, $maxVal[, $logstep]]] ) -> retval

int cv::ml::TrainData::getLayout()

AutoIt:
    cv.ml.TrainData.getLayout() -> retval

int cv::ml::TrainData::getNTrainSamples()

AutoIt:
    cv.ml.TrainData.getNTrainSamples() -> retval

int cv::ml::TrainData::getNTestSamples()

AutoIt:
    cv.ml.TrainData.getNTestSamples() -> retval

int cv::ml::TrainData::getNSamples()

AutoIt:
    cv.ml.TrainData.getNSamples() -> retval

int cv::ml::TrainData::getNVars()

AutoIt:
    cv.ml.TrainData.getNVars() -> retval

int cv::ml::TrainData::getNAllVars()

AutoIt:
    cv.ml.TrainData.getNAllVars() -> retval

void cv::ml::TrainData::getSample( _InputArray varIdx
                                   int         sidx
                                   float*      buf )

AutoIt:
    cv.ml.TrainData.getSample( $varIdx, $sidx[, $buf] ) -> buf

cv::Mat cv::ml::TrainData::getSamples()

AutoIt:
    cv.ml.TrainData.getSamples() -> retval

cv::Mat cv::ml::TrainData::getMissing()

AutoIt:
    cv.ml.TrainData.getMissing() -> retval

cv::Mat cv::ml::TrainData::getTrainSamples( int  layout = ROW_SAMPLE
                                            bool compressSamples = true
                                            bool compressVars = true )

AutoIt:
    cv.ml.TrainData.getTrainSamples( [$layout[, $compressSamples[, $compressVars]]] ) -> retval

cv::Mat cv::ml::TrainData::getTrainResponses()

AutoIt:
    cv.ml.TrainData.getTrainResponses() -> retval

cv::Mat cv::ml::TrainData::getTrainNormCatResponses()

AutoIt:
    cv.ml.TrainData.getTrainNormCatResponses() -> retval

cv::Mat cv::ml::TrainData::getTestResponses()

AutoIt:
    cv.ml.TrainData.getTestResponses() -> retval

cv::Mat cv::ml::TrainData::getTestNormCatResponses()

AutoIt:
    cv.ml.TrainData.getTestNormCatResponses() -> retval

cv::Mat cv::ml::TrainData::getResponses()

AutoIt:
    cv.ml.TrainData.getResponses() -> retval

cv::Mat cv::ml::TrainData::getNormCatResponses()

AutoIt:
    cv.ml.TrainData.getNormCatResponses() -> retval

cv::Mat cv::ml::TrainData::getSampleWeights()

AutoIt:
    cv.ml.TrainData.getSampleWeights() -> retval

cv::Mat cv::ml::TrainData::getTrainSampleWeights()

AutoIt:
    cv.ml.TrainData.getTrainSampleWeights() -> retval

cv::Mat cv::ml::TrainData::getTestSampleWeights()

AutoIt:
    cv.ml.TrainData.getTestSampleWeights() -> retval

cv::Mat cv::ml::TrainData::getVarIdx()

AutoIt:
    cv.ml.TrainData.getVarIdx() -> retval

cv::Mat cv::ml::TrainData::getVarType()

AutoIt:
    cv.ml.TrainData.getVarType() -> retval

cv::Mat cv::ml::TrainData::getVarSymbolFlags()

AutoIt:
    cv.ml.TrainData.getVarSymbolFlags() -> retval

int cv::ml::TrainData::getResponseType()

AutoIt:
    cv.ml.TrainData.getResponseType() -> retval

cv::Mat cv::ml::TrainData::getTrainSampleIdx()

AutoIt:
    cv.ml.TrainData.getTrainSampleIdx() -> retval

cv::Mat cv::ml::TrainData::getTestSampleIdx()

AutoIt:
    cv.ml.TrainData.getTestSampleIdx() -> retval

void cv::ml::TrainData::getValues( int         vi
                                   _InputArray sidx
                                   float*      values )

AutoIt:
    cv.ml.TrainData.getValues( $vi, $sidx[, $values] ) -> values

cv::Mat cv::ml::TrainData::getDefaultSubstValues()

AutoIt:
    cv.ml.TrainData.getDefaultSubstValues() -> retval

int cv::ml::TrainData::getCatCount( int vi )

AutoIt:
    cv.ml.TrainData.getCatCount( $vi ) -> retval

cv::Mat cv::ml::TrainData::getClassLabels()

AutoIt:
    cv.ml.TrainData.getClassLabels() -> retval

cv::Mat cv::ml::TrainData::getCatOfs()

AutoIt:
    cv.ml.TrainData.getCatOfs() -> retval

cv::Mat cv::ml::TrainData::getCatMap()

AutoIt:
    cv.ml.TrainData.getCatMap() -> retval

void cv::ml::TrainData::setTrainTestSplit( int  count
                                           bool shuffle = true )

AutoIt:
    cv.ml.TrainData.setTrainTestSplit( $count[, $shuffle] ) -> None

void cv::ml::TrainData::setTrainTestSplitRatio( double ratio
                                                bool   shuffle = true )

AutoIt:
    cv.ml.TrainData.setTrainTestSplitRatio( $ratio[, $shuffle] ) -> None

void cv::ml::TrainData::shuffleTrainTest()

AutoIt:
    cv.ml.TrainData.shuffleTrainTest() -> None

cv::Mat cv::ml::TrainData::getTestSamples()

AutoIt:
    cv.ml.TrainData.getTestSamples() -> retval

void cv::ml::TrainData::getNames( std::vector<std::string>& names )

AutoIt:
    cv.ml.TrainData.getNames( $names ) -> None

static cv::Mat cv::ml::TrainData::getSubVector( const cv::Mat& vec
                                                const cv::Mat& idx )

AutoIt:
    cv.ml.TrainData.getSubVector( $vec, $idx ) -> retval

static cv::Mat cv::ml::TrainData::getSubMatrix( const cv::Mat& matrix
                                                const cv::Mat& idx
                                                int            layout )

AutoIt:
    cv.ml.TrainData.getSubMatrix( $matrix, $idx, $layout ) -> retval

static cv::Ptr<cv::ml::TrainData> cv::ml::TrainData::create( _InputArray samples
                                                             int         layout
                                                             _InputArray responses
                                                             _InputArray varIdx = noArray()
                                                             _InputArray sampleIdx = noArray()
                                                             _InputArray sampleWeights = noArray()
                                                             _InputArray varType = noArray() )

AutoIt:
    cv.ml.TrainData.create( $samples, $layout, $responses[, $varIdx[, $sampleIdx[, $sampleWeights[, $varType]]]] ) -> retval

int cv::ml::StatModel::getVarCount()

AutoIt:
    cv.ml.StatModel.getVarCount() -> retval

bool cv::ml::StatModel::empty()

AutoIt:
    cv.ml.StatModel.empty() -> retval

bool cv::ml::StatModel::isTrained()

AutoIt:
    cv.ml.StatModel.isTrained() -> retval

bool cv::ml::StatModel::isClassifier()

AutoIt:
    cv.ml.StatModel.isClassifier() -> retval

bool cv::ml::StatModel::train( const cv::Ptr<cv::ml::TrainData>& trainData
                               int                               flags = 0 )

AutoIt:
    cv.ml.StatModel.train( $trainData[, $flags] ) -> retval

bool cv::ml::StatModel::train( _InputArray samples
                               int         layout
                               _InputArray responses )

AutoIt:
    cv.ml.StatModel.train( $samples, $layout, $responses ) -> retval

float cv::ml::StatModel::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                    bool                              test
                                    _OutputArray                      resp )

AutoIt:
    cv.ml.StatModel.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::StatModel::predict( _InputArray  samples
                                  _OutputArray results = noArray()
                                  int          flags = 0 )

AutoIt:
    cv.ml.StatModel.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::StatModel::clear()

AutoIt:
    cv.ml.StatModel.clear() -> None

void cv::ml::StatModel::write( const cv::Ptr<cv::FileStorage>& fs
                               const std::string&              name = String() )

AutoIt:
    cv.ml.StatModel.write( $fs[, $name] ) -> None

void cv::ml::StatModel::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.StatModel.read( $fn ) -> None

void cv::ml::StatModel::save( const std::string& filename )

AutoIt:
    cv.ml.StatModel.save( $filename ) -> None

std::string cv::ml::StatModel::getDefaultName()

AutoIt:
    cv.ml.StatModel.getDefaultName() -> retval

float cv::ml::NormalBayesClassifier::predictProb( _InputArray  inputs
                                                  _OutputArray outputs
                                                  _OutputArray outputProbs
                                                  int          flags = 0 )

AutoIt:
    cv.ml.NormalBayesClassifier.predictProb( $inputs[, $outputs[, $outputProbs[, $flags]]] ) -> retval, outputs, outputProbs

static cv::Ptr<cv::ml::NormalBayesClassifier> cv::ml::NormalBayesClassifier::create()

AutoIt:
    cv.ml.NormalBayesClassifier.create() -> retval

static cv::Ptr<cv::ml::NormalBayesClassifier> cv::ml::NormalBayesClassifier::load( const std::string& filepath
                                                                                   const std::string& nodeName = String() )

AutoIt:
    cv.ml.NormalBayesClassifier.load( $filepath[, $nodeName] ) -> retval

int cv::ml::NormalBayesClassifier::getVarCount()

AutoIt:
    cv.ml.NormalBayesClassifier.getVarCount() -> retval

bool cv::ml::NormalBayesClassifier::empty()

AutoIt:
    cv.ml.NormalBayesClassifier.empty() -> retval

bool cv::ml::NormalBayesClassifier::isTrained()

AutoIt:
    cv.ml.NormalBayesClassifier.isTrained() -> retval

bool cv::ml::NormalBayesClassifier::isClassifier()

AutoIt:
    cv.ml.NormalBayesClassifier.isClassifier() -> retval

bool cv::ml::NormalBayesClassifier::train( const cv::Ptr<cv::ml::TrainData>& trainData
                                           int                               flags = 0 )

AutoIt:
    cv.ml.NormalBayesClassifier.train( $trainData[, $flags] ) -> retval

bool cv::ml::NormalBayesClassifier::train( _InputArray samples
                                           int         layout
                                           _InputArray responses )

AutoIt:
    cv.ml.NormalBayesClassifier.train( $samples, $layout, $responses ) -> retval

float cv::ml::NormalBayesClassifier::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                                bool                              test
                                                _OutputArray                      resp )

AutoIt:
    cv.ml.NormalBayesClassifier.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::NormalBayesClassifier::predict( _InputArray  samples
                                              _OutputArray results = noArray()
                                              int          flags = 0 )

AutoIt:
    cv.ml.NormalBayesClassifier.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::NormalBayesClassifier::clear()

AutoIt:
    cv.ml.NormalBayesClassifier.clear() -> None

void cv::ml::NormalBayesClassifier::write( const cv::Ptr<cv::FileStorage>& fs
                                           const std::string&              name = String() )

AutoIt:
    cv.ml.NormalBayesClassifier.write( $fs[, $name] ) -> None

void cv::ml::NormalBayesClassifier::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.NormalBayesClassifier.read( $fn ) -> None

void cv::ml::NormalBayesClassifier::save( const std::string& filename )

AutoIt:
    cv.ml.NormalBayesClassifier.save( $filename ) -> None

std::string cv::ml::NormalBayesClassifier::getDefaultName()

AutoIt:
    cv.ml.NormalBayesClassifier.getDefaultName() -> retval

int cv::ml::KNearest::getDefaultK()

AutoIt:
    cv.ml.KNearest.getDefaultK() -> retval

void cv::ml::KNearest::setDefaultK( int val )

AutoIt:
    cv.ml.KNearest.setDefaultK( $val ) -> None

bool cv::ml::KNearest::getIsClassifier()

AutoIt:
    cv.ml.KNearest.getIsClassifier() -> retval

void cv::ml::KNearest::setIsClassifier( bool val )

AutoIt:
    cv.ml.KNearest.setIsClassifier( $val ) -> None

int cv::ml::KNearest::getEmax()

AutoIt:
    cv.ml.KNearest.getEmax() -> retval

void cv::ml::KNearest::setEmax( int val )

AutoIt:
    cv.ml.KNearest.setEmax( $val ) -> None

int cv::ml::KNearest::getAlgorithmType()

AutoIt:
    cv.ml.KNearest.getAlgorithmType() -> retval

void cv::ml::KNearest::setAlgorithmType( int val )

AutoIt:
    cv.ml.KNearest.setAlgorithmType( $val ) -> None

float cv::ml::KNearest::findNearest( _InputArray  samples
                                     int          k
                                     _OutputArray results
                                     _OutputArray neighborResponses = noArray()
                                     _OutputArray dist = noArray() )

AutoIt:
    cv.ml.KNearest.findNearest( $samples, $k[, $results[, $neighborResponses[, $dist]]] ) -> retval, results, neighborResponses, dist

static cv::Ptr<cv::ml::KNearest> cv::ml::KNearest::create()

AutoIt:
    cv.ml.KNearest.create() -> retval

static cv::Ptr<cv::ml::KNearest> cv::ml::KNearest::load( const std::string& filepath )

AutoIt:
    cv.ml.KNearest.load( $filepath ) -> retval

int cv::ml::KNearest::getVarCount()

AutoIt:
    cv.ml.KNearest.getVarCount() -> retval

bool cv::ml::KNearest::empty()

AutoIt:
    cv.ml.KNearest.empty() -> retval

bool cv::ml::KNearest::isTrained()

AutoIt:
    cv.ml.KNearest.isTrained() -> retval

bool cv::ml::KNearest::isClassifier()

AutoIt:
    cv.ml.KNearest.isClassifier() -> retval

bool cv::ml::KNearest::train( const cv::Ptr<cv::ml::TrainData>& trainData
                              int                               flags = 0 )

AutoIt:
    cv.ml.KNearest.train( $trainData[, $flags] ) -> retval

bool cv::ml::KNearest::train( _InputArray samples
                              int         layout
                              _InputArray responses )

AutoIt:
    cv.ml.KNearest.train( $samples, $layout, $responses ) -> retval

float cv::ml::KNearest::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                   bool                              test
                                   _OutputArray                      resp )

AutoIt:
    cv.ml.KNearest.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::KNearest::predict( _InputArray  samples
                                 _OutputArray results = noArray()
                                 int          flags = 0 )

AutoIt:
    cv.ml.KNearest.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::KNearest::clear()

AutoIt:
    cv.ml.KNearest.clear() -> None

void cv::ml::KNearest::write( const cv::Ptr<cv::FileStorage>& fs
                              const std::string&              name = String() )

AutoIt:
    cv.ml.KNearest.write( $fs[, $name] ) -> None

void cv::ml::KNearest::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.KNearest.read( $fn ) -> None

void cv::ml::KNearest::save( const std::string& filename )

AutoIt:
    cv.ml.KNearest.save( $filename ) -> None

std::string cv::ml::KNearest::getDefaultName()

AutoIt:
    cv.ml.KNearest.getDefaultName() -> retval

int cv::ml::SVM::getType()

AutoIt:
    cv.ml.SVM.getType() -> retval

void cv::ml::SVM::setType( int val )

AutoIt:
    cv.ml.SVM.setType( $val ) -> None

double cv::ml::SVM::getGamma()

AutoIt:
    cv.ml.SVM.getGamma() -> retval

void cv::ml::SVM::setGamma( double val )

AutoIt:
    cv.ml.SVM.setGamma( $val ) -> None

double cv::ml::SVM::getCoef0()

AutoIt:
    cv.ml.SVM.getCoef0() -> retval

void cv::ml::SVM::setCoef0( double val )

AutoIt:
    cv.ml.SVM.setCoef0( $val ) -> None

double cv::ml::SVM::getDegree()

AutoIt:
    cv.ml.SVM.getDegree() -> retval

void cv::ml::SVM::setDegree( double val )

AutoIt:
    cv.ml.SVM.setDegree( $val ) -> None

double cv::ml::SVM::getC()

AutoIt:
    cv.ml.SVM.getC() -> retval

void cv::ml::SVM::setC( double val )

AutoIt:
    cv.ml.SVM.setC( $val ) -> None

double cv::ml::SVM::getNu()

AutoIt:
    cv.ml.SVM.getNu() -> retval

void cv::ml::SVM::setNu( double val )

AutoIt:
    cv.ml.SVM.setNu( $val ) -> None

double cv::ml::SVM::getP()

AutoIt:
    cv.ml.SVM.getP() -> retval

void cv::ml::SVM::setP( double val )

AutoIt:
    cv.ml.SVM.setP( $val ) -> None

cv::Mat cv::ml::SVM::getClassWeights()

AutoIt:
    cv.ml.SVM.getClassWeights() -> retval

void cv::ml::SVM::setClassWeights( const cv::Mat& val )

AutoIt:
    cv.ml.SVM.setClassWeights( $val ) -> None

cv::TermCriteria cv::ml::SVM::getTermCriteria()

AutoIt:
    cv.ml.SVM.getTermCriteria() -> retval

void cv::ml::SVM::setTermCriteria( const cv::TermCriteria& val )

AutoIt:
    cv.ml.SVM.setTermCriteria( $val ) -> None

int cv::ml::SVM::getKernelType()

AutoIt:
    cv.ml.SVM.getKernelType() -> retval

void cv::ml::SVM::setKernel( int kernelType )

AutoIt:
    cv.ml.SVM.setKernel( $kernelType ) -> None

bool cv::ml::SVM::trainAuto( _InputArray                samples
                             int                        layout
                             _InputArray                responses
                             int                        kFold = 10
                             cv::Ptr<cv::ml::ParamGrid> Cgrid = SVM::getDefaultGridPtr(SVM::C)
                             cv::Ptr<cv::ml::ParamGrid> gammaGrid = SVM::getDefaultGridPtr(SVM::GAMMA)
                             cv::Ptr<cv::ml::ParamGrid> pGrid = SVM::getDefaultGridPtr(SVM::P)
                             cv::Ptr<cv::ml::ParamGrid> nuGrid = SVM::getDefaultGridPtr(SVM::NU)
                             cv::Ptr<cv::ml::ParamGrid> coeffGrid = SVM::getDefaultGridPtr(SVM::COEF)
                             cv::Ptr<cv::ml::ParamGrid> degreeGrid = SVM::getDefaultGridPtr(SVM::DEGREE)
                             bool                       balanced = false )

AutoIt:
    cv.ml.SVM.trainAuto( $samples, $layout, $responses[, $kFold[, $Cgrid[, $gammaGrid[, $pGrid[, $nuGrid[, $coeffGrid[, $degreeGrid[, $balanced]]]]]]]] ) -> retval

cv::Mat cv::ml::SVM::getSupportVectors()

AutoIt:
    cv.ml.SVM.getSupportVectors() -> retval

cv::Mat cv::ml::SVM::getUncompressedSupportVectors()

AutoIt:
    cv.ml.SVM.getUncompressedSupportVectors() -> retval

double cv::ml::SVM::getDecisionFunction( int          i
                                         _OutputArray alpha
                                         _OutputArray svidx )

AutoIt:
    cv.ml.SVM.getDecisionFunction( $i[, $alpha[, $svidx]] ) -> retval, alpha, svidx

static cv::Ptr<cv::ml::ParamGrid> cv::ml::SVM::getDefaultGridPtr( int param_id )

AutoIt:
    cv.ml.SVM.getDefaultGridPtr( $param_id ) -> retval

static cv::Ptr<cv::ml::SVM> cv::ml::SVM::create()

AutoIt:
    cv.ml.SVM.create() -> retval

static cv::Ptr<cv::ml::SVM> cv::ml::SVM::load( const std::string& filepath )

AutoIt:
    cv.ml.SVM.load( $filepath ) -> retval

int cv::ml::SVM::getVarCount()

AutoIt:
    cv.ml.SVM.getVarCount() -> retval

bool cv::ml::SVM::empty()

AutoIt:
    cv.ml.SVM.empty() -> retval

bool cv::ml::SVM::isTrained()

AutoIt:
    cv.ml.SVM.isTrained() -> retval

bool cv::ml::SVM::isClassifier()

AutoIt:
    cv.ml.SVM.isClassifier() -> retval

bool cv::ml::SVM::train( const cv::Ptr<cv::ml::TrainData>& trainData
                         int                               flags = 0 )

AutoIt:
    cv.ml.SVM.train( $trainData[, $flags] ) -> retval

bool cv::ml::SVM::train( _InputArray samples
                         int         layout
                         _InputArray responses )

AutoIt:
    cv.ml.SVM.train( $samples, $layout, $responses ) -> retval

float cv::ml::SVM::calcError( const cv::Ptr<cv::ml::TrainData>& data
                              bool                              test
                              _OutputArray                      resp )

AutoIt:
    cv.ml.SVM.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::SVM::predict( _InputArray  samples
                            _OutputArray results = noArray()
                            int          flags = 0 )

AutoIt:
    cv.ml.SVM.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::SVM::clear()

AutoIt:
    cv.ml.SVM.clear() -> None

void cv::ml::SVM::write( const cv::Ptr<cv::FileStorage>& fs
                         const std::string&              name = String() )

AutoIt:
    cv.ml.SVM.write( $fs[, $name] ) -> None

void cv::ml::SVM::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.SVM.read( $fn ) -> None

void cv::ml::SVM::save( const std::string& filename )

AutoIt:
    cv.ml.SVM.save( $filename ) -> None

std::string cv::ml::SVM::getDefaultName()

AutoIt:
    cv.ml.SVM.getDefaultName() -> retval

int cv::ml::EM::getClustersNumber()

AutoIt:
    cv.ml.EM.getClustersNumber() -> retval

void cv::ml::EM::setClustersNumber( int val )

AutoIt:
    cv.ml.EM.setClustersNumber( $val ) -> None

int cv::ml::EM::getCovarianceMatrixType()

AutoIt:
    cv.ml.EM.getCovarianceMatrixType() -> retval

void cv::ml::EM::setCovarianceMatrixType( int val )

AutoIt:
    cv.ml.EM.setCovarianceMatrixType( $val ) -> None

cv::TermCriteria cv::ml::EM::getTermCriteria()

AutoIt:
    cv.ml.EM.getTermCriteria() -> retval

void cv::ml::EM::setTermCriteria( const cv::TermCriteria& val )

AutoIt:
    cv.ml.EM.setTermCriteria( $val ) -> None

cv::Mat cv::ml::EM::getWeights()

AutoIt:
    cv.ml.EM.getWeights() -> retval

cv::Mat cv::ml::EM::getMeans()

AutoIt:
    cv.ml.EM.getMeans() -> retval

void cv::ml::EM::getCovs( std::vector<cv::Mat>& covs )

AutoIt:
    cv.ml.EM.getCovs( [$covs] ) -> covs

float cv::ml::EM::predict( _InputArray  samples
                           _OutputArray results = noArray()
                           int          flags = 0 )

AutoIt:
    cv.ml.EM.predict( $samples[, $results[, $flags]] ) -> retval, results

cv::Vec2d cv::ml::EM::predict2( _InputArray  sample
                                _OutputArray probs )

AutoIt:
    cv.ml.EM.predict2( $sample[, $probs] ) -> retval, probs

bool cv::ml::EM::trainEM( _InputArray  samples
                          _OutputArray logLikelihoods = noArray()
                          _OutputArray labels = noArray()
                          _OutputArray probs = noArray() )

AutoIt:
    cv.ml.EM.trainEM( $samples[, $logLikelihoods[, $labels[, $probs]]] ) -> retval, logLikelihoods, labels, probs

bool cv::ml::EM::trainE( _InputArray  samples
                         _InputArray  means0
                         _InputArray  covs0 = noArray()
                         _InputArray  weights0 = noArray()
                         _OutputArray logLikelihoods = noArray()
                         _OutputArray labels = noArray()
                         _OutputArray probs = noArray() )

AutoIt:
    cv.ml.EM.trainE( $samples, $means0[, $covs0[, $weights0[, $logLikelihoods[, $labels[, $probs]]]]] ) -> retval, logLikelihoods, labels, probs

bool cv::ml::EM::trainM( _InputArray  samples
                         _InputArray  probs0
                         _OutputArray logLikelihoods = noArray()
                         _OutputArray labels = noArray()
                         _OutputArray probs = noArray() )

AutoIt:
    cv.ml.EM.trainM( $samples, $probs0[, $logLikelihoods[, $labels[, $probs]]] ) -> retval, logLikelihoods, labels, probs

static cv::Ptr<cv::ml::EM> cv::ml::EM::create()

AutoIt:
    cv.ml.EM.create() -> retval

static cv::Ptr<cv::ml::EM> cv::ml::EM::load( const std::string& filepath
                                             const std::string& nodeName = String() )

AutoIt:
    cv.ml.EM.load( $filepath[, $nodeName] ) -> retval

int cv::ml::EM::getVarCount()

AutoIt:
    cv.ml.EM.getVarCount() -> retval

bool cv::ml::EM::empty()

AutoIt:
    cv.ml.EM.empty() -> retval

bool cv::ml::EM::isTrained()

AutoIt:
    cv.ml.EM.isTrained() -> retval

bool cv::ml::EM::isClassifier()

AutoIt:
    cv.ml.EM.isClassifier() -> retval

bool cv::ml::EM::train( const cv::Ptr<cv::ml::TrainData>& trainData
                        int                               flags = 0 )

AutoIt:
    cv.ml.EM.train( $trainData[, $flags] ) -> retval

bool cv::ml::EM::train( _InputArray samples
                        int         layout
                        _InputArray responses )

AutoIt:
    cv.ml.EM.train( $samples, $layout, $responses ) -> retval

float cv::ml::EM::calcError( const cv::Ptr<cv::ml::TrainData>& data
                             bool                              test
                             _OutputArray                      resp )

AutoIt:
    cv.ml.EM.calcError( $data, $test[, $resp] ) -> retval, resp

void cv::ml::EM::clear()

AutoIt:
    cv.ml.EM.clear() -> None

void cv::ml::EM::write( const cv::Ptr<cv::FileStorage>& fs
                        const std::string&              name = String() )

AutoIt:
    cv.ml.EM.write( $fs[, $name] ) -> None

void cv::ml::EM::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.EM.read( $fn ) -> None

void cv::ml::EM::save( const std::string& filename )

AutoIt:
    cv.ml.EM.save( $filename ) -> None

std::string cv::ml::EM::getDefaultName()

AutoIt:
    cv.ml.EM.getDefaultName() -> retval

int cv::ml::DTrees::getMaxCategories()

AutoIt:
    cv.ml.DTrees.getMaxCategories() -> retval

void cv::ml::DTrees::setMaxCategories( int val )

AutoIt:
    cv.ml.DTrees.setMaxCategories( $val ) -> None

int cv::ml::DTrees::getMaxDepth()

AutoIt:
    cv.ml.DTrees.getMaxDepth() -> retval

void cv::ml::DTrees::setMaxDepth( int val )

AutoIt:
    cv.ml.DTrees.setMaxDepth( $val ) -> None

int cv::ml::DTrees::getMinSampleCount()

AutoIt:
    cv.ml.DTrees.getMinSampleCount() -> retval

void cv::ml::DTrees::setMinSampleCount( int val )

AutoIt:
    cv.ml.DTrees.setMinSampleCount( $val ) -> None

int cv::ml::DTrees::getCVFolds()

AutoIt:
    cv.ml.DTrees.getCVFolds() -> retval

void cv::ml::DTrees::setCVFolds( int val )

AutoIt:
    cv.ml.DTrees.setCVFolds( $val ) -> None

bool cv::ml::DTrees::getUseSurrogates()

AutoIt:
    cv.ml.DTrees.getUseSurrogates() -> retval

void cv::ml::DTrees::setUseSurrogates( bool val )

AutoIt:
    cv.ml.DTrees.setUseSurrogates( $val ) -> None

bool cv::ml::DTrees::getUse1SERule()

AutoIt:
    cv.ml.DTrees.getUse1SERule() -> retval

void cv::ml::DTrees::setUse1SERule( bool val )

AutoIt:
    cv.ml.DTrees.setUse1SERule( $val ) -> None

bool cv::ml::DTrees::getTruncatePrunedTree()

AutoIt:
    cv.ml.DTrees.getTruncatePrunedTree() -> retval

void cv::ml::DTrees::setTruncatePrunedTree( bool val )

AutoIt:
    cv.ml.DTrees.setTruncatePrunedTree( $val ) -> None

float cv::ml::DTrees::getRegressionAccuracy()

AutoIt:
    cv.ml.DTrees.getRegressionAccuracy() -> retval

void cv::ml::DTrees::setRegressionAccuracy( float val )

AutoIt:
    cv.ml.DTrees.setRegressionAccuracy( $val ) -> None

cv::Mat cv::ml::DTrees::getPriors()

AutoIt:
    cv.ml.DTrees.getPriors() -> retval

void cv::ml::DTrees::setPriors( const cv::Mat& val )

AutoIt:
    cv.ml.DTrees.setPriors( $val ) -> None

static cv::Ptr<cv::ml::DTrees> cv::ml::DTrees::create()

AutoIt:
    cv.ml.DTrees.create() -> retval

static cv::Ptr<cv::ml::DTrees> cv::ml::DTrees::load( const std::string& filepath
                                                     const std::string& nodeName = String() )

AutoIt:
    cv.ml.DTrees.load( $filepath[, $nodeName] ) -> retval

int cv::ml::DTrees::getVarCount()

AutoIt:
    cv.ml.DTrees.getVarCount() -> retval

bool cv::ml::DTrees::empty()

AutoIt:
    cv.ml.DTrees.empty() -> retval

bool cv::ml::DTrees::isTrained()

AutoIt:
    cv.ml.DTrees.isTrained() -> retval

bool cv::ml::DTrees::isClassifier()

AutoIt:
    cv.ml.DTrees.isClassifier() -> retval

bool cv::ml::DTrees::train( const cv::Ptr<cv::ml::TrainData>& trainData
                            int                               flags = 0 )

AutoIt:
    cv.ml.DTrees.train( $trainData[, $flags] ) -> retval

bool cv::ml::DTrees::train( _InputArray samples
                            int         layout
                            _InputArray responses )

AutoIt:
    cv.ml.DTrees.train( $samples, $layout, $responses ) -> retval

float cv::ml::DTrees::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                 bool                              test
                                 _OutputArray                      resp )

AutoIt:
    cv.ml.DTrees.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::DTrees::predict( _InputArray  samples
                               _OutputArray results = noArray()
                               int          flags = 0 )

AutoIt:
    cv.ml.DTrees.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::DTrees::clear()

AutoIt:
    cv.ml.DTrees.clear() -> None

void cv::ml::DTrees::write( const cv::Ptr<cv::FileStorage>& fs
                            const std::string&              name = String() )

AutoIt:
    cv.ml.DTrees.write( $fs[, $name] ) -> None

void cv::ml::DTrees::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.DTrees.read( $fn ) -> None

void cv::ml::DTrees::save( const std::string& filename )

AutoIt:
    cv.ml.DTrees.save( $filename ) -> None

std::string cv::ml::DTrees::getDefaultName()

AutoIt:
    cv.ml.DTrees.getDefaultName() -> retval

bool cv::ml::RTrees::getCalculateVarImportance()

AutoIt:
    cv.ml.RTrees.getCalculateVarImportance() -> retval

void cv::ml::RTrees::setCalculateVarImportance( bool val )

AutoIt:
    cv.ml.RTrees.setCalculateVarImportance( $val ) -> None

int cv::ml::RTrees::getActiveVarCount()

AutoIt:
    cv.ml.RTrees.getActiveVarCount() -> retval

void cv::ml::RTrees::setActiveVarCount( int val )

AutoIt:
    cv.ml.RTrees.setActiveVarCount( $val ) -> None

cv::TermCriteria cv::ml::RTrees::getTermCriteria()

AutoIt:
    cv.ml.RTrees.getTermCriteria() -> retval

void cv::ml::RTrees::setTermCriteria( const cv::TermCriteria& val )

AutoIt:
    cv.ml.RTrees.setTermCriteria( $val ) -> None

cv::Mat cv::ml::RTrees::getVarImportance()

AutoIt:
    cv.ml.RTrees.getVarImportance() -> retval

void cv::ml::RTrees::getVotes( _InputArray  samples
                               _OutputArray results
                               int          flags )

AutoIt:
    cv.ml.RTrees.getVotes( $samples, $flags[, $results] ) -> results

double cv::ml::RTrees::getOOBError()

AutoIt:
    cv.ml.RTrees.getOOBError() -> retval

static cv::Ptr<cv::ml::RTrees> cv::ml::RTrees::create()

AutoIt:
    cv.ml.RTrees.create() -> retval

static cv::Ptr<cv::ml::RTrees> cv::ml::RTrees::load( const std::string& filepath
                                                     const std::string& nodeName = String() )

AutoIt:
    cv.ml.RTrees.load( $filepath[, $nodeName] ) -> retval

int cv::ml::RTrees::getMaxCategories()

AutoIt:
    cv.ml.RTrees.getMaxCategories() -> retval

void cv::ml::RTrees::setMaxCategories( int val )

AutoIt:
    cv.ml.RTrees.setMaxCategories( $val ) -> None

int cv::ml::RTrees::getMaxDepth()

AutoIt:
    cv.ml.RTrees.getMaxDepth() -> retval

void cv::ml::RTrees::setMaxDepth( int val )

AutoIt:
    cv.ml.RTrees.setMaxDepth( $val ) -> None

int cv::ml::RTrees::getMinSampleCount()

AutoIt:
    cv.ml.RTrees.getMinSampleCount() -> retval

void cv::ml::RTrees::setMinSampleCount( int val )

AutoIt:
    cv.ml.RTrees.setMinSampleCount( $val ) -> None

int cv::ml::RTrees::getCVFolds()

AutoIt:
    cv.ml.RTrees.getCVFolds() -> retval

void cv::ml::RTrees::setCVFolds( int val )

AutoIt:
    cv.ml.RTrees.setCVFolds( $val ) -> None

bool cv::ml::RTrees::getUseSurrogates()

AutoIt:
    cv.ml.RTrees.getUseSurrogates() -> retval

void cv::ml::RTrees::setUseSurrogates( bool val )

AutoIt:
    cv.ml.RTrees.setUseSurrogates( $val ) -> None

bool cv::ml::RTrees::getUse1SERule()

AutoIt:
    cv.ml.RTrees.getUse1SERule() -> retval

void cv::ml::RTrees::setUse1SERule( bool val )

AutoIt:
    cv.ml.RTrees.setUse1SERule( $val ) -> None

bool cv::ml::RTrees::getTruncatePrunedTree()

AutoIt:
    cv.ml.RTrees.getTruncatePrunedTree() -> retval

void cv::ml::RTrees::setTruncatePrunedTree( bool val )

AutoIt:
    cv.ml.RTrees.setTruncatePrunedTree( $val ) -> None

float cv::ml::RTrees::getRegressionAccuracy()

AutoIt:
    cv.ml.RTrees.getRegressionAccuracy() -> retval

void cv::ml::RTrees::setRegressionAccuracy( float val )

AutoIt:
    cv.ml.RTrees.setRegressionAccuracy( $val ) -> None

cv::Mat cv::ml::RTrees::getPriors()

AutoIt:
    cv.ml.RTrees.getPriors() -> retval

void cv::ml::RTrees::setPriors( const cv::Mat& val )

AutoIt:
    cv.ml.RTrees.setPriors( $val ) -> None

int cv::ml::RTrees::getVarCount()

AutoIt:
    cv.ml.RTrees.getVarCount() -> retval

bool cv::ml::RTrees::empty()

AutoIt:
    cv.ml.RTrees.empty() -> retval

bool cv::ml::RTrees::isTrained()

AutoIt:
    cv.ml.RTrees.isTrained() -> retval

bool cv::ml::RTrees::isClassifier()

AutoIt:
    cv.ml.RTrees.isClassifier() -> retval

bool cv::ml::RTrees::train( const cv::Ptr<cv::ml::TrainData>& trainData
                            int                               flags = 0 )

AutoIt:
    cv.ml.RTrees.train( $trainData[, $flags] ) -> retval

bool cv::ml::RTrees::train( _InputArray samples
                            int         layout
                            _InputArray responses )

AutoIt:
    cv.ml.RTrees.train( $samples, $layout, $responses ) -> retval

float cv::ml::RTrees::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                 bool                              test
                                 _OutputArray                      resp )

AutoIt:
    cv.ml.RTrees.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::RTrees::predict( _InputArray  samples
                               _OutputArray results = noArray()
                               int          flags = 0 )

AutoIt:
    cv.ml.RTrees.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::RTrees::clear()

AutoIt:
    cv.ml.RTrees.clear() -> None

void cv::ml::RTrees::write( const cv::Ptr<cv::FileStorage>& fs
                            const std::string&              name = String() )

AutoIt:
    cv.ml.RTrees.write( $fs[, $name] ) -> None

void cv::ml::RTrees::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.RTrees.read( $fn ) -> None

void cv::ml::RTrees::save( const std::string& filename )

AutoIt:
    cv.ml.RTrees.save( $filename ) -> None

std::string cv::ml::RTrees::getDefaultName()

AutoIt:
    cv.ml.RTrees.getDefaultName() -> retval

int cv::ml::Boost::getBoostType()

AutoIt:
    cv.ml.Boost.getBoostType() -> retval

void cv::ml::Boost::setBoostType( int val )

AutoIt:
    cv.ml.Boost.setBoostType( $val ) -> None

int cv::ml::Boost::getWeakCount()

AutoIt:
    cv.ml.Boost.getWeakCount() -> retval

void cv::ml::Boost::setWeakCount( int val )

AutoIt:
    cv.ml.Boost.setWeakCount( $val ) -> None

double cv::ml::Boost::getWeightTrimRate()

AutoIt:
    cv.ml.Boost.getWeightTrimRate() -> retval

void cv::ml::Boost::setWeightTrimRate( double val )

AutoIt:
    cv.ml.Boost.setWeightTrimRate( $val ) -> None

static cv::Ptr<cv::ml::Boost> cv::ml::Boost::create()

AutoIt:
    cv.ml.Boost.create() -> retval

static cv::Ptr<cv::ml::Boost> cv::ml::Boost::load( const std::string& filepath
                                                   const std::string& nodeName = String() )

AutoIt:
    cv.ml.Boost.load( $filepath[, $nodeName] ) -> retval

int cv::ml::Boost::getMaxCategories()

AutoIt:
    cv.ml.Boost.getMaxCategories() -> retval

void cv::ml::Boost::setMaxCategories( int val )

AutoIt:
    cv.ml.Boost.setMaxCategories( $val ) -> None

int cv::ml::Boost::getMaxDepth()

AutoIt:
    cv.ml.Boost.getMaxDepth() -> retval

void cv::ml::Boost::setMaxDepth( int val )

AutoIt:
    cv.ml.Boost.setMaxDepth( $val ) -> None

int cv::ml::Boost::getMinSampleCount()

AutoIt:
    cv.ml.Boost.getMinSampleCount() -> retval

void cv::ml::Boost::setMinSampleCount( int val )

AutoIt:
    cv.ml.Boost.setMinSampleCount( $val ) -> None

int cv::ml::Boost::getCVFolds()

AutoIt:
    cv.ml.Boost.getCVFolds() -> retval

void cv::ml::Boost::setCVFolds( int val )

AutoIt:
    cv.ml.Boost.setCVFolds( $val ) -> None

bool cv::ml::Boost::getUseSurrogates()

AutoIt:
    cv.ml.Boost.getUseSurrogates() -> retval

void cv::ml::Boost::setUseSurrogates( bool val )

AutoIt:
    cv.ml.Boost.setUseSurrogates( $val ) -> None

bool cv::ml::Boost::getUse1SERule()

AutoIt:
    cv.ml.Boost.getUse1SERule() -> retval

void cv::ml::Boost::setUse1SERule( bool val )

AutoIt:
    cv.ml.Boost.setUse1SERule( $val ) -> None

bool cv::ml::Boost::getTruncatePrunedTree()

AutoIt:
    cv.ml.Boost.getTruncatePrunedTree() -> retval

void cv::ml::Boost::setTruncatePrunedTree( bool val )

AutoIt:
    cv.ml.Boost.setTruncatePrunedTree( $val ) -> None

float cv::ml::Boost::getRegressionAccuracy()

AutoIt:
    cv.ml.Boost.getRegressionAccuracy() -> retval

void cv::ml::Boost::setRegressionAccuracy( float val )

AutoIt:
    cv.ml.Boost.setRegressionAccuracy( $val ) -> None

cv::Mat cv::ml::Boost::getPriors()

AutoIt:
    cv.ml.Boost.getPriors() -> retval

void cv::ml::Boost::setPriors( const cv::Mat& val )

AutoIt:
    cv.ml.Boost.setPriors( $val ) -> None

int cv::ml::Boost::getVarCount()

AutoIt:
    cv.ml.Boost.getVarCount() -> retval

bool cv::ml::Boost::empty()

AutoIt:
    cv.ml.Boost.empty() -> retval

bool cv::ml::Boost::isTrained()

AutoIt:
    cv.ml.Boost.isTrained() -> retval

bool cv::ml::Boost::isClassifier()

AutoIt:
    cv.ml.Boost.isClassifier() -> retval

bool cv::ml::Boost::train( const cv::Ptr<cv::ml::TrainData>& trainData
                           int                               flags = 0 )

AutoIt:
    cv.ml.Boost.train( $trainData[, $flags] ) -> retval

bool cv::ml::Boost::train( _InputArray samples
                           int         layout
                           _InputArray responses )

AutoIt:
    cv.ml.Boost.train( $samples, $layout, $responses ) -> retval

float cv::ml::Boost::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                bool                              test
                                _OutputArray                      resp )

AutoIt:
    cv.ml.Boost.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::Boost::predict( _InputArray  samples
                              _OutputArray results = noArray()
                              int          flags = 0 )

AutoIt:
    cv.ml.Boost.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::Boost::clear()

AutoIt:
    cv.ml.Boost.clear() -> None

void cv::ml::Boost::write( const cv::Ptr<cv::FileStorage>& fs
                           const std::string&              name = String() )

AutoIt:
    cv.ml.Boost.write( $fs[, $name] ) -> None

void cv::ml::Boost::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.Boost.read( $fn ) -> None

void cv::ml::Boost::save( const std::string& filename )

AutoIt:
    cv.ml.Boost.save( $filename ) -> None

std::string cv::ml::Boost::getDefaultName()

AutoIt:
    cv.ml.Boost.getDefaultName() -> retval

void cv::ml::ANN_MLP::setTrainMethod( int    method
                                      double param1 = 0
                                      double param2 = 0 )

AutoIt:
    cv.ml.ANN_MLP.setTrainMethod( $method[, $param1[, $param2]] ) -> None

int cv::ml::ANN_MLP::getTrainMethod()

AutoIt:
    cv.ml.ANN_MLP.getTrainMethod() -> retval

void cv::ml::ANN_MLP::setActivationFunction( int    type
                                             double param1 = 0
                                             double param2 = 0 )

AutoIt:
    cv.ml.ANN_MLP.setActivationFunction( $type[, $param1[, $param2]] ) -> None

void cv::ml::ANN_MLP::setLayerSizes( _InputArray _layer_sizes )

AutoIt:
    cv.ml.ANN_MLP.setLayerSizes( $_layer_sizes ) -> None

cv::Mat cv::ml::ANN_MLP::getLayerSizes()

AutoIt:
    cv.ml.ANN_MLP.getLayerSizes() -> retval

cv::TermCriteria cv::ml::ANN_MLP::getTermCriteria()

AutoIt:
    cv.ml.ANN_MLP.getTermCriteria() -> retval

void cv::ml::ANN_MLP::setTermCriteria( cv::TermCriteria val )

AutoIt:
    cv.ml.ANN_MLP.setTermCriteria( $val ) -> None

double cv::ml::ANN_MLP::getBackpropWeightScale()

AutoIt:
    cv.ml.ANN_MLP.getBackpropWeightScale() -> retval

void cv::ml::ANN_MLP::setBackpropWeightScale( double val )

AutoIt:
    cv.ml.ANN_MLP.setBackpropWeightScale( $val ) -> None

double cv::ml::ANN_MLP::getBackpropMomentumScale()

AutoIt:
    cv.ml.ANN_MLP.getBackpropMomentumScale() -> retval

void cv::ml::ANN_MLP::setBackpropMomentumScale( double val )

AutoIt:
    cv.ml.ANN_MLP.setBackpropMomentumScale( $val ) -> None

double cv::ml::ANN_MLP::getRpropDW0()

AutoIt:
    cv.ml.ANN_MLP.getRpropDW0() -> retval

void cv::ml::ANN_MLP::setRpropDW0( double val )

AutoIt:
    cv.ml.ANN_MLP.setRpropDW0( $val ) -> None

double cv::ml::ANN_MLP::getRpropDWPlus()

AutoIt:
    cv.ml.ANN_MLP.getRpropDWPlus() -> retval

void cv::ml::ANN_MLP::setRpropDWPlus( double val )

AutoIt:
    cv.ml.ANN_MLP.setRpropDWPlus( $val ) -> None

double cv::ml::ANN_MLP::getRpropDWMinus()

AutoIt:
    cv.ml.ANN_MLP.getRpropDWMinus() -> retval

void cv::ml::ANN_MLP::setRpropDWMinus( double val )

AutoIt:
    cv.ml.ANN_MLP.setRpropDWMinus( $val ) -> None

double cv::ml::ANN_MLP::getRpropDWMin()

AutoIt:
    cv.ml.ANN_MLP.getRpropDWMin() -> retval

void cv::ml::ANN_MLP::setRpropDWMin( double val )

AutoIt:
    cv.ml.ANN_MLP.setRpropDWMin( $val ) -> None

double cv::ml::ANN_MLP::getRpropDWMax()

AutoIt:
    cv.ml.ANN_MLP.getRpropDWMax() -> retval

void cv::ml::ANN_MLP::setRpropDWMax( double val )

AutoIt:
    cv.ml.ANN_MLP.setRpropDWMax( $val ) -> None

double cv::ml::ANN_MLP::getAnnealInitialT()

AutoIt:
    cv.ml.ANN_MLP.getAnnealInitialT() -> retval

void cv::ml::ANN_MLP::setAnnealInitialT( double val )

AutoIt:
    cv.ml.ANN_MLP.setAnnealInitialT( $val ) -> None

double cv::ml::ANN_MLP::getAnnealFinalT()

AutoIt:
    cv.ml.ANN_MLP.getAnnealFinalT() -> retval

void cv::ml::ANN_MLP::setAnnealFinalT( double val )

AutoIt:
    cv.ml.ANN_MLP.setAnnealFinalT( $val ) -> None

double cv::ml::ANN_MLP::getAnnealCoolingRatio()

AutoIt:
    cv.ml.ANN_MLP.getAnnealCoolingRatio() -> retval

void cv::ml::ANN_MLP::setAnnealCoolingRatio( double val )

AutoIt:
    cv.ml.ANN_MLP.setAnnealCoolingRatio( $val ) -> None

int cv::ml::ANN_MLP::getAnnealItePerStep()

AutoIt:
    cv.ml.ANN_MLP.getAnnealItePerStep() -> retval

void cv::ml::ANN_MLP::setAnnealItePerStep( int val )

AutoIt:
    cv.ml.ANN_MLP.setAnnealItePerStep( $val ) -> None

cv::Mat cv::ml::ANN_MLP::getWeights( int layerIdx )

AutoIt:
    cv.ml.ANN_MLP.getWeights( $layerIdx ) -> retval

static cv::Ptr<cv::ml::ANN_MLP> cv::ml::ANN_MLP::create()

AutoIt:
    cv.ml.ANN_MLP.create() -> retval

static cv::Ptr<cv::ml::ANN_MLP> cv::ml::ANN_MLP::load( const std::string& filepath )

AutoIt:
    cv.ml.ANN_MLP.load( $filepath ) -> retval

int cv::ml::ANN_MLP::getVarCount()

AutoIt:
    cv.ml.ANN_MLP.getVarCount() -> retval

bool cv::ml::ANN_MLP::empty()

AutoIt:
    cv.ml.ANN_MLP.empty() -> retval

bool cv::ml::ANN_MLP::isTrained()

AutoIt:
    cv.ml.ANN_MLP.isTrained() -> retval

bool cv::ml::ANN_MLP::isClassifier()

AutoIt:
    cv.ml.ANN_MLP.isClassifier() -> retval

bool cv::ml::ANN_MLP::train( const cv::Ptr<cv::ml::TrainData>& trainData
                             int                               flags = 0 )

AutoIt:
    cv.ml.ANN_MLP.train( $trainData[, $flags] ) -> retval

bool cv::ml::ANN_MLP::train( _InputArray samples
                             int         layout
                             _InputArray responses )

AutoIt:
    cv.ml.ANN_MLP.train( $samples, $layout, $responses ) -> retval

float cv::ml::ANN_MLP::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                  bool                              test
                                  _OutputArray                      resp )

AutoIt:
    cv.ml.ANN_MLP.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::ANN_MLP::predict( _InputArray  samples
                                _OutputArray results = noArray()
                                int          flags = 0 )

AutoIt:
    cv.ml.ANN_MLP.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::ANN_MLP::clear()

AutoIt:
    cv.ml.ANN_MLP.clear() -> None

void cv::ml::ANN_MLP::write( const cv::Ptr<cv::FileStorage>& fs
                             const std::string&              name = String() )

AutoIt:
    cv.ml.ANN_MLP.write( $fs[, $name] ) -> None

void cv::ml::ANN_MLP::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.ANN_MLP.read( $fn ) -> None

void cv::ml::ANN_MLP::save( const std::string& filename )

AutoIt:
    cv.ml.ANN_MLP.save( $filename ) -> None

std::string cv::ml::ANN_MLP::getDefaultName()

AutoIt:
    cv.ml.ANN_MLP.getDefaultName() -> retval

double cv::ml::LogisticRegression::getLearningRate()

AutoIt:
    cv.ml.LogisticRegression.getLearningRate() -> retval

void cv::ml::LogisticRegression::setLearningRate( double val )

AutoIt:
    cv.ml.LogisticRegression.setLearningRate( $val ) -> None

int cv::ml::LogisticRegression::getIterations()

AutoIt:
    cv.ml.LogisticRegression.getIterations() -> retval

void cv::ml::LogisticRegression::setIterations( int val )

AutoIt:
    cv.ml.LogisticRegression.setIterations( $val ) -> None

int cv::ml::LogisticRegression::getRegularization()

AutoIt:
    cv.ml.LogisticRegression.getRegularization() -> retval

void cv::ml::LogisticRegression::setRegularization( int val )

AutoIt:
    cv.ml.LogisticRegression.setRegularization( $val ) -> None

int cv::ml::LogisticRegression::getTrainMethod()

AutoIt:
    cv.ml.LogisticRegression.getTrainMethod() -> retval

void cv::ml::LogisticRegression::setTrainMethod( int val )

AutoIt:
    cv.ml.LogisticRegression.setTrainMethod( $val ) -> None

int cv::ml::LogisticRegression::getMiniBatchSize()

AutoIt:
    cv.ml.LogisticRegression.getMiniBatchSize() -> retval

void cv::ml::LogisticRegression::setMiniBatchSize( int val )

AutoIt:
    cv.ml.LogisticRegression.setMiniBatchSize( $val ) -> None

cv::TermCriteria cv::ml::LogisticRegression::getTermCriteria()

AutoIt:
    cv.ml.LogisticRegression.getTermCriteria() -> retval

void cv::ml::LogisticRegression::setTermCriteria( cv::TermCriteria val )

AutoIt:
    cv.ml.LogisticRegression.setTermCriteria( $val ) -> None

float cv::ml::LogisticRegression::predict( _InputArray  samples
                                           _OutputArray results = noArray()
                                           int          flags = 0 )

AutoIt:
    cv.ml.LogisticRegression.predict( $samples[, $results[, $flags]] ) -> retval, results

cv::Mat cv::ml::LogisticRegression::get_learnt_thetas()

AutoIt:
    cv.ml.LogisticRegression.get_learnt_thetas() -> retval

static cv::Ptr<cv::ml::LogisticRegression> cv::ml::LogisticRegression::create()

AutoIt:
    cv.ml.LogisticRegression.create() -> retval

static cv::Ptr<cv::ml::LogisticRegression> cv::ml::LogisticRegression::load( const std::string& filepath
                                                                             const std::string& nodeName = String() )

AutoIt:
    cv.ml.LogisticRegression.load( $filepath[, $nodeName] ) -> retval

int cv::ml::LogisticRegression::getVarCount()

AutoIt:
    cv.ml.LogisticRegression.getVarCount() -> retval

bool cv::ml::LogisticRegression::empty()

AutoIt:
    cv.ml.LogisticRegression.empty() -> retval

bool cv::ml::LogisticRegression::isTrained()

AutoIt:
    cv.ml.LogisticRegression.isTrained() -> retval

bool cv::ml::LogisticRegression::isClassifier()

AutoIt:
    cv.ml.LogisticRegression.isClassifier() -> retval

bool cv::ml::LogisticRegression::train( const cv::Ptr<cv::ml::TrainData>& trainData
                                        int                               flags = 0 )

AutoIt:
    cv.ml.LogisticRegression.train( $trainData[, $flags] ) -> retval

bool cv::ml::LogisticRegression::train( _InputArray samples
                                        int         layout
                                        _InputArray responses )

AutoIt:
    cv.ml.LogisticRegression.train( $samples, $layout, $responses ) -> retval

float cv::ml::LogisticRegression::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                             bool                              test
                                             _OutputArray                      resp )

AutoIt:
    cv.ml.LogisticRegression.calcError( $data, $test[, $resp] ) -> retval, resp

void cv::ml::LogisticRegression::clear()

AutoIt:
    cv.ml.LogisticRegression.clear() -> None

void cv::ml::LogisticRegression::write( const cv::Ptr<cv::FileStorage>& fs
                                        const std::string&              name = String() )

AutoIt:
    cv.ml.LogisticRegression.write( $fs[, $name] ) -> None

void cv::ml::LogisticRegression::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.LogisticRegression.read( $fn ) -> None

void cv::ml::LogisticRegression::save( const std::string& filename )

AutoIt:
    cv.ml.LogisticRegression.save( $filename ) -> None

std::string cv::ml::LogisticRegression::getDefaultName()

AutoIt:
    cv.ml.LogisticRegression.getDefaultName() -> retval

cv::Mat cv::ml::SVMSGD::getWeights()

AutoIt:
    cv.ml.SVMSGD.getWeights() -> retval

float cv::ml::SVMSGD::getShift()

AutoIt:
    cv.ml.SVMSGD.getShift() -> retval

static cv::Ptr<cv::ml::SVMSGD> cv::ml::SVMSGD::create()

AutoIt:
    cv.ml.SVMSGD.create() -> retval

static cv::Ptr<cv::ml::SVMSGD> cv::ml::SVMSGD::load( const std::string& filepath
                                                     const std::string& nodeName = String() )

AutoIt:
    cv.ml.SVMSGD.load( $filepath[, $nodeName] ) -> retval

void cv::ml::SVMSGD::setOptimalParameters( int svmsgdType = SVMSGD::ASGD
                                           int marginType = SVMSGD::SOFT_MARGIN )

AutoIt:
    cv.ml.SVMSGD.setOptimalParameters( [$svmsgdType[, $marginType]] ) -> None

int cv::ml::SVMSGD::getSvmsgdType()

AutoIt:
    cv.ml.SVMSGD.getSvmsgdType() -> retval

void cv::ml::SVMSGD::setSvmsgdType( int svmsgdType )

AutoIt:
    cv.ml.SVMSGD.setSvmsgdType( $svmsgdType ) -> None

int cv::ml::SVMSGD::getMarginType()

AutoIt:
    cv.ml.SVMSGD.getMarginType() -> retval

void cv::ml::SVMSGD::setMarginType( int marginType )

AutoIt:
    cv.ml.SVMSGD.setMarginType( $marginType ) -> None

float cv::ml::SVMSGD::getMarginRegularization()

AutoIt:
    cv.ml.SVMSGD.getMarginRegularization() -> retval

void cv::ml::SVMSGD::setMarginRegularization( float marginRegularization )

AutoIt:
    cv.ml.SVMSGD.setMarginRegularization( $marginRegularization ) -> None

float cv::ml::SVMSGD::getInitialStepSize()

AutoIt:
    cv.ml.SVMSGD.getInitialStepSize() -> retval

void cv::ml::SVMSGD::setInitialStepSize( float InitialStepSize )

AutoIt:
    cv.ml.SVMSGD.setInitialStepSize( $InitialStepSize ) -> None

float cv::ml::SVMSGD::getStepDecreasingPower()

AutoIt:
    cv.ml.SVMSGD.getStepDecreasingPower() -> retval

void cv::ml::SVMSGD::setStepDecreasingPower( float stepDecreasingPower )

AutoIt:
    cv.ml.SVMSGD.setStepDecreasingPower( $stepDecreasingPower ) -> None

cv::TermCriteria cv::ml::SVMSGD::getTermCriteria()

AutoIt:
    cv.ml.SVMSGD.getTermCriteria() -> retval

void cv::ml::SVMSGD::setTermCriteria( const cv::TermCriteria& val )

AutoIt:
    cv.ml.SVMSGD.setTermCriteria( $val ) -> None

int cv::ml::SVMSGD::getVarCount()

AutoIt:
    cv.ml.SVMSGD.getVarCount() -> retval

bool cv::ml::SVMSGD::empty()

AutoIt:
    cv.ml.SVMSGD.empty() -> retval

bool cv::ml::SVMSGD::isTrained()

AutoIt:
    cv.ml.SVMSGD.isTrained() -> retval

bool cv::ml::SVMSGD::isClassifier()

AutoIt:
    cv.ml.SVMSGD.isClassifier() -> retval

bool cv::ml::SVMSGD::train( const cv::Ptr<cv::ml::TrainData>& trainData
                            int                               flags = 0 )

AutoIt:
    cv.ml.SVMSGD.train( $trainData[, $flags] ) -> retval

bool cv::ml::SVMSGD::train( _InputArray samples
                            int         layout
                            _InputArray responses )

AutoIt:
    cv.ml.SVMSGD.train( $samples, $layout, $responses ) -> retval

float cv::ml::SVMSGD::calcError( const cv::Ptr<cv::ml::TrainData>& data
                                 bool                              test
                                 _OutputArray                      resp )

AutoIt:
    cv.ml.SVMSGD.calcError( $data, $test[, $resp] ) -> retval, resp

float cv::ml::SVMSGD::predict( _InputArray  samples
                               _OutputArray results = noArray()
                               int          flags = 0 )

AutoIt:
    cv.ml.SVMSGD.predict( $samples[, $results[, $flags]] ) -> retval, results

void cv::ml::SVMSGD::clear()

AutoIt:
    cv.ml.SVMSGD.clear() -> None

void cv::ml::SVMSGD::write( const cv::Ptr<cv::FileStorage>& fs
                            const std::string&              name = String() )

AutoIt:
    cv.ml.SVMSGD.write( $fs[, $name] ) -> None

void cv::ml::SVMSGD::read( const cv::FileNode& fn )

AutoIt:
    cv.ml.SVMSGD.read( $fn ) -> None

void cv::ml::SVMSGD::save( const std::string& filename )

AutoIt:
    cv.ml.SVMSGD.save( $filename ) -> None

std::string cv::ml::SVMSGD::getDefaultName()

AutoIt:
    cv.ml.SVMSGD.getDefaultName() -> retval

void cv::Tonemap::process( _InputArray  src
                           _OutputArray dst )

AutoIt:
    cv.Tonemap.process( $src[, $dst] ) -> dst

float cv::Tonemap::getGamma()

AutoIt:
    cv.Tonemap.getGamma() -> retval

void cv::Tonemap::setGamma( float gamma )

AutoIt:
    cv.Tonemap.setGamma( $gamma ) -> None

void cv::Tonemap::clear()

AutoIt:
    cv.Tonemap.clear() -> None

void cv::Tonemap::write( const cv::Ptr<cv::FileStorage>& fs
                         const std::string&              name = String() )

AutoIt:
    cv.Tonemap.write( $fs[, $name] ) -> None

void cv::Tonemap::read( const cv::FileNode& fn )

AutoIt:
    cv.Tonemap.read( $fn ) -> None

bool cv::Tonemap::empty()

AutoIt:
    cv.Tonemap.empty() -> retval

void cv::Tonemap::save( const std::string& filename )

AutoIt:
    cv.Tonemap.save( $filename ) -> None

std::string cv::Tonemap::getDefaultName()

AutoIt:
    cv.Tonemap.getDefaultName() -> retval

float cv::TonemapDrago::getSaturation()

AutoIt:
    cv.TonemapDrago.getSaturation() -> retval

void cv::TonemapDrago::setSaturation( float saturation )

AutoIt:
    cv.TonemapDrago.setSaturation( $saturation ) -> None

float cv::TonemapDrago::getBias()

AutoIt:
    cv.TonemapDrago.getBias() -> retval

void cv::TonemapDrago::setBias( float bias )

AutoIt:
    cv.TonemapDrago.setBias( $bias ) -> None

void cv::TonemapDrago::process( _InputArray  src
                                _OutputArray dst )

AutoIt:
    cv.TonemapDrago.process( $src[, $dst] ) -> dst

float cv::TonemapDrago::getGamma()

AutoIt:
    cv.TonemapDrago.getGamma() -> retval

void cv::TonemapDrago::setGamma( float gamma )

AutoIt:
    cv.TonemapDrago.setGamma( $gamma ) -> None

void cv::TonemapDrago::clear()

AutoIt:
    cv.TonemapDrago.clear() -> None

void cv::TonemapDrago::write( const cv::Ptr<cv::FileStorage>& fs
                              const std::string&              name = String() )

AutoIt:
    cv.TonemapDrago.write( $fs[, $name] ) -> None

void cv::TonemapDrago::read( const cv::FileNode& fn )

AutoIt:
    cv.TonemapDrago.read( $fn ) -> None

bool cv::TonemapDrago::empty()

AutoIt:
    cv.TonemapDrago.empty() -> retval

void cv::TonemapDrago::save( const std::string& filename )

AutoIt:
    cv.TonemapDrago.save( $filename ) -> None

std::string cv::TonemapDrago::getDefaultName()

AutoIt:
    cv.TonemapDrago.getDefaultName() -> retval

float cv::TonemapReinhard::getIntensity()

AutoIt:
    cv.TonemapReinhard.getIntensity() -> retval

void cv::TonemapReinhard::setIntensity( float intensity )

AutoIt:
    cv.TonemapReinhard.setIntensity( $intensity ) -> None

float cv::TonemapReinhard::getLightAdaptation()

AutoIt:
    cv.TonemapReinhard.getLightAdaptation() -> retval

void cv::TonemapReinhard::setLightAdaptation( float light_adapt )

AutoIt:
    cv.TonemapReinhard.setLightAdaptation( $light_adapt ) -> None

float cv::TonemapReinhard::getColorAdaptation()

AutoIt:
    cv.TonemapReinhard.getColorAdaptation() -> retval

void cv::TonemapReinhard::setColorAdaptation( float color_adapt )

AutoIt:
    cv.TonemapReinhard.setColorAdaptation( $color_adapt ) -> None

void cv::TonemapReinhard::process( _InputArray  src
                                   _OutputArray dst )

AutoIt:
    cv.TonemapReinhard.process( $src[, $dst] ) -> dst

float cv::TonemapReinhard::getGamma()

AutoIt:
    cv.TonemapReinhard.getGamma() -> retval

void cv::TonemapReinhard::setGamma( float gamma )

AutoIt:
    cv.TonemapReinhard.setGamma( $gamma ) -> None

void cv::TonemapReinhard::clear()

AutoIt:
    cv.TonemapReinhard.clear() -> None

void cv::TonemapReinhard::write( const cv::Ptr<cv::FileStorage>& fs
                                 const std::string&              name = String() )

AutoIt:
    cv.TonemapReinhard.write( $fs[, $name] ) -> None

void cv::TonemapReinhard::read( const cv::FileNode& fn )

AutoIt:
    cv.TonemapReinhard.read( $fn ) -> None

bool cv::TonemapReinhard::empty()

AutoIt:
    cv.TonemapReinhard.empty() -> retval

void cv::TonemapReinhard::save( const std::string& filename )

AutoIt:
    cv.TonemapReinhard.save( $filename ) -> None

std::string cv::TonemapReinhard::getDefaultName()

AutoIt:
    cv.TonemapReinhard.getDefaultName() -> retval

float cv::TonemapMantiuk::getScale()

AutoIt:
    cv.TonemapMantiuk.getScale() -> retval

void cv::TonemapMantiuk::setScale( float scale )

AutoIt:
    cv.TonemapMantiuk.setScale( $scale ) -> None

float cv::TonemapMantiuk::getSaturation()

AutoIt:
    cv.TonemapMantiuk.getSaturation() -> retval

void cv::TonemapMantiuk::setSaturation( float saturation )

AutoIt:
    cv.TonemapMantiuk.setSaturation( $saturation ) -> None

void cv::TonemapMantiuk::process( _InputArray  src
                                  _OutputArray dst )

AutoIt:
    cv.TonemapMantiuk.process( $src[, $dst] ) -> dst

float cv::TonemapMantiuk::getGamma()

AutoIt:
    cv.TonemapMantiuk.getGamma() -> retval

void cv::TonemapMantiuk::setGamma( float gamma )

AutoIt:
    cv.TonemapMantiuk.setGamma( $gamma ) -> None

void cv::TonemapMantiuk::clear()

AutoIt:
    cv.TonemapMantiuk.clear() -> None

void cv::TonemapMantiuk::write( const cv::Ptr<cv::FileStorage>& fs
                                const std::string&              name = String() )

AutoIt:
    cv.TonemapMantiuk.write( $fs[, $name] ) -> None

void cv::TonemapMantiuk::read( const cv::FileNode& fn )

AutoIt:
    cv.TonemapMantiuk.read( $fn ) -> None

bool cv::TonemapMantiuk::empty()

AutoIt:
    cv.TonemapMantiuk.empty() -> retval

void cv::TonemapMantiuk::save( const std::string& filename )

AutoIt:
    cv.TonemapMantiuk.save( $filename ) -> None

std::string cv::TonemapMantiuk::getDefaultName()

AutoIt:
    cv.TonemapMantiuk.getDefaultName() -> retval

void cv::AlignExposures::process( _InputArray           src
                                  std::vector<cv::Mat>& dst
                                  _InputArray           times
                                  _InputArray           response )

AutoIt:
    cv.AlignExposures.process( $src, $dst, $times, $response ) -> None

void cv::AlignExposures::clear()

AutoIt:
    cv.AlignExposures.clear() -> None

void cv::AlignExposures::write( const cv::Ptr<cv::FileStorage>& fs
                                const std::string&              name = String() )

AutoIt:
    cv.AlignExposures.write( $fs[, $name] ) -> None

void cv::AlignExposures::read( const cv::FileNode& fn )

AutoIt:
    cv.AlignExposures.read( $fn ) -> None

bool cv::AlignExposures::empty()

AutoIt:
    cv.AlignExposures.empty() -> retval

void cv::AlignExposures::save( const std::string& filename )

AutoIt:
    cv.AlignExposures.save( $filename ) -> None

std::string cv::AlignExposures::getDefaultName()

AutoIt:
    cv.AlignExposures.getDefaultName() -> retval

void cv::AlignMTB::process( _InputArray           src
                            std::vector<cv::Mat>& dst
                            _InputArray           times
                            _InputArray           response )

AutoIt:
    cv.AlignMTB.process( $src, $dst, $times, $response ) -> None

void cv::AlignMTB::process( _InputArray           src
                            std::vector<cv::Mat>& dst )

AutoIt:
    cv.AlignMTB.process( $src, $dst ) -> None

cv::Point cv::AlignMTB::calculateShift( _InputArray img0
                                        _InputArray img1 )

AutoIt:
    cv.AlignMTB.calculateShift( $img0, $img1 ) -> retval

void cv::AlignMTB::shiftMat( _InputArray     src
                             _OutputArray    dst
                             const cv::Point shift )

AutoIt:
    cv.AlignMTB.shiftMat( $src, $shift[, $dst] ) -> dst

void cv::AlignMTB::computeBitmaps( _InputArray  img
                                   _OutputArray tb
                                   _OutputArray eb )

AutoIt:
    cv.AlignMTB.computeBitmaps( $img[, $tb[, $eb]] ) -> tb, eb

int cv::AlignMTB::getMaxBits()

AutoIt:
    cv.AlignMTB.getMaxBits() -> retval

void cv::AlignMTB::setMaxBits( int max_bits )

AutoIt:
    cv.AlignMTB.setMaxBits( $max_bits ) -> None

int cv::AlignMTB::getExcludeRange()

AutoIt:
    cv.AlignMTB.getExcludeRange() -> retval

void cv::AlignMTB::setExcludeRange( int exclude_range )

AutoIt:
    cv.AlignMTB.setExcludeRange( $exclude_range ) -> None

bool cv::AlignMTB::getCut()

AutoIt:
    cv.AlignMTB.getCut() -> retval

void cv::AlignMTB::setCut( bool value )

AutoIt:
    cv.AlignMTB.setCut( $value ) -> None

void cv::AlignMTB::clear()

AutoIt:
    cv.AlignMTB.clear() -> None

void cv::AlignMTB::write( const cv::Ptr<cv::FileStorage>& fs
                          const std::string&              name = String() )

AutoIt:
    cv.AlignMTB.write( $fs[, $name] ) -> None

void cv::AlignMTB::read( const cv::FileNode& fn )

AutoIt:
    cv.AlignMTB.read( $fn ) -> None

bool cv::AlignMTB::empty()

AutoIt:
    cv.AlignMTB.empty() -> retval

void cv::AlignMTB::save( const std::string& filename )

AutoIt:
    cv.AlignMTB.save( $filename ) -> None

std::string cv::AlignMTB::getDefaultName()

AutoIt:
    cv.AlignMTB.getDefaultName() -> retval

void cv::CalibrateCRF::process( _InputArray  src
                                _OutputArray dst
                                _InputArray  times )

AutoIt:
    cv.CalibrateCRF.process( $src, $times[, $dst] ) -> dst

void cv::CalibrateCRF::clear()

AutoIt:
    cv.CalibrateCRF.clear() -> None

void cv::CalibrateCRF::write( const cv::Ptr<cv::FileStorage>& fs
                              const std::string&              name = String() )

AutoIt:
    cv.CalibrateCRF.write( $fs[, $name] ) -> None

void cv::CalibrateCRF::read( const cv::FileNode& fn )

AutoIt:
    cv.CalibrateCRF.read( $fn ) -> None

bool cv::CalibrateCRF::empty()

AutoIt:
    cv.CalibrateCRF.empty() -> retval

void cv::CalibrateCRF::save( const std::string& filename )

AutoIt:
    cv.CalibrateCRF.save( $filename ) -> None

std::string cv::CalibrateCRF::getDefaultName()

AutoIt:
    cv.CalibrateCRF.getDefaultName() -> retval

float cv::CalibrateDebevec::getLambda()

AutoIt:
    cv.CalibrateDebevec.getLambda() -> retval

void cv::CalibrateDebevec::setLambda( float lambda )

AutoIt:
    cv.CalibrateDebevec.setLambda( $lambda ) -> None

int cv::CalibrateDebevec::getSamples()

AutoIt:
    cv.CalibrateDebevec.getSamples() -> retval

void cv::CalibrateDebevec::setSamples( int samples )

AutoIt:
    cv.CalibrateDebevec.setSamples( $samples ) -> None

bool cv::CalibrateDebevec::getRandom()

AutoIt:
    cv.CalibrateDebevec.getRandom() -> retval

void cv::CalibrateDebevec::setRandom( bool random )

AutoIt:
    cv.CalibrateDebevec.setRandom( $random ) -> None

void cv::CalibrateDebevec::process( _InputArray  src
                                    _OutputArray dst
                                    _InputArray  times )

AutoIt:
    cv.CalibrateDebevec.process( $src, $times[, $dst] ) -> dst

void cv::CalibrateDebevec::clear()

AutoIt:
    cv.CalibrateDebevec.clear() -> None

void cv::CalibrateDebevec::write( const cv::Ptr<cv::FileStorage>& fs
                                  const std::string&              name = String() )

AutoIt:
    cv.CalibrateDebevec.write( $fs[, $name] ) -> None

void cv::CalibrateDebevec::read( const cv::FileNode& fn )

AutoIt:
    cv.CalibrateDebevec.read( $fn ) -> None

bool cv::CalibrateDebevec::empty()

AutoIt:
    cv.CalibrateDebevec.empty() -> retval

void cv::CalibrateDebevec::save( const std::string& filename )

AutoIt:
    cv.CalibrateDebevec.save( $filename ) -> None

std::string cv::CalibrateDebevec::getDefaultName()

AutoIt:
    cv.CalibrateDebevec.getDefaultName() -> retval

int cv::CalibrateRobertson::getMaxIter()

AutoIt:
    cv.CalibrateRobertson.getMaxIter() -> retval

void cv::CalibrateRobertson::setMaxIter( int max_iter )

AutoIt:
    cv.CalibrateRobertson.setMaxIter( $max_iter ) -> None

float cv::CalibrateRobertson::getThreshold()

AutoIt:
    cv.CalibrateRobertson.getThreshold() -> retval

void cv::CalibrateRobertson::setThreshold( float threshold )

AutoIt:
    cv.CalibrateRobertson.setThreshold( $threshold ) -> None

cv::Mat cv::CalibrateRobertson::getRadiance()

AutoIt:
    cv.CalibrateRobertson.getRadiance() -> retval

void cv::CalibrateRobertson::process( _InputArray  src
                                      _OutputArray dst
                                      _InputArray  times )

AutoIt:
    cv.CalibrateRobertson.process( $src, $times[, $dst] ) -> dst

void cv::CalibrateRobertson::clear()

AutoIt:
    cv.CalibrateRobertson.clear() -> None

void cv::CalibrateRobertson::write( const cv::Ptr<cv::FileStorage>& fs
                                    const std::string&              name = String() )

AutoIt:
    cv.CalibrateRobertson.write( $fs[, $name] ) -> None

void cv::CalibrateRobertson::read( const cv::FileNode& fn )

AutoIt:
    cv.CalibrateRobertson.read( $fn ) -> None

bool cv::CalibrateRobertson::empty()

AutoIt:
    cv.CalibrateRobertson.empty() -> retval

void cv::CalibrateRobertson::save( const std::string& filename )

AutoIt:
    cv.CalibrateRobertson.save( $filename ) -> None

std::string cv::CalibrateRobertson::getDefaultName()

AutoIt:
    cv.CalibrateRobertson.getDefaultName() -> retval

void cv::MergeExposures::process( _InputArray  src
                                  _OutputArray dst
                                  _InputArray  times
                                  _InputArray  response )

AutoIt:
    cv.MergeExposures.process( $src, $times, $response[, $dst] ) -> dst

void cv::MergeExposures::clear()

AutoIt:
    cv.MergeExposures.clear() -> None

void cv::MergeExposures::write( const cv::Ptr<cv::FileStorage>& fs
                                const std::string&              name = String() )

AutoIt:
    cv.MergeExposures.write( $fs[, $name] ) -> None

void cv::MergeExposures::read( const cv::FileNode& fn )

AutoIt:
    cv.MergeExposures.read( $fn ) -> None

bool cv::MergeExposures::empty()

AutoIt:
    cv.MergeExposures.empty() -> retval

void cv::MergeExposures::save( const std::string& filename )

AutoIt:
    cv.MergeExposures.save( $filename ) -> None

std::string cv::MergeExposures::getDefaultName()

AutoIt:
    cv.MergeExposures.getDefaultName() -> retval

void cv::MergeDebevec::process( _InputArray  src
                                _OutputArray dst
                                _InputArray  times
                                _InputArray  response )

AutoIt:
    cv.MergeDebevec.process( $src, $times, $response[, $dst] ) -> dst

void cv::MergeDebevec::process( _InputArray  src
                                _OutputArray dst
                                _InputArray  times )

AutoIt:
    cv.MergeDebevec.process( $src, $times[, $dst] ) -> dst

void cv::MergeDebevec::clear()

AutoIt:
    cv.MergeDebevec.clear() -> None

void cv::MergeDebevec::write( const cv::Ptr<cv::FileStorage>& fs
                              const std::string&              name = String() )

AutoIt:
    cv.MergeDebevec.write( $fs[, $name] ) -> None

void cv::MergeDebevec::read( const cv::FileNode& fn )

AutoIt:
    cv.MergeDebevec.read( $fn ) -> None

bool cv::MergeDebevec::empty()

AutoIt:
    cv.MergeDebevec.empty() -> retval

void cv::MergeDebevec::save( const std::string& filename )

AutoIt:
    cv.MergeDebevec.save( $filename ) -> None

std::string cv::MergeDebevec::getDefaultName()

AutoIt:
    cv.MergeDebevec.getDefaultName() -> retval

void cv::MergeMertens::process( _InputArray  src
                                _OutputArray dst
                                _InputArray  times
                                _InputArray  response )

AutoIt:
    cv.MergeMertens.process( $src, $times, $response[, $dst] ) -> dst

void cv::MergeMertens::process( _InputArray  src
                                _OutputArray dst )

AutoIt:
    cv.MergeMertens.process( $src[, $dst] ) -> dst

float cv::MergeMertens::getContrastWeight()

AutoIt:
    cv.MergeMertens.getContrastWeight() -> retval

void cv::MergeMertens::setContrastWeight( float contrast_weiht )

AutoIt:
    cv.MergeMertens.setContrastWeight( $contrast_weiht ) -> None

float cv::MergeMertens::getSaturationWeight()

AutoIt:
    cv.MergeMertens.getSaturationWeight() -> retval

void cv::MergeMertens::setSaturationWeight( float saturation_weight )

AutoIt:
    cv.MergeMertens.setSaturationWeight( $saturation_weight ) -> None

float cv::MergeMertens::getExposureWeight()

AutoIt:
    cv.MergeMertens.getExposureWeight() -> retval

void cv::MergeMertens::setExposureWeight( float exposure_weight )

AutoIt:
    cv.MergeMertens.setExposureWeight( $exposure_weight ) -> None

void cv::MergeMertens::clear()

AutoIt:
    cv.MergeMertens.clear() -> None

void cv::MergeMertens::write( const cv::Ptr<cv::FileStorage>& fs
                              const std::string&              name = String() )

AutoIt:
    cv.MergeMertens.write( $fs[, $name] ) -> None

void cv::MergeMertens::read( const cv::FileNode& fn )

AutoIt:
    cv.MergeMertens.read( $fn ) -> None

bool cv::MergeMertens::empty()

AutoIt:
    cv.MergeMertens.empty() -> retval

void cv::MergeMertens::save( const std::string& filename )

AutoIt:
    cv.MergeMertens.save( $filename ) -> None

std::string cv::MergeMertens::getDefaultName()

AutoIt:
    cv.MergeMertens.getDefaultName() -> retval

void cv::MergeRobertson::process( _InputArray  src
                                  _OutputArray dst
                                  _InputArray  times
                                  _InputArray  response )

AutoIt:
    cv.MergeRobertson.process( $src, $times, $response[, $dst] ) -> dst

void cv::MergeRobertson::process( _InputArray  src
                                  _OutputArray dst
                                  _InputArray  times )

AutoIt:
    cv.MergeRobertson.process( $src, $times[, $dst] ) -> dst

void cv::MergeRobertson::clear()

AutoIt:
    cv.MergeRobertson.clear() -> None

void cv::MergeRobertson::write( const cv::Ptr<cv::FileStorage>& fs
                                const std::string&              name = String() )

AutoIt:
    cv.MergeRobertson.write( $fs[, $name] ) -> None

void cv::MergeRobertson::read( const cv::FileNode& fn )

AutoIt:
    cv.MergeRobertson.read( $fn ) -> None

bool cv::MergeRobertson::empty()

AutoIt:
    cv.MergeRobertson.empty() -> retval

void cv::MergeRobertson::save( const std::string& filename )

AutoIt:
    cv.MergeRobertson.save( $filename ) -> None

std::string cv::MergeRobertson::getDefaultName()

AutoIt:
    cv.MergeRobertson.getDefaultName() -> retval

std::vector<int> cv::dnn::getAvailableTargets( int be )

AutoIt:
    cv.dnn.getAvailableTargets( $be ) -> retval

cv::dnn::Net cv::dnn::readNetFromDarknet( const std::string& cfgFile
                                          const std::string& darknetModel = String() )

AutoIt:
    cv.dnn.readNetFromDarknet( $cfgFile[, $darknetModel] ) -> retval

cv::dnn::Net cv::dnn::readNetFromDarknet( const std::vector<uchar>& bufferCfg
                                          const std::vector<uchar>& bufferModel = std::vector<uchar>() )

AutoIt:
    cv.dnn.readNetFromDarknet( $bufferCfg[, $bufferModel] ) -> retval

cv::dnn::Net cv::dnn::readNetFromCaffe( const std::string& prototxt
                                        const std::string& caffeModel = String() )

AutoIt:
    cv.dnn.readNetFromCaffe( $prototxt[, $caffeModel] ) -> retval

cv::dnn::Net cv::dnn::readNetFromCaffe( const std::vector<uchar>& bufferProto
                                        const std::vector<uchar>& bufferModel = std::vector<uchar>() )

AutoIt:
    cv.dnn.readNetFromCaffe( $bufferProto[, $bufferModel] ) -> retval

cv::dnn::Net cv::dnn::readNetFromTensorflow( const std::string& model
                                             const std::string& config = String() )

AutoIt:
    cv.dnn.readNetFromTensorflow( $model[, $config] ) -> retval

cv::dnn::Net cv::dnn::readNetFromTensorflow( const std::vector<uchar>& bufferModel
                                             const std::vector<uchar>& bufferConfig = std::vector<uchar>() )

AutoIt:
    cv.dnn.readNetFromTensorflow( $bufferModel[, $bufferConfig] ) -> retval

cv::dnn::Net cv::dnn::readNetFromTorch( const std::string& model
                                        bool               isBinary = true
                                        bool               evaluate = true )

AutoIt:
    cv.dnn.readNetFromTorch( $model[, $isBinary[, $evaluate]] ) -> retval

cv::dnn::Net cv::dnn::readNet( const std::string& model
                               const std::string& config = ""
                               const std::string& framework = "" )

AutoIt:
    cv.dnn.readNet( $model[, $config[, $framework]] ) -> retval

cv::dnn::Net cv::dnn::readNet( const std::string&        framework
                               const std::vector<uchar>& bufferModel
                               const std::vector<uchar>& bufferConfig = std::vector<uchar>() )

AutoIt:
    cv.dnn.readNet( $framework, $bufferModel[, $bufferConfig] ) -> retval

cv::Mat cv::dnn::readTorchBlob( const std::string& filename
                                bool               isBinary = true )

AutoIt:
    cv.dnn.readTorchBlob( $filename[, $isBinary] ) -> retval

cv::dnn::Net cv::dnn::readNetFromModelOptimizer( const std::string& xml
                                                 const std::string& bin )

AutoIt:
    cv.dnn.readNetFromModelOptimizer( $xml, $bin ) -> retval

cv::dnn::Net cv::dnn::readNetFromModelOptimizer( const std::vector<uchar>& bufferModelConfig
                                                 const std::vector<uchar>& bufferWeights )

AutoIt:
    cv.dnn.readNetFromModelOptimizer( $bufferModelConfig, $bufferWeights ) -> retval

cv::dnn::Net cv::dnn::readNetFromONNX( const std::string& onnxFile )

AutoIt:
    cv.dnn.readNetFromONNX( $onnxFile ) -> retval

cv::dnn::Net cv::dnn::readNetFromONNX( const std::vector<uchar>& buffer )

AutoIt:
    cv.dnn.readNetFromONNX( $buffer ) -> retval

cv::Mat cv::dnn::readTensorFromONNX( const std::string& path )

AutoIt:
    cv.dnn.readTensorFromONNX( $path ) -> retval

cv::Mat cv::dnn::blobFromImage( _InputArray       image
                                double            scalefactor = 1.0
                                const cv::Size&   size = Size()
                                const cv::Scalar& mean = Scalar()
                                bool              swapRB = false
                                bool              crop = false
                                int               ddepth = CV_32F )

AutoIt:
    cv.dnn.blobFromImage( $image[, $scalefactor[, $size[, $mean[, $swapRB[, $crop[, $ddepth]]]]]] ) -> retval

cv::Mat cv::dnn::blobFromImages( _InputArray       images
                                 double            scalefactor = 1.0
                                 cv::Size          size = Size()
                                 const cv::Scalar& mean = Scalar()
                                 bool              swapRB = false
                                 bool              crop = false
                                 int               ddepth = CV_32F )

AutoIt:
    cv.dnn.blobFromImages( $images[, $scalefactor[, $size[, $mean[, $swapRB[, $crop[, $ddepth]]]]]] ) -> retval

void cv::dnn::imagesFromBlob( const cv::Mat& blob_
                              _OutputArray   images_ )

AutoIt:
    cv.dnn.imagesFromBlob( $blob_[, $images_] ) -> images_

void cv::dnn::shrinkCaffeModel( const std::string&              src
                                const std::string&              dst
                                const std::vector<std::string>& layersTypes = std::vector<String>() )

AutoIt:
    cv.dnn.shrinkCaffeModel( $src, $dst[, $layersTypes] ) -> None

void cv::dnn::writeTextGraph( const std::string& model
                              const std::string& output )

AutoIt:
    cv.dnn.writeTextGraph( $model, $output ) -> None

void cv::dnn::NMSBoxes( const std::vector<cv::Rect2d>& bboxes
                        const std::vector<float>&      scores
                        const float                    score_threshold
                        const float                    nms_threshold
                        std::vector<int>&              indices
                        const float                    eta = 1.f
                        const int                      top_k = 0 )

AutoIt:
    cv.dnn.NMSBoxes( $bboxes, $scores, $score_threshold, $nms_threshold[, $eta[, $top_k[, $indices]]] ) -> indices

void cv::dnn::NMSBoxesRotated( const std::vector<cv::RotatedRect>& bboxes
                               const std::vector<float>&           scores
                               const float                         score_threshold
                               const float                         nms_threshold
                               std::vector<int>&                   indices
                               const float                         eta = 1.f
                               const int                           top_k = 0 )

AutoIt:
    cv.dnn.NMSBoxesRotated( $bboxes, $scores, $score_threshold, $nms_threshold[, $eta[, $top_k[, $indices]]] ) -> indices

void cv::dnn::softNMSBoxes( const std::vector<cv::Rect>& bboxes
                            const std::vector<float>&    scores
                            std::vector<float>&          updated_scores
                            const float                  score_threshold
                            const float                  nms_threshold
                            std::vector<int>&            indices
                            size_t                       top_k = 0
                            const float                  sigma = 0.5
                            int                          method = SoftNMSMethod::SOFTNMS_GAUSSIAN )

AutoIt:
    cv.dnn.softNMSBoxes( $bboxes, $scores, $score_threshold, $nms_threshold[, $top_k[, $sigma[, $method[, $updated_scores[, $indices]]]]] ) -> updated_scores, indices

static cv::dnn::DictValue cv::dnn::DictValue::create()

AutoIt:
    cv.dnn.DictValue.create() -> <cv.dnn.DictValue object>

static cv::dnn::DictValue cv::dnn::DictValue::create( int i )

AutoIt:
    cv.dnn.DictValue.create( $i ) -> <cv.dnn.DictValue object>

static cv::dnn::DictValue cv::dnn::DictValue::create( double p )

AutoIt:
    cv.dnn.DictValue.create( $p ) -> <cv.dnn.DictValue object>

static cv::dnn::DictValue cv::dnn::DictValue::create( const std::string& s )

AutoIt:
    cv.dnn.DictValue.create( $s ) -> <cv.dnn.DictValue object>

bool cv::dnn::DictValue::isInt()

AutoIt:
    cv.dnn.DictValue.isInt() -> retval

bool cv::dnn::DictValue::isString()

AutoIt:
    cv.dnn.DictValue.isString() -> retval

bool cv::dnn::DictValue::isReal()

AutoIt:
    cv.dnn.DictValue.isReal() -> retval

int cv::dnn::DictValue::getIntValue( int idx = -1 )

AutoIt:
    cv.dnn.DictValue.getIntValue( [$idx] ) -> retval

double cv::dnn::DictValue::getRealValue( int idx = -1 )

AutoIt:
    cv.dnn.DictValue.getRealValue( [$idx] ) -> retval

std::string cv::dnn::DictValue::getStringValue( int idx = -1 )

AutoIt:
    cv.dnn.DictValue.getStringValue( [$idx] ) -> retval

void cv::dnn::Layer::finalize( _InputArray  inputs
                               _OutputArray outputs )

AutoIt:
    cv.dnn.Layer.finalize( $inputs[, $outputs] ) -> outputs

void cv::dnn::Layer::run( const std::vector<cv::Mat>& inputs
                          std::vector<cv::Mat>&       outputs
                          std::vector<cv::Mat>&       internals )

AutoIt:
    cv.dnn.Layer.run( $inputs, $internals[, $outputs] ) -> outputs, internals

int cv::dnn::Layer::outputNameToIndex( const std::string& outputName )

AutoIt:
    cv.dnn.Layer.outputNameToIndex( $outputName ) -> retval

void cv::dnn::Layer::clear()

AutoIt:
    cv.dnn.Layer.clear() -> None

void cv::dnn::Layer::write( const cv::Ptr<cv::FileStorage>& fs
                            const std::string&              name = String() )

AutoIt:
    cv.dnn.Layer.write( $fs[, $name] ) -> None

void cv::dnn::Layer::read( const cv::FileNode& fn )

AutoIt:
    cv.dnn.Layer.read( $fn ) -> None

bool cv::dnn::Layer::empty()

AutoIt:
    cv.dnn.Layer.empty() -> retval

void cv::dnn::Layer::save( const std::string& filename )

AutoIt:
    cv.dnn.Layer.save( $filename ) -> None

std::string cv::dnn::Layer::getDefaultName()

AutoIt:
    cv.dnn.Layer.getDefaultName() -> retval

static cv::dnn::Net cv::dnn::Net::create()

AutoIt:
    cv.dnn.Net.create() -> <cv.dnn.Net object>

static cv::dnn::Net cv::dnn::Net::readFromModelOptimizer( const std::string& xml
                                                          const std::string& bin )

AutoIt:
    cv.dnn.Net.readFromModelOptimizer( $xml, $bin ) -> retval

static cv::dnn::Net cv::dnn::Net::readFromModelOptimizer( const std::vector<uchar>& bufferModelConfig
                                                          const std::vector<uchar>& bufferWeights )

AutoIt:
    cv.dnn.Net.readFromModelOptimizer( $bufferModelConfig, $bufferWeights ) -> retval

bool cv::dnn::Net::empty()

AutoIt:
    cv.dnn.Net.empty() -> retval

std::string cv::dnn::Net::dump()

AutoIt:
    cv.dnn.Net.dump() -> retval

void cv::dnn::Net::dumpToFile( const std::string& path )

AutoIt:
    cv.dnn.Net.dumpToFile( $path ) -> None

int cv::dnn::Net::getLayerId( const std::string& layer )

AutoIt:
    cv.dnn.Net.getLayerId( $layer ) -> retval

std::vector<std::string> cv::dnn::Net::getLayerNames()

AutoIt:
    cv.dnn.Net.getLayerNames() -> retval

cv::Ptr<cv::dnn::Layer> cv::dnn::Net::getLayer( cv::dnn::DictValue layerId )

AutoIt:
    cv.dnn.Net.getLayer( $layerId ) -> retval

void cv::dnn::Net::connect( std::string outPin
                            std::string inpPin )

AutoIt:
    cv.dnn.Net.connect( $outPin, $inpPin ) -> None

void cv::dnn::Net::setInputsNames( const std::vector<std::string>& inputBlobNames )

AutoIt:
    cv.dnn.Net.setInputsNames( $inputBlobNames ) -> None

void cv::dnn::Net::setInputShape( const std::string&      inputName
                                  const std::vector<int>& shape )

AutoIt:
    cv.dnn.Net.setInputShape( $inputName, $shape ) -> None

cv::Mat cv::dnn::Net::forward( const std::string& outputName = String() )

AutoIt:
    cv.dnn.Net.forward( [$outputName] ) -> retval

void cv::dnn::Net::forward( _OutputArray       outputBlobs
                            const std::string& outputName = String() )

AutoIt:
    cv.dnn.Net.forward( [$outputBlobs[, $outputName]] ) -> outputBlobs

void cv::dnn::Net::forward( _OutputArray                    outputBlobs
                            const std::vector<std::string>& outBlobNames )

AutoIt:
    cv.dnn.Net.forward( $outBlobNames[, $outputBlobs] ) -> outputBlobs

cv::AsyncArray cv::dnn::Net::forwardAsync( const std::string& outputName = String() )

AutoIt:
    cv.dnn.Net.forwardAsync( [$outputName] ) -> retval

void cv::dnn::Net::forwardAndRetrieve( std::vector<std::vector<cv::Mat>>& outputBlobs
                                       const std::vector<std::string>&    outBlobNames )

AutoIt:
    cv.dnn.Net.forwardAndRetrieve( $outBlobNames[, $outputBlobs] ) -> outputBlobs

cv::dnn::Net cv::dnn::Net::quantize( _InputArray calibData
                                     int         inputsDtype
                                     int         outputsDtype )

AutoIt:
    cv.dnn.Net.quantize( $calibData, $inputsDtype, $outputsDtype ) -> retval

void cv::dnn::Net::getInputDetails( std::vector<float>& scales
                                    std::vector<int>&   zeropoints )

AutoIt:
    cv.dnn.Net.getInputDetails( [$scales[, $zeropoints]] ) -> scales, zeropoints

void cv::dnn::Net::getOutputDetails( std::vector<float>& scales
                                     std::vector<int>&   zeropoints )

AutoIt:
    cv.dnn.Net.getOutputDetails( [$scales[, $zeropoints]] ) -> scales, zeropoints

void cv::dnn::Net::setHalideScheduler( const std::string& scheduler )

AutoIt:
    cv.dnn.Net.setHalideScheduler( $scheduler ) -> None

void cv::dnn::Net::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.Net.setPreferableBackend( $backendId ) -> None

void cv::dnn::Net::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.Net.setPreferableTarget( $targetId ) -> None

void cv::dnn::Net::setInput( _InputArray        blob
                             const std::string& name = ""
                             double             scalefactor = 1.0
                             const cv::Scalar&  mean = Scalar() )

AutoIt:
    cv.dnn.Net.setInput( $blob[, $name[, $scalefactor[, $mean]]] ) -> None

void cv::dnn::Net::setParam( cv::dnn::DictValue layer
                             int                numParam
                             const cv::Mat&     blob )

AutoIt:
    cv.dnn.Net.setParam( $layer, $numParam, $blob ) -> None

cv::Mat cv::dnn::Net::getParam( cv::dnn::DictValue layer
                                int                numParam = 0 )

AutoIt:
    cv.dnn.Net.getParam( $layer[, $numParam] ) -> retval

std::vector<int> cv::dnn::Net::getUnconnectedOutLayers()

AutoIt:
    cv.dnn.Net.getUnconnectedOutLayers() -> retval

std::vector<std::string> cv::dnn::Net::getUnconnectedOutLayersNames()

AutoIt:
    cv.dnn.Net.getUnconnectedOutLayersNames() -> retval

void cv::dnn::Net::getLayersShapes( const std::vector<std::vector<int>>&        netInputShapes
                                    std::vector<int>&                           layersIds
                                    std::vector<std::vector<std::vector<int>>>& inLayersShapes
                                    std::vector<std::vector<std::vector<int>>>& outLayersShapes )

AutoIt:
    cv.dnn.Net.getLayersShapes( $netInputShapes[, $layersIds[, $inLayersShapes[, $outLayersShapes]]] ) -> layersIds, inLayersShapes, outLayersShapes

void cv::dnn::Net::getLayersShapes( const std::vector<int>&                     netInputShape
                                    std::vector<int>&                           layersIds
                                    std::vector<std::vector<std::vector<int>>>& inLayersShapes
                                    std::vector<std::vector<std::vector<int>>>& outLayersShapes )

AutoIt:
    cv.dnn.Net.getLayersShapes( $netInputShape[, $layersIds[, $inLayersShapes[, $outLayersShapes]]] ) -> layersIds, inLayersShapes, outLayersShapes

int64 cv::dnn::Net::getFLOPS( const std::vector<std::vector<int>>& netInputShapes )

AutoIt:
    cv.dnn.Net.getFLOPS( $netInputShapes ) -> retval

int64 cv::dnn::Net::getFLOPS( const std::vector<int>& netInputShape )

AutoIt:
    cv.dnn.Net.getFLOPS( $netInputShape ) -> retval

int64 cv::dnn::Net::getFLOPS( const int                            layerId
                              const std::vector<std::vector<int>>& netInputShapes )

AutoIt:
    cv.dnn.Net.getFLOPS( $layerId, $netInputShapes ) -> retval

int64 cv::dnn::Net::getFLOPS( const int               layerId
                              const std::vector<int>& netInputShape )

AutoIt:
    cv.dnn.Net.getFLOPS( $layerId, $netInputShape ) -> retval

void cv::dnn::Net::getLayerTypes( std::vector<std::string>& layersTypes )

AutoIt:
    cv.dnn.Net.getLayerTypes( [$layersTypes] ) -> layersTypes

int cv::dnn::Net::getLayersCount( const std::string& layerType )

AutoIt:
    cv.dnn.Net.getLayersCount( $layerType ) -> retval

void cv::dnn::Net::getMemoryConsumption( const std::vector<int>& netInputShape
                                         size_t&                 weights
                                         size_t&                 blobs )

AutoIt:
    cv.dnn.Net.getMemoryConsumption( $netInputShape[, $weights[, $blobs]] ) -> weights, blobs

void cv::dnn::Net::getMemoryConsumption( const int                            layerId
                                         const std::vector<std::vector<int>>& netInputShapes
                                         size_t&                              weights
                                         size_t&                              blobs )

AutoIt:
    cv.dnn.Net.getMemoryConsumption( $layerId, $netInputShapes[, $weights[, $blobs]] ) -> weights, blobs

void cv::dnn::Net::getMemoryConsumption( const int               layerId
                                         const std::vector<int>& netInputShape
                                         size_t&                 weights
                                         size_t&                 blobs )

AutoIt:
    cv.dnn.Net.getMemoryConsumption( $layerId, $netInputShape[, $weights[, $blobs]] ) -> weights, blobs

void cv::dnn::Net::enableFusion( bool fusion )

AutoIt:
    cv.dnn.Net.enableFusion( $fusion ) -> None

int64 cv::dnn::Net::getPerfProfile( std::vector<double>& timings )

AutoIt:
    cv.dnn.Net.getPerfProfile( [$timings] ) -> retval, timings

static cv::dnn::Model cv::dnn::Model::create( const std::string& model
                                              const std::string& config = "" )

AutoIt:
    cv.dnn.Model.create( $model[, $config] ) -> <cv.dnn.Model object>

static cv::dnn::Model cv::dnn::Model::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.Model.create( $network ) -> <cv.dnn.Model object>

cv::dnn::Model cv::dnn::Model::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.Model.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::Model::setInputSize( int width
                                             int height )

AutoIt:
    cv.dnn.Model.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::Model::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.Model.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::Model::setInputScale( double scale )

AutoIt:
    cv.dnn.Model.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::Model::setInputCrop( bool crop )

AutoIt:
    cv.dnn.Model.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::Model::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.Model.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::Model::setInputParams( double            scale = 1.0
                                     const cv::Size&   size = Size()
                                     const cv::Scalar& mean = Scalar()
                                     bool              swapRB = false
                                     bool              crop = false )

AutoIt:
    cv.dnn.Model.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::Model::predict( _InputArray  frame
                              _OutputArray outs )

AutoIt:
    cv.dnn.Model.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::Model::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.Model.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::Model::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.Model.setPreferableTarget( $targetId ) -> retval

static cv::dnn::ClassificationModel cv::dnn::ClassificationModel::create( const std::string& model
                                                                          const std::string& config = "" )

AutoIt:
    cv.dnn.ClassificationModel.create( $model[, $config] ) -> <cv.dnn.ClassificationModel object>

static cv::dnn::ClassificationModel cv::dnn::ClassificationModel::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.ClassificationModel.create( $network ) -> <cv.dnn.ClassificationModel object>

void cv::dnn::ClassificationModel::classify( _InputArray frame
                                             int&        classId
                                             float&      conf )

AutoIt:
    cv.dnn.ClassificationModel.classify( $frame[, $classId[, $conf]] ) -> classId, conf

cv::dnn::Model cv::dnn::ClassificationModel::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.ClassificationModel.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::ClassificationModel::setInputSize( int width
                                                           int height )

AutoIt:
    cv.dnn.ClassificationModel.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::ClassificationModel::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.ClassificationModel.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::ClassificationModel::setInputScale( double scale )

AutoIt:
    cv.dnn.ClassificationModel.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::ClassificationModel::setInputCrop( bool crop )

AutoIt:
    cv.dnn.ClassificationModel.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::ClassificationModel::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.ClassificationModel.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::ClassificationModel::setInputParams( double            scale = 1.0
                                                   const cv::Size&   size = Size()
                                                   const cv::Scalar& mean = Scalar()
                                                   bool              swapRB = false
                                                   bool              crop = false )

AutoIt:
    cv.dnn.ClassificationModel.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::ClassificationModel::predict( _InputArray  frame
                                            _OutputArray outs )

AutoIt:
    cv.dnn.ClassificationModel.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::ClassificationModel::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.ClassificationModel.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::ClassificationModel::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.ClassificationModel.setPreferableTarget( $targetId ) -> retval

static cv::dnn::KeypointsModel cv::dnn::KeypointsModel::create( const std::string& model
                                                                const std::string& config = "" )

AutoIt:
    cv.dnn.KeypointsModel.create( $model[, $config] ) -> <cv.dnn.KeypointsModel object>

static cv::dnn::KeypointsModel cv::dnn::KeypointsModel::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.KeypointsModel.create( $network ) -> <cv.dnn.KeypointsModel object>

std::vector<cv::Point2f> cv::dnn::KeypointsModel::estimate( _InputArray frame
                                                            float       thresh = 0.5 )

AutoIt:
    cv.dnn.KeypointsModel.estimate( $frame[, $thresh] ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.KeypointsModel.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setInputSize( int width
                                                      int height )

AutoIt:
    cv.dnn.KeypointsModel.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.KeypointsModel.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setInputScale( double scale )

AutoIt:
    cv.dnn.KeypointsModel.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setInputCrop( bool crop )

AutoIt:
    cv.dnn.KeypointsModel.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.KeypointsModel.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::KeypointsModel::setInputParams( double            scale = 1.0
                                              const cv::Size&   size = Size()
                                              const cv::Scalar& mean = Scalar()
                                              bool              swapRB = false
                                              bool              crop = false )

AutoIt:
    cv.dnn.KeypointsModel.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::KeypointsModel::predict( _InputArray  frame
                                       _OutputArray outs )

AutoIt:
    cv.dnn.KeypointsModel.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::KeypointsModel::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.KeypointsModel.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::KeypointsModel::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.KeypointsModel.setPreferableTarget( $targetId ) -> retval

static cv::dnn::SegmentationModel cv::dnn::SegmentationModel::create( const std::string& model
                                                                      const std::string& config = "" )

AutoIt:
    cv.dnn.SegmentationModel.create( $model[, $config] ) -> <cv.dnn.SegmentationModel object>

static cv::dnn::SegmentationModel cv::dnn::SegmentationModel::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.SegmentationModel.create( $network ) -> <cv.dnn.SegmentationModel object>

void cv::dnn::SegmentationModel::segment( _InputArray  frame
                                          _OutputArray mask )

AutoIt:
    cv.dnn.SegmentationModel.segment( $frame[, $mask] ) -> mask

cv::dnn::Model cv::dnn::SegmentationModel::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.SegmentationModel.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::SegmentationModel::setInputSize( int width
                                                         int height )

AutoIt:
    cv.dnn.SegmentationModel.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::SegmentationModel::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.SegmentationModel.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::SegmentationModel::setInputScale( double scale )

AutoIt:
    cv.dnn.SegmentationModel.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::SegmentationModel::setInputCrop( bool crop )

AutoIt:
    cv.dnn.SegmentationModel.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::SegmentationModel::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.SegmentationModel.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::SegmentationModel::setInputParams( double            scale = 1.0
                                                 const cv::Size&   size = Size()
                                                 const cv::Scalar& mean = Scalar()
                                                 bool              swapRB = false
                                                 bool              crop = false )

AutoIt:
    cv.dnn.SegmentationModel.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::SegmentationModel::predict( _InputArray  frame
                                          _OutputArray outs )

AutoIt:
    cv.dnn.SegmentationModel.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::SegmentationModel::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.SegmentationModel.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::SegmentationModel::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.SegmentationModel.setPreferableTarget( $targetId ) -> retval

static cv::dnn::DetectionModel cv::dnn::DetectionModel::create( const std::string& model
                                                                const std::string& config = "" )

AutoIt:
    cv.dnn.DetectionModel.create( $model[, $config] ) -> <cv.dnn.DetectionModel object>

static cv::dnn::DetectionModel cv::dnn::DetectionModel::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.DetectionModel.create( $network ) -> <cv.dnn.DetectionModel object>

cv::dnn::DetectionModel cv::dnn::DetectionModel::setNmsAcrossClasses( bool value )

AutoIt:
    cv.dnn.DetectionModel.setNmsAcrossClasses( $value ) -> retval

bool cv::dnn::DetectionModel::getNmsAcrossClasses()

AutoIt:
    cv.dnn.DetectionModel.getNmsAcrossClasses() -> retval

void cv::dnn::DetectionModel::detect( _InputArray            frame
                                      std::vector<int>&      classIds
                                      std::vector<float>&    confidences
                                      std::vector<cv::Rect>& boxes
                                      float                  confThreshold = 0.5f
                                      float                  nmsThreshold = 0.0f )

AutoIt:
    cv.dnn.DetectionModel.detect( $frame[, $confThreshold[, $nmsThreshold[, $classIds[, $confidences[, $boxes]]]]] ) -> classIds, confidences, boxes

cv::dnn::Model cv::dnn::DetectionModel::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.DetectionModel.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::DetectionModel::setInputSize( int width
                                                      int height )

AutoIt:
    cv.dnn.DetectionModel.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::DetectionModel::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.DetectionModel.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::DetectionModel::setInputScale( double scale )

AutoIt:
    cv.dnn.DetectionModel.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::DetectionModel::setInputCrop( bool crop )

AutoIt:
    cv.dnn.DetectionModel.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::DetectionModel::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.DetectionModel.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::DetectionModel::setInputParams( double            scale = 1.0
                                              const cv::Size&   size = Size()
                                              const cv::Scalar& mean = Scalar()
                                              bool              swapRB = false
                                              bool              crop = false )

AutoIt:
    cv.dnn.DetectionModel.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::DetectionModel::predict( _InputArray  frame
                                       _OutputArray outs )

AutoIt:
    cv.dnn.DetectionModel.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::DetectionModel::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.DetectionModel.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::DetectionModel::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.DetectionModel.setPreferableTarget( $targetId ) -> retval

static cv::dnn::TextRecognitionModel cv::dnn::TextRecognitionModel::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.TextRecognitionModel.create( $network ) -> <cv.dnn.TextRecognitionModel object>

static cv::dnn::TextRecognitionModel cv::dnn::TextRecognitionModel::create( const std::string& model
                                                                            const std::string& config = "" )

AutoIt:
    cv.dnn.TextRecognitionModel.create( $model[, $config] ) -> <cv.dnn.TextRecognitionModel object>

cv::dnn::TextRecognitionModel cv::dnn::TextRecognitionModel::setDecodeType( const std::string& decodeType )

AutoIt:
    cv.dnn.TextRecognitionModel.setDecodeType( $decodeType ) -> retval

std::string cv::dnn::TextRecognitionModel::getDecodeType()

AutoIt:
    cv.dnn.TextRecognitionModel.getDecodeType() -> retval

cv::dnn::TextRecognitionModel cv::dnn::TextRecognitionModel::setDecodeOptsCTCPrefixBeamSearch( int beamSize
                                                                                               int vocPruneSize = 0 )

AutoIt:
    cv.dnn.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch( $beamSize[, $vocPruneSize] ) -> retval

cv::dnn::TextRecognitionModel cv::dnn::TextRecognitionModel::setVocabulary( const std::vector<std::string>& vocabulary )

AutoIt:
    cv.dnn.TextRecognitionModel.setVocabulary( $vocabulary ) -> retval

std::vector<std::string> cv::dnn::TextRecognitionModel::getVocabulary()

AutoIt:
    cv.dnn.TextRecognitionModel.getVocabulary() -> retval

std::string cv::dnn::TextRecognitionModel::recognize( _InputArray frame )

AutoIt:
    cv.dnn.TextRecognitionModel.recognize( $frame ) -> retval

void cv::dnn::TextRecognitionModel::recognize( _InputArray               frame
                                               _InputArray               roiRects
                                               std::vector<std::string>& results )

AutoIt:
    cv.dnn.TextRecognitionModel.recognize( $frame, $roiRects[, $results] ) -> results

cv::dnn::Model cv::dnn::TextRecognitionModel::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::TextRecognitionModel::setInputSize( int width
                                                            int height )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::TextRecognitionModel::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::TextRecognitionModel::setInputScale( double scale )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::TextRecognitionModel::setInputCrop( bool crop )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::TextRecognitionModel::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::TextRecognitionModel::setInputParams( double            scale = 1.0
                                                    const cv::Size&   size = Size()
                                                    const cv::Scalar& mean = Scalar()
                                                    bool              swapRB = false
                                                    bool              crop = false )

AutoIt:
    cv.dnn.TextRecognitionModel.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::TextRecognitionModel::predict( _InputArray  frame
                                             _OutputArray outs )

AutoIt:
    cv.dnn.TextRecognitionModel.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::TextRecognitionModel::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.TextRecognitionModel.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::TextRecognitionModel::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.TextRecognitionModel.setPreferableTarget( $targetId ) -> retval

void cv::dnn::TextDetectionModel::detect( _InputArray                          frame
                                          std::vector<std::vector<cv::Point>>& detections
                                          std::vector<float>&                  confidences )

AutoIt:
    cv.dnn.TextDetectionModel.detect( $frame[, $detections[, $confidences]] ) -> detections, confidences

void cv::dnn::TextDetectionModel::detect( _InputArray                          frame
                                          std::vector<std::vector<cv::Point>>& detections )

AutoIt:
    cv.dnn.TextDetectionModel.detect( $frame[, $detections] ) -> detections

void cv::dnn::TextDetectionModel::detectTextRectangles( _InputArray                   frame
                                                        std::vector<cv::RotatedRect>& detections
                                                        std::vector<float>&           confidences )

AutoIt:
    cv.dnn.TextDetectionModel.detectTextRectangles( $frame[, $detections[, $confidences]] ) -> detections, confidences

void cv::dnn::TextDetectionModel::detectTextRectangles( _InputArray                   frame
                                                        std::vector<cv::RotatedRect>& detections )

AutoIt:
    cv.dnn.TextDetectionModel.detectTextRectangles( $frame[, $detections] ) -> detections

cv::dnn::Model cv::dnn::TextDetectionModel::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.TextDetectionModel.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel::setInputSize( int width
                                                          int height )

AutoIt:
    cv.dnn.TextDetectionModel.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.TextDetectionModel.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel::setInputScale( double scale )

AutoIt:
    cv.dnn.TextDetectionModel.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel::setInputCrop( bool crop )

AutoIt:
    cv.dnn.TextDetectionModel.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.TextDetectionModel.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::TextDetectionModel::setInputParams( double            scale = 1.0
                                                  const cv::Size&   size = Size()
                                                  const cv::Scalar& mean = Scalar()
                                                  bool              swapRB = false
                                                  bool              crop = false )

AutoIt:
    cv.dnn.TextDetectionModel.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::TextDetectionModel::predict( _InputArray  frame
                                           _OutputArray outs )

AutoIt:
    cv.dnn.TextDetectionModel.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::TextDetectionModel::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.TextDetectionModel.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.TextDetectionModel.setPreferableTarget( $targetId ) -> retval

static cv::dnn::TextDetectionModel_EAST cv::dnn::TextDetectionModel_EAST::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.create( $network ) -> <cv.dnn.TextDetectionModel_EAST object>

static cv::dnn::TextDetectionModel_EAST cv::dnn::TextDetectionModel_EAST::create( const std::string& model
                                                                                  const std::string& config = "" )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.create( $model[, $config] ) -> <cv.dnn.TextDetectionModel_EAST object>

cv::dnn::TextDetectionModel_EAST cv::dnn::TextDetectionModel_EAST::setConfidenceThreshold( float confThreshold )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setConfidenceThreshold( $confThreshold ) -> retval

float cv::dnn::TextDetectionModel_EAST::getConfidenceThreshold()

AutoIt:
    cv.dnn.TextDetectionModel_EAST.getConfidenceThreshold() -> retval

cv::dnn::TextDetectionModel_EAST cv::dnn::TextDetectionModel_EAST::setNMSThreshold( float nmsThreshold )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setNMSThreshold( $nmsThreshold ) -> retval

float cv::dnn::TextDetectionModel_EAST::getNMSThreshold()

AutoIt:
    cv.dnn.TextDetectionModel_EAST.getNMSThreshold() -> retval

void cv::dnn::TextDetectionModel_EAST::detect( _InputArray                          frame
                                               std::vector<std::vector<cv::Point>>& detections
                                               std::vector<float>&                  confidences )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.detect( $frame[, $detections[, $confidences]] ) -> detections, confidences

void cv::dnn::TextDetectionModel_EAST::detect( _InputArray                          frame
                                               std::vector<std::vector<cv::Point>>& detections )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.detect( $frame[, $detections] ) -> detections

void cv::dnn::TextDetectionModel_EAST::detectTextRectangles( _InputArray                   frame
                                                             std::vector<cv::RotatedRect>& detections
                                                             std::vector<float>&           confidences )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.detectTextRectangles( $frame[, $detections[, $confidences]] ) -> detections, confidences

void cv::dnn::TextDetectionModel_EAST::detectTextRectangles( _InputArray                   frame
                                                             std::vector<cv::RotatedRect>& detections )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.detectTextRectangles( $frame[, $detections] ) -> detections

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setInputSize( int width
                                                               int height )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setInputScale( double scale )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setInputCrop( bool crop )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::TextDetectionModel_EAST::setInputParams( double            scale = 1.0
                                                       const cv::Size&   size = Size()
                                                       const cv::Scalar& mean = Scalar()
                                                       bool              swapRB = false
                                                       bool              crop = false )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::TextDetectionModel_EAST::predict( _InputArray  frame
                                                _OutputArray outs )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_EAST::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.TextDetectionModel_EAST.setPreferableTarget( $targetId ) -> retval

static cv::dnn::TextDetectionModel_DB cv::dnn::TextDetectionModel_DB::create( const cv::dnn::Net& network )

AutoIt:
    cv.dnn.TextDetectionModel_DB.create( $network ) -> <cv.dnn.TextDetectionModel_DB object>

static cv::dnn::TextDetectionModel_DB cv::dnn::TextDetectionModel_DB::create( const std::string& model
                                                                              const std::string& config = "" )

AutoIt:
    cv.dnn.TextDetectionModel_DB.create( $model[, $config] ) -> <cv.dnn.TextDetectionModel_DB object>

cv::dnn::TextDetectionModel_DB cv::dnn::TextDetectionModel_DB::setBinaryThreshold( float binaryThreshold )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setBinaryThreshold( $binaryThreshold ) -> retval

float cv::dnn::TextDetectionModel_DB::getBinaryThreshold()

AutoIt:
    cv.dnn.TextDetectionModel_DB.getBinaryThreshold() -> retval

cv::dnn::TextDetectionModel_DB cv::dnn::TextDetectionModel_DB::setPolygonThreshold( float polygonThreshold )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setPolygonThreshold( $polygonThreshold ) -> retval

float cv::dnn::TextDetectionModel_DB::getPolygonThreshold()

AutoIt:
    cv.dnn.TextDetectionModel_DB.getPolygonThreshold() -> retval

cv::dnn::TextDetectionModel_DB cv::dnn::TextDetectionModel_DB::setUnclipRatio( double unclipRatio )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setUnclipRatio( $unclipRatio ) -> retval

double cv::dnn::TextDetectionModel_DB::getUnclipRatio()

AutoIt:
    cv.dnn.TextDetectionModel_DB.getUnclipRatio() -> retval

cv::dnn::TextDetectionModel_DB cv::dnn::TextDetectionModel_DB::setMaxCandidates( int maxCandidates )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setMaxCandidates( $maxCandidates ) -> retval

int cv::dnn::TextDetectionModel_DB::getMaxCandidates()

AutoIt:
    cv.dnn.TextDetectionModel_DB.getMaxCandidates() -> retval

void cv::dnn::TextDetectionModel_DB::detect( _InputArray                          frame
                                             std::vector<std::vector<cv::Point>>& detections
                                             std::vector<float>&                  confidences )

AutoIt:
    cv.dnn.TextDetectionModel_DB.detect( $frame[, $detections[, $confidences]] ) -> detections, confidences

void cv::dnn::TextDetectionModel_DB::detect( _InputArray                          frame
                                             std::vector<std::vector<cv::Point>>& detections )

AutoIt:
    cv.dnn.TextDetectionModel_DB.detect( $frame[, $detections] ) -> detections

void cv::dnn::TextDetectionModel_DB::detectTextRectangles( _InputArray                   frame
                                                           std::vector<cv::RotatedRect>& detections
                                                           std::vector<float>&           confidences )

AutoIt:
    cv.dnn.TextDetectionModel_DB.detectTextRectangles( $frame[, $detections[, $confidences]] ) -> detections, confidences

void cv::dnn::TextDetectionModel_DB::detectTextRectangles( _InputArray                   frame
                                                           std::vector<cv::RotatedRect>& detections )

AutoIt:
    cv.dnn.TextDetectionModel_DB.detectTextRectangles( $frame[, $detections] ) -> detections

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setInputSize( const cv::Size& size )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputSize( $size ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setInputSize( int width
                                                             int height )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputSize( $width, $height ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setInputMean( const cv::Scalar& mean )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputMean( $mean ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setInputScale( double scale )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputScale( $scale ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setInputCrop( bool crop )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputCrop( $crop ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setInputSwapRB( bool swapRB )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputSwapRB( $swapRB ) -> retval

void cv::dnn::TextDetectionModel_DB::setInputParams( double            scale = 1.0
                                                     const cv::Size&   size = Size()
                                                     const cv::Scalar& mean = Scalar()
                                                     bool              swapRB = false
                                                     bool              crop = false )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setInputParams( [$scale[, $size[, $mean[, $swapRB[, $crop]]]]] ) -> None

void cv::dnn::TextDetectionModel_DB::predict( _InputArray  frame
                                              _OutputArray outs )

AutoIt:
    cv.dnn.TextDetectionModel_DB.predict( $frame[, $outs] ) -> outs

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setPreferableBackend( int backendId )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setPreferableBackend( $backendId ) -> retval

cv::dnn::Model cv::dnn::TextDetectionModel_DB::setPreferableTarget( int targetId )

AutoIt:
    cv.dnn.TextDetectionModel_DB.setPreferableTarget( $targetId ) -> retval

void cv::Feature2D::detect( _InputArray                image
                            std::vector<cv::KeyPoint>& keypoints
                            _InputArray                mask = noArray() )

AutoIt:
    cv.Feature2D.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::Feature2D::detect( _InputArray                             images
                            std::vector<std::vector<cv::KeyPoint>>& keypoints
                            _InputArray                             masks = noArray() )

AutoIt:
    cv.Feature2D.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::Feature2D::compute( _InputArray                image
                             std::vector<cv::KeyPoint>& keypoints
                             _OutputArray               descriptors )

AutoIt:
    cv.Feature2D.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::Feature2D::compute( _InputArray                             images
                             std::vector<std::vector<cv::KeyPoint>>& keypoints
                             _OutputArray                            descriptors )

AutoIt:
    cv.Feature2D.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::Feature2D::detectAndCompute( _InputArray                image
                                      _InputArray                mask
                                      std::vector<cv::KeyPoint>& keypoints
                                      _OutputArray               descriptors
                                      bool                       useProvidedKeypoints = false )

AutoIt:
    cv.Feature2D.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::Feature2D::descriptorSize()

AutoIt:
    cv.Feature2D.descriptorSize() -> retval

int cv::Feature2D::descriptorType()

AutoIt:
    cv.Feature2D.descriptorType() -> retval

int cv::Feature2D::defaultNorm()

AutoIt:
    cv.Feature2D.defaultNorm() -> retval

void cv::Feature2D::write( const std::string& fileName )

AutoIt:
    cv.Feature2D.write( $fileName ) -> None

void cv::Feature2D::write( const cv::Ptr<cv::FileStorage>& fs
                           const std::string&              name = String() )

AutoIt:
    cv.Feature2D.write( $fs[, $name] ) -> None

void cv::Feature2D::read( const std::string& fileName )

AutoIt:
    cv.Feature2D.read( $fileName ) -> None

void cv::Feature2D::read( const cv::FileNode& arg1 )

AutoIt:
    cv.Feature2D.read( $arg1 ) -> None

bool cv::Feature2D::empty()

AutoIt:
    cv.Feature2D.empty() -> retval

std::string cv::Feature2D::getDefaultName()

AutoIt:
    cv.Feature2D.getDefaultName() -> retval

void cv::Feature2D::clear()

AutoIt:
    cv.Feature2D.clear() -> None

void cv::Feature2D::save( const std::string& filename )

AutoIt:
    cv.Feature2D.save( $filename ) -> None

static cv::Ptr<cv::AffineFeature> cv::AffineFeature::create( const cv::Ptr<cv::Feature2D>& backend
                                                             int                           maxTilt = 5
                                                             int                           minTilt = 0
                                                             float                         tiltStep = 1.4142135623730951f
                                                             float                         rotateStepBase = 72 )

AutoIt:
    cv.AffineFeature.create( $backend[, $maxTilt[, $minTilt[, $tiltStep[, $rotateStepBase]]]] ) -> retval

void cv::AffineFeature::setViewParams( const std::vector<float>& tilts
                                       const std::vector<float>& rolls )

AutoIt:
    cv.AffineFeature.setViewParams( $tilts, $rolls ) -> None

void cv::AffineFeature::getViewParams( std::vector<float>& tilts
                                       std::vector<float>& rolls )

AutoIt:
    cv.AffineFeature.getViewParams( $tilts, $rolls ) -> None

std::string cv::AffineFeature::getDefaultName()

AutoIt:
    cv.AffineFeature.getDefaultName() -> retval

void cv::AffineFeature::detect( _InputArray                image
                                std::vector<cv::KeyPoint>& keypoints
                                _InputArray                mask = noArray() )

AutoIt:
    cv.AffineFeature.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::AffineFeature::detect( _InputArray                             images
                                std::vector<std::vector<cv::KeyPoint>>& keypoints
                                _InputArray                             masks = noArray() )

AutoIt:
    cv.AffineFeature.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::AffineFeature::compute( _InputArray                image
                                 std::vector<cv::KeyPoint>& keypoints
                                 _OutputArray               descriptors )

AutoIt:
    cv.AffineFeature.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::AffineFeature::compute( _InputArray                             images
                                 std::vector<std::vector<cv::KeyPoint>>& keypoints
                                 _OutputArray                            descriptors )

AutoIt:
    cv.AffineFeature.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::AffineFeature::detectAndCompute( _InputArray                image
                                          _InputArray                mask
                                          std::vector<cv::KeyPoint>& keypoints
                                          _OutputArray               descriptors
                                          bool                       useProvidedKeypoints = false )

AutoIt:
    cv.AffineFeature.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::AffineFeature::descriptorSize()

AutoIt:
    cv.AffineFeature.descriptorSize() -> retval

int cv::AffineFeature::descriptorType()

AutoIt:
    cv.AffineFeature.descriptorType() -> retval

int cv::AffineFeature::defaultNorm()

AutoIt:
    cv.AffineFeature.defaultNorm() -> retval

void cv::AffineFeature::write( const std::string& fileName )

AutoIt:
    cv.AffineFeature.write( $fileName ) -> None

void cv::AffineFeature::write( const cv::Ptr<cv::FileStorage>& fs
                               const std::string&              name = String() )

AutoIt:
    cv.AffineFeature.write( $fs[, $name] ) -> None

void cv::AffineFeature::read( const std::string& fileName )

AutoIt:
    cv.AffineFeature.read( $fileName ) -> None

void cv::AffineFeature::read( const cv::FileNode& arg1 )

AutoIt:
    cv.AffineFeature.read( $arg1 ) -> None

bool cv::AffineFeature::empty()

AutoIt:
    cv.AffineFeature.empty() -> retval

void cv::AffineFeature::clear()

AutoIt:
    cv.AffineFeature.clear() -> None

void cv::AffineFeature::save( const std::string& filename )

AutoIt:
    cv.AffineFeature.save( $filename ) -> None

static cv::Ptr<cv::SIFT> cv::SIFT::create( int    nfeatures = 0
                                           int    nOctaveLayers = 3
                                           double contrastThreshold = 0.04
                                           double edgeThreshold = 10
                                           double sigma = 1.6 )

AutoIt:
    cv.SIFT.create( [$nfeatures[, $nOctaveLayers[, $contrastThreshold[, $edgeThreshold[, $sigma]]]]] ) -> retval

static cv::Ptr<cv::SIFT> cv::SIFT::create( int    nfeatures
                                           int    nOctaveLayers
                                           double contrastThreshold
                                           double edgeThreshold
                                           double sigma
                                           int    descriptorType )

AutoIt:
    cv.SIFT.create( $nfeatures, $nOctaveLayers, $contrastThreshold, $edgeThreshold, $sigma, $descriptorType ) -> retval

std::string cv::SIFT::getDefaultName()

AutoIt:
    cv.SIFT.getDefaultName() -> retval

void cv::SIFT::detect( _InputArray                image
                       std::vector<cv::KeyPoint>& keypoints
                       _InputArray                mask = noArray() )

AutoIt:
    cv.SIFT.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::SIFT::detect( _InputArray                             images
                       std::vector<std::vector<cv::KeyPoint>>& keypoints
                       _InputArray                             masks = noArray() )

AutoIt:
    cv.SIFT.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::SIFT::compute( _InputArray                image
                        std::vector<cv::KeyPoint>& keypoints
                        _OutputArray               descriptors )

AutoIt:
    cv.SIFT.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::SIFT::compute( _InputArray                             images
                        std::vector<std::vector<cv::KeyPoint>>& keypoints
                        _OutputArray                            descriptors )

AutoIt:
    cv.SIFT.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::SIFT::detectAndCompute( _InputArray                image
                                 _InputArray                mask
                                 std::vector<cv::KeyPoint>& keypoints
                                 _OutputArray               descriptors
                                 bool                       useProvidedKeypoints = false )

AutoIt:
    cv.SIFT.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::SIFT::descriptorSize()

AutoIt:
    cv.SIFT.descriptorSize() -> retval

int cv::SIFT::descriptorType()

AutoIt:
    cv.SIFT.descriptorType() -> retval

int cv::SIFT::defaultNorm()

AutoIt:
    cv.SIFT.defaultNorm() -> retval

void cv::SIFT::write( const std::string& fileName )

AutoIt:
    cv.SIFT.write( $fileName ) -> None

void cv::SIFT::write( const cv::Ptr<cv::FileStorage>& fs
                      const std::string&              name = String() )

AutoIt:
    cv.SIFT.write( $fs[, $name] ) -> None

void cv::SIFT::read( const std::string& fileName )

AutoIt:
    cv.SIFT.read( $fileName ) -> None

void cv::SIFT::read( const cv::FileNode& arg1 )

AutoIt:
    cv.SIFT.read( $arg1 ) -> None

bool cv::SIFT::empty()

AutoIt:
    cv.SIFT.empty() -> retval

void cv::SIFT::clear()

AutoIt:
    cv.SIFT.clear() -> None

void cv::SIFT::save( const std::string& filename )

AutoIt:
    cv.SIFT.save( $filename ) -> None

static cv::Ptr<cv::BRISK> cv::BRISK::create( int   thresh = 30
                                             int   octaves = 3
                                             float patternScale = 1.0f )

AutoIt:
    cv.BRISK.create( [$thresh[, $octaves[, $patternScale]]] ) -> retval

static cv::Ptr<cv::BRISK> cv::BRISK::create( const std::vector<float>& radiusList
                                             const std::vector<int>&   numberList
                                             float                     dMax = 5.85f
                                             float                     dMin = 8.2f
                                             const std::vector<int>&   indexChange = std::vector<int>() )

AutoIt:
    cv.BRISK.create( $radiusList, $numberList[, $dMax[, $dMin[, $indexChange]]] ) -> retval

static cv::Ptr<cv::BRISK> cv::BRISK::create( int                       thresh
                                             int                       octaves
                                             const std::vector<float>& radiusList
                                             const std::vector<int>&   numberList
                                             float                     dMax = 5.85f
                                             float                     dMin = 8.2f
                                             const std::vector<int>&   indexChange = std::vector<int>() )

AutoIt:
    cv.BRISK.create( $thresh, $octaves, $radiusList, $numberList[, $dMax[, $dMin[, $indexChange]]] ) -> retval

std::string cv::BRISK::getDefaultName()

AutoIt:
    cv.BRISK.getDefaultName() -> retval

void cv::BRISK::setThreshold( int threshold )

AutoIt:
    cv.BRISK.setThreshold( $threshold ) -> None

int cv::BRISK::getThreshold()

AutoIt:
    cv.BRISK.getThreshold() -> retval

void cv::BRISK::setOctaves( int octaves )

AutoIt:
    cv.BRISK.setOctaves( $octaves ) -> None

int cv::BRISK::getOctaves()

AutoIt:
    cv.BRISK.getOctaves() -> retval

void cv::BRISK::detect( _InputArray                image
                        std::vector<cv::KeyPoint>& keypoints
                        _InputArray                mask = noArray() )

AutoIt:
    cv.BRISK.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::BRISK::detect( _InputArray                             images
                        std::vector<std::vector<cv::KeyPoint>>& keypoints
                        _InputArray                             masks = noArray() )

AutoIt:
    cv.BRISK.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::BRISK::compute( _InputArray                image
                         std::vector<cv::KeyPoint>& keypoints
                         _OutputArray               descriptors )

AutoIt:
    cv.BRISK.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::BRISK::compute( _InputArray                             images
                         std::vector<std::vector<cv::KeyPoint>>& keypoints
                         _OutputArray                            descriptors )

AutoIt:
    cv.BRISK.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::BRISK::detectAndCompute( _InputArray                image
                                  _InputArray                mask
                                  std::vector<cv::KeyPoint>& keypoints
                                  _OutputArray               descriptors
                                  bool                       useProvidedKeypoints = false )

AutoIt:
    cv.BRISK.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::BRISK::descriptorSize()

AutoIt:
    cv.BRISK.descriptorSize() -> retval

int cv::BRISK::descriptorType()

AutoIt:
    cv.BRISK.descriptorType() -> retval

int cv::BRISK::defaultNorm()

AutoIt:
    cv.BRISK.defaultNorm() -> retval

void cv::BRISK::write( const std::string& fileName )

AutoIt:
    cv.BRISK.write( $fileName ) -> None

void cv::BRISK::write( const cv::Ptr<cv::FileStorage>& fs
                       const std::string&              name = String() )

AutoIt:
    cv.BRISK.write( $fs[, $name] ) -> None

void cv::BRISK::read( const std::string& fileName )

AutoIt:
    cv.BRISK.read( $fileName ) -> None

void cv::BRISK::read( const cv::FileNode& arg1 )

AutoIt:
    cv.BRISK.read( $arg1 ) -> None

bool cv::BRISK::empty()

AutoIt:
    cv.BRISK.empty() -> retval

void cv::BRISK::clear()

AutoIt:
    cv.BRISK.clear() -> None

void cv::BRISK::save( const std::string& filename )

AutoIt:
    cv.BRISK.save( $filename ) -> None

static cv::Ptr<cv::ORB> cv::ORB::create( int   nfeatures = 500
                                         float scaleFactor = 1.2f
                                         int   nlevels = 8
                                         int   edgeThreshold = 31
                                         int   firstLevel = 0
                                         int   WTA_K = 2
                                         int   scoreType = ORB::HARRIS_SCORE
                                         int   patchSize = 31
                                         int   fastThreshold = 20 )

AutoIt:
    cv.ORB.create( [$nfeatures[, $scaleFactor[, $nlevels[, $edgeThreshold[, $firstLevel[, $WTA_K[, $scoreType[, $patchSize[, $fastThreshold]]]]]]]]] ) -> retval

void cv::ORB::setMaxFeatures( int maxFeatures )

AutoIt:
    cv.ORB.setMaxFeatures( $maxFeatures ) -> None

int cv::ORB::getMaxFeatures()

AutoIt:
    cv.ORB.getMaxFeatures() -> retval

void cv::ORB::setScaleFactor( double scaleFactor )

AutoIt:
    cv.ORB.setScaleFactor( $scaleFactor ) -> None

double cv::ORB::getScaleFactor()

AutoIt:
    cv.ORB.getScaleFactor() -> retval

void cv::ORB::setNLevels( int nlevels )

AutoIt:
    cv.ORB.setNLevels( $nlevels ) -> None

int cv::ORB::getNLevels()

AutoIt:
    cv.ORB.getNLevels() -> retval

void cv::ORB::setEdgeThreshold( int edgeThreshold )

AutoIt:
    cv.ORB.setEdgeThreshold( $edgeThreshold ) -> None

int cv::ORB::getEdgeThreshold()

AutoIt:
    cv.ORB.getEdgeThreshold() -> retval

void cv::ORB::setFirstLevel( int firstLevel )

AutoIt:
    cv.ORB.setFirstLevel( $firstLevel ) -> None

int cv::ORB::getFirstLevel()

AutoIt:
    cv.ORB.getFirstLevel() -> retval

void cv::ORB::setWTA_K( int wta_k )

AutoIt:
    cv.ORB.setWTA_K( $wta_k ) -> None

int cv::ORB::getWTA_K()

AutoIt:
    cv.ORB.getWTA_K() -> retval

void cv::ORB::setScoreType( int scoreType )

AutoIt:
    cv.ORB.setScoreType( $scoreType ) -> None

int cv::ORB::getScoreType()

AutoIt:
    cv.ORB.getScoreType() -> retval

void cv::ORB::setPatchSize( int patchSize )

AutoIt:
    cv.ORB.setPatchSize( $patchSize ) -> None

int cv::ORB::getPatchSize()

AutoIt:
    cv.ORB.getPatchSize() -> retval

void cv::ORB::setFastThreshold( int fastThreshold )

AutoIt:
    cv.ORB.setFastThreshold( $fastThreshold ) -> None

int cv::ORB::getFastThreshold()

AutoIt:
    cv.ORB.getFastThreshold() -> retval

std::string cv::ORB::getDefaultName()

AutoIt:
    cv.ORB.getDefaultName() -> retval

void cv::ORB::detect( _InputArray                image
                      std::vector<cv::KeyPoint>& keypoints
                      _InputArray                mask = noArray() )

AutoIt:
    cv.ORB.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::ORB::detect( _InputArray                             images
                      std::vector<std::vector<cv::KeyPoint>>& keypoints
                      _InputArray                             masks = noArray() )

AutoIt:
    cv.ORB.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::ORB::compute( _InputArray                image
                       std::vector<cv::KeyPoint>& keypoints
                       _OutputArray               descriptors )

AutoIt:
    cv.ORB.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::ORB::compute( _InputArray                             images
                       std::vector<std::vector<cv::KeyPoint>>& keypoints
                       _OutputArray                            descriptors )

AutoIt:
    cv.ORB.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::ORB::detectAndCompute( _InputArray                image
                                _InputArray                mask
                                std::vector<cv::KeyPoint>& keypoints
                                _OutputArray               descriptors
                                bool                       useProvidedKeypoints = false )

AutoIt:
    cv.ORB.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::ORB::descriptorSize()

AutoIt:
    cv.ORB.descriptorSize() -> retval

int cv::ORB::descriptorType()

AutoIt:
    cv.ORB.descriptorType() -> retval

int cv::ORB::defaultNorm()

AutoIt:
    cv.ORB.defaultNorm() -> retval

void cv::ORB::write( const std::string& fileName )

AutoIt:
    cv.ORB.write( $fileName ) -> None

void cv::ORB::write( const cv::Ptr<cv::FileStorage>& fs
                     const std::string&              name = String() )

AutoIt:
    cv.ORB.write( $fs[, $name] ) -> None

void cv::ORB::read( const std::string& fileName )

AutoIt:
    cv.ORB.read( $fileName ) -> None

void cv::ORB::read( const cv::FileNode& arg1 )

AutoIt:
    cv.ORB.read( $arg1 ) -> None

bool cv::ORB::empty()

AutoIt:
    cv.ORB.empty() -> retval

void cv::ORB::clear()

AutoIt:
    cv.ORB.clear() -> None

void cv::ORB::save( const std::string& filename )

AutoIt:
    cv.ORB.save( $filename ) -> None

static cv::Ptr<cv::MSER> cv::MSER::create( int    delta = 5
                                           int    min_area = 60
                                           int    max_area = 14400
                                           double max_variation = 0.25
                                           double min_diversity = .2
                                           int    max_evolution = 200
                                           double area_threshold = 1.01
                                           double min_margin = 0.003
                                           int    edge_blur_size = 5 )

AutoIt:
    cv.MSER.create( [$delta[, $min_area[, $max_area[, $max_variation[, $min_diversity[, $max_evolution[, $area_threshold[, $min_margin[, $edge_blur_size]]]]]]]]] ) -> retval

void cv::MSER::detectRegions( _InputArray                          image
                              std::vector<std::vector<cv::Point>>& msers
                              std::vector<cv::Rect>&               bboxes )

AutoIt:
    cv.MSER.detectRegions( $image[, $msers[, $bboxes]] ) -> msers, bboxes

void cv::MSER::setDelta( int delta )

AutoIt:
    cv.MSER.setDelta( $delta ) -> None

int cv::MSER::getDelta()

AutoIt:
    cv.MSER.getDelta() -> retval

void cv::MSER::setMinArea( int minArea )

AutoIt:
    cv.MSER.setMinArea( $minArea ) -> None

int cv::MSER::getMinArea()

AutoIt:
    cv.MSER.getMinArea() -> retval

void cv::MSER::setMaxArea( int maxArea )

AutoIt:
    cv.MSER.setMaxArea( $maxArea ) -> None

int cv::MSER::getMaxArea()

AutoIt:
    cv.MSER.getMaxArea() -> retval

void cv::MSER::setPass2Only( bool f )

AutoIt:
    cv.MSER.setPass2Only( $f ) -> None

bool cv::MSER::getPass2Only()

AutoIt:
    cv.MSER.getPass2Only() -> retval

std::string cv::MSER::getDefaultName()

AutoIt:
    cv.MSER.getDefaultName() -> retval

void cv::MSER::detect( _InputArray                image
                       std::vector<cv::KeyPoint>& keypoints
                       _InputArray                mask = noArray() )

AutoIt:
    cv.MSER.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::MSER::detect( _InputArray                             images
                       std::vector<std::vector<cv::KeyPoint>>& keypoints
                       _InputArray                             masks = noArray() )

AutoIt:
    cv.MSER.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::MSER::compute( _InputArray                image
                        std::vector<cv::KeyPoint>& keypoints
                        _OutputArray               descriptors )

AutoIt:
    cv.MSER.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::MSER::compute( _InputArray                             images
                        std::vector<std::vector<cv::KeyPoint>>& keypoints
                        _OutputArray                            descriptors )

AutoIt:
    cv.MSER.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::MSER::detectAndCompute( _InputArray                image
                                 _InputArray                mask
                                 std::vector<cv::KeyPoint>& keypoints
                                 _OutputArray               descriptors
                                 bool                       useProvidedKeypoints = false )

AutoIt:
    cv.MSER.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::MSER::descriptorSize()

AutoIt:
    cv.MSER.descriptorSize() -> retval

int cv::MSER::descriptorType()

AutoIt:
    cv.MSER.descriptorType() -> retval

int cv::MSER::defaultNorm()

AutoIt:
    cv.MSER.defaultNorm() -> retval

void cv::MSER::write( const std::string& fileName )

AutoIt:
    cv.MSER.write( $fileName ) -> None

void cv::MSER::write( const cv::Ptr<cv::FileStorage>& fs
                      const std::string&              name = String() )

AutoIt:
    cv.MSER.write( $fs[, $name] ) -> None

void cv::MSER::read( const std::string& fileName )

AutoIt:
    cv.MSER.read( $fileName ) -> None

void cv::MSER::read( const cv::FileNode& arg1 )

AutoIt:
    cv.MSER.read( $arg1 ) -> None

bool cv::MSER::empty()

AutoIt:
    cv.MSER.empty() -> retval

void cv::MSER::clear()

AutoIt:
    cv.MSER.clear() -> None

void cv::MSER::save( const std::string& filename )

AutoIt:
    cv.MSER.save( $filename ) -> None

static cv::Ptr<cv::FastFeatureDetector> cv::FastFeatureDetector::create( int  threshold = 10
                                                                         bool nonmaxSuppression = true
                                                                         int  type = FastFeatureDetector::TYPE_9_16 )

AutoIt:
    cv.FastFeatureDetector.create( [$threshold[, $nonmaxSuppression[, $type]]] ) -> retval

void cv::FastFeatureDetector::setThreshold( int threshold )

AutoIt:
    cv.FastFeatureDetector.setThreshold( $threshold ) -> None

int cv::FastFeatureDetector::getThreshold()

AutoIt:
    cv.FastFeatureDetector.getThreshold() -> retval

void cv::FastFeatureDetector::setNonmaxSuppression( bool f )

AutoIt:
    cv.FastFeatureDetector.setNonmaxSuppression( $f ) -> None

bool cv::FastFeatureDetector::getNonmaxSuppression()

AutoIt:
    cv.FastFeatureDetector.getNonmaxSuppression() -> retval

void cv::FastFeatureDetector::setType( int type )

AutoIt:
    cv.FastFeatureDetector.setType( $type ) -> None

int cv::FastFeatureDetector::getType()

AutoIt:
    cv.FastFeatureDetector.getType() -> retval

std::string cv::FastFeatureDetector::getDefaultName()

AutoIt:
    cv.FastFeatureDetector.getDefaultName() -> retval

void cv::FastFeatureDetector::detect( _InputArray                image
                                      std::vector<cv::KeyPoint>& keypoints
                                      _InputArray                mask = noArray() )

AutoIt:
    cv.FastFeatureDetector.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::FastFeatureDetector::detect( _InputArray                             images
                                      std::vector<std::vector<cv::KeyPoint>>& keypoints
                                      _InputArray                             masks = noArray() )

AutoIt:
    cv.FastFeatureDetector.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::FastFeatureDetector::compute( _InputArray                image
                                       std::vector<cv::KeyPoint>& keypoints
                                       _OutputArray               descriptors )

AutoIt:
    cv.FastFeatureDetector.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::FastFeatureDetector::compute( _InputArray                             images
                                       std::vector<std::vector<cv::KeyPoint>>& keypoints
                                       _OutputArray                            descriptors )

AutoIt:
    cv.FastFeatureDetector.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::FastFeatureDetector::detectAndCompute( _InputArray                image
                                                _InputArray                mask
                                                std::vector<cv::KeyPoint>& keypoints
                                                _OutputArray               descriptors
                                                bool                       useProvidedKeypoints = false )

AutoIt:
    cv.FastFeatureDetector.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::FastFeatureDetector::descriptorSize()

AutoIt:
    cv.FastFeatureDetector.descriptorSize() -> retval

int cv::FastFeatureDetector::descriptorType()

AutoIt:
    cv.FastFeatureDetector.descriptorType() -> retval

int cv::FastFeatureDetector::defaultNorm()

AutoIt:
    cv.FastFeatureDetector.defaultNorm() -> retval

void cv::FastFeatureDetector::write( const std::string& fileName )

AutoIt:
    cv.FastFeatureDetector.write( $fileName ) -> None

void cv::FastFeatureDetector::write( const cv::Ptr<cv::FileStorage>& fs
                                     const std::string&              name = String() )

AutoIt:
    cv.FastFeatureDetector.write( $fs[, $name] ) -> None

void cv::FastFeatureDetector::read( const std::string& fileName )

AutoIt:
    cv.FastFeatureDetector.read( $fileName ) -> None

void cv::FastFeatureDetector::read( const cv::FileNode& arg1 )

AutoIt:
    cv.FastFeatureDetector.read( $arg1 ) -> None

bool cv::FastFeatureDetector::empty()

AutoIt:
    cv.FastFeatureDetector.empty() -> retval

void cv::FastFeatureDetector::clear()

AutoIt:
    cv.FastFeatureDetector.clear() -> None

void cv::FastFeatureDetector::save( const std::string& filename )

AutoIt:
    cv.FastFeatureDetector.save( $filename ) -> None

static cv::Ptr<cv::AgastFeatureDetector> cv::AgastFeatureDetector::create( int  threshold = 10
                                                                           bool nonmaxSuppression = true
                                                                           int  type = AgastFeatureDetector::OAST_9_16 )

AutoIt:
    cv.AgastFeatureDetector.create( [$threshold[, $nonmaxSuppression[, $type]]] ) -> retval

void cv::AgastFeatureDetector::setThreshold( int threshold )

AutoIt:
    cv.AgastFeatureDetector.setThreshold( $threshold ) -> None

int cv::AgastFeatureDetector::getThreshold()

AutoIt:
    cv.AgastFeatureDetector.getThreshold() -> retval

void cv::AgastFeatureDetector::setNonmaxSuppression( bool f )

AutoIt:
    cv.AgastFeatureDetector.setNonmaxSuppression( $f ) -> None

bool cv::AgastFeatureDetector::getNonmaxSuppression()

AutoIt:
    cv.AgastFeatureDetector.getNonmaxSuppression() -> retval

void cv::AgastFeatureDetector::setType( int type )

AutoIt:
    cv.AgastFeatureDetector.setType( $type ) -> None

int cv::AgastFeatureDetector::getType()

AutoIt:
    cv.AgastFeatureDetector.getType() -> retval

std::string cv::AgastFeatureDetector::getDefaultName()

AutoIt:
    cv.AgastFeatureDetector.getDefaultName() -> retval

void cv::AgastFeatureDetector::detect( _InputArray                image
                                       std::vector<cv::KeyPoint>& keypoints
                                       _InputArray                mask = noArray() )

AutoIt:
    cv.AgastFeatureDetector.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::AgastFeatureDetector::detect( _InputArray                             images
                                       std::vector<std::vector<cv::KeyPoint>>& keypoints
                                       _InputArray                             masks = noArray() )

AutoIt:
    cv.AgastFeatureDetector.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::AgastFeatureDetector::compute( _InputArray                image
                                        std::vector<cv::KeyPoint>& keypoints
                                        _OutputArray               descriptors )

AutoIt:
    cv.AgastFeatureDetector.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::AgastFeatureDetector::compute( _InputArray                             images
                                        std::vector<std::vector<cv::KeyPoint>>& keypoints
                                        _OutputArray                            descriptors )

AutoIt:
    cv.AgastFeatureDetector.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::AgastFeatureDetector::detectAndCompute( _InputArray                image
                                                 _InputArray                mask
                                                 std::vector<cv::KeyPoint>& keypoints
                                                 _OutputArray               descriptors
                                                 bool                       useProvidedKeypoints = false )

AutoIt:
    cv.AgastFeatureDetector.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::AgastFeatureDetector::descriptorSize()

AutoIt:
    cv.AgastFeatureDetector.descriptorSize() -> retval

int cv::AgastFeatureDetector::descriptorType()

AutoIt:
    cv.AgastFeatureDetector.descriptorType() -> retval

int cv::AgastFeatureDetector::defaultNorm()

AutoIt:
    cv.AgastFeatureDetector.defaultNorm() -> retval

void cv::AgastFeatureDetector::write( const std::string& fileName )

AutoIt:
    cv.AgastFeatureDetector.write( $fileName ) -> None

void cv::AgastFeatureDetector::write( const cv::Ptr<cv::FileStorage>& fs
                                      const std::string&              name = String() )

AutoIt:
    cv.AgastFeatureDetector.write( $fs[, $name] ) -> None

void cv::AgastFeatureDetector::read( const std::string& fileName )

AutoIt:
    cv.AgastFeatureDetector.read( $fileName ) -> None

void cv::AgastFeatureDetector::read( const cv::FileNode& arg1 )

AutoIt:
    cv.AgastFeatureDetector.read( $arg1 ) -> None

bool cv::AgastFeatureDetector::empty()

AutoIt:
    cv.AgastFeatureDetector.empty() -> retval

void cv::AgastFeatureDetector::clear()

AutoIt:
    cv.AgastFeatureDetector.clear() -> None

void cv::AgastFeatureDetector::save( const std::string& filename )

AutoIt:
    cv.AgastFeatureDetector.save( $filename ) -> None

static cv::Ptr<cv::GFTTDetector> cv::GFTTDetector::create( int    maxCorners = 1000
                                                           double qualityLevel = 0.01
                                                           double minDistance = 1
                                                           int    blockSize = 3
                                                           bool   useHarrisDetector = false
                                                           double k = 0.04 )

AutoIt:
    cv.GFTTDetector.create( [$maxCorners[, $qualityLevel[, $minDistance[, $blockSize[, $useHarrisDetector[, $k]]]]]] ) -> retval

static cv::Ptr<cv::GFTTDetector> cv::GFTTDetector::create( int    maxCorners
                                                           double qualityLevel
                                                           double minDistance
                                                           int    blockSize
                                                           int    gradiantSize
                                                           bool   useHarrisDetector = false
                                                           double k = 0.04 )

AutoIt:
    cv.GFTTDetector.create( $maxCorners, $qualityLevel, $minDistance, $blockSize, $gradiantSize[, $useHarrisDetector[, $k]] ) -> retval

void cv::GFTTDetector::setMaxFeatures( int maxFeatures )

AutoIt:
    cv.GFTTDetector.setMaxFeatures( $maxFeatures ) -> None

int cv::GFTTDetector::getMaxFeatures()

AutoIt:
    cv.GFTTDetector.getMaxFeatures() -> retval

void cv::GFTTDetector::setQualityLevel( double qlevel )

AutoIt:
    cv.GFTTDetector.setQualityLevel( $qlevel ) -> None

double cv::GFTTDetector::getQualityLevel()

AutoIt:
    cv.GFTTDetector.getQualityLevel() -> retval

void cv::GFTTDetector::setMinDistance( double minDistance )

AutoIt:
    cv.GFTTDetector.setMinDistance( $minDistance ) -> None

double cv::GFTTDetector::getMinDistance()

AutoIt:
    cv.GFTTDetector.getMinDistance() -> retval

void cv::GFTTDetector::setBlockSize( int blockSize )

AutoIt:
    cv.GFTTDetector.setBlockSize( $blockSize ) -> None

int cv::GFTTDetector::getBlockSize()

AutoIt:
    cv.GFTTDetector.getBlockSize() -> retval

void cv::GFTTDetector::setHarrisDetector( bool val )

AutoIt:
    cv.GFTTDetector.setHarrisDetector( $val ) -> None

bool cv::GFTTDetector::getHarrisDetector()

AutoIt:
    cv.GFTTDetector.getHarrisDetector() -> retval

void cv::GFTTDetector::setK( double k )

AutoIt:
    cv.GFTTDetector.setK( $k ) -> None

double cv::GFTTDetector::getK()

AutoIt:
    cv.GFTTDetector.getK() -> retval

std::string cv::GFTTDetector::getDefaultName()

AutoIt:
    cv.GFTTDetector.getDefaultName() -> retval

void cv::GFTTDetector::detect( _InputArray                image
                               std::vector<cv::KeyPoint>& keypoints
                               _InputArray                mask = noArray() )

AutoIt:
    cv.GFTTDetector.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::GFTTDetector::detect( _InputArray                             images
                               std::vector<std::vector<cv::KeyPoint>>& keypoints
                               _InputArray                             masks = noArray() )

AutoIt:
    cv.GFTTDetector.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::GFTTDetector::compute( _InputArray                image
                                std::vector<cv::KeyPoint>& keypoints
                                _OutputArray               descriptors )

AutoIt:
    cv.GFTTDetector.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::GFTTDetector::compute( _InputArray                             images
                                std::vector<std::vector<cv::KeyPoint>>& keypoints
                                _OutputArray                            descriptors )

AutoIt:
    cv.GFTTDetector.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::GFTTDetector::detectAndCompute( _InputArray                image
                                         _InputArray                mask
                                         std::vector<cv::KeyPoint>& keypoints
                                         _OutputArray               descriptors
                                         bool                       useProvidedKeypoints = false )

AutoIt:
    cv.GFTTDetector.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::GFTTDetector::descriptorSize()

AutoIt:
    cv.GFTTDetector.descriptorSize() -> retval

int cv::GFTTDetector::descriptorType()

AutoIt:
    cv.GFTTDetector.descriptorType() -> retval

int cv::GFTTDetector::defaultNorm()

AutoIt:
    cv.GFTTDetector.defaultNorm() -> retval

void cv::GFTTDetector::write( const std::string& fileName )

AutoIt:
    cv.GFTTDetector.write( $fileName ) -> None

void cv::GFTTDetector::write( const cv::Ptr<cv::FileStorage>& fs
                              const std::string&              name = String() )

AutoIt:
    cv.GFTTDetector.write( $fs[, $name] ) -> None

void cv::GFTTDetector::read( const std::string& fileName )

AutoIt:
    cv.GFTTDetector.read( $fileName ) -> None

void cv::GFTTDetector::read( const cv::FileNode& arg1 )

AutoIt:
    cv.GFTTDetector.read( $arg1 ) -> None

bool cv::GFTTDetector::empty()

AutoIt:
    cv.GFTTDetector.empty() -> retval

void cv::GFTTDetector::clear()

AutoIt:
    cv.GFTTDetector.clear() -> None

void cv::GFTTDetector::save( const std::string& filename )

AutoIt:
    cv.GFTTDetector.save( $filename ) -> None

static cv::Ptr<cv::SimpleBlobDetector> cv::SimpleBlobDetector::create( const cv::SimpleBlobDetector::Params& parameters = SimpleBlobDetector::Params() )

AutoIt:
    cv.SimpleBlobDetector.create( [$parameters] ) -> retval

std::string cv::SimpleBlobDetector::getDefaultName()

AutoIt:
    cv.SimpleBlobDetector.getDefaultName() -> retval

void cv::SimpleBlobDetector::detect( _InputArray                image
                                     std::vector<cv::KeyPoint>& keypoints
                                     _InputArray                mask = noArray() )

AutoIt:
    cv.SimpleBlobDetector.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::SimpleBlobDetector::detect( _InputArray                             images
                                     std::vector<std::vector<cv::KeyPoint>>& keypoints
                                     _InputArray                             masks = noArray() )

AutoIt:
    cv.SimpleBlobDetector.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::SimpleBlobDetector::compute( _InputArray                image
                                      std::vector<cv::KeyPoint>& keypoints
                                      _OutputArray               descriptors )

AutoIt:
    cv.SimpleBlobDetector.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::SimpleBlobDetector::compute( _InputArray                             images
                                      std::vector<std::vector<cv::KeyPoint>>& keypoints
                                      _OutputArray                            descriptors )

AutoIt:
    cv.SimpleBlobDetector.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::SimpleBlobDetector::detectAndCompute( _InputArray                image
                                               _InputArray                mask
                                               std::vector<cv::KeyPoint>& keypoints
                                               _OutputArray               descriptors
                                               bool                       useProvidedKeypoints = false )

AutoIt:
    cv.SimpleBlobDetector.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::SimpleBlobDetector::descriptorSize()

AutoIt:
    cv.SimpleBlobDetector.descriptorSize() -> retval

int cv::SimpleBlobDetector::descriptorType()

AutoIt:
    cv.SimpleBlobDetector.descriptorType() -> retval

int cv::SimpleBlobDetector::defaultNorm()

AutoIt:
    cv.SimpleBlobDetector.defaultNorm() -> retval

void cv::SimpleBlobDetector::write( const std::string& fileName )

AutoIt:
    cv.SimpleBlobDetector.write( $fileName ) -> None

void cv::SimpleBlobDetector::write( const cv::Ptr<cv::FileStorage>& fs
                                    const std::string&              name = String() )

AutoIt:
    cv.SimpleBlobDetector.write( $fs[, $name] ) -> None

void cv::SimpleBlobDetector::read( const std::string& fileName )

AutoIt:
    cv.SimpleBlobDetector.read( $fileName ) -> None

void cv::SimpleBlobDetector::read( const cv::FileNode& arg1 )

AutoIt:
    cv.SimpleBlobDetector.read( $arg1 ) -> None

bool cv::SimpleBlobDetector::empty()

AutoIt:
    cv.SimpleBlobDetector.empty() -> retval

void cv::SimpleBlobDetector::clear()

AutoIt:
    cv.SimpleBlobDetector.clear() -> None

void cv::SimpleBlobDetector::save( const std::string& filename )

AutoIt:
    cv.SimpleBlobDetector.save( $filename ) -> None

static cv::SimpleBlobDetector::Params cv::SimpleBlobDetector::Params::create()

AutoIt:
    cv.SimpleBlobDetector.Params.create() -> <cv.SimpleBlobDetector.Params object>

static cv::SimpleBlobDetector::Params cv::SimpleBlobDetector::Params::create()

AutoIt:
    cv.SimpleBlobDetector.Params.create() -> <cv.SimpleBlobDetector.Params object>

static cv::Ptr<cv::KAZE> cv::KAZE::create( bool  extended = false
                                           bool  upright = false
                                           float threshold = 0.001f
                                           int   nOctaves = 4
                                           int   nOctaveLayers = 4
                                           int   diffusivity = KAZE::DIFF_PM_G2 )

AutoIt:
    cv.KAZE.create( [$extended[, $upright[, $threshold[, $nOctaves[, $nOctaveLayers[, $diffusivity]]]]]] ) -> retval

void cv::KAZE::setExtended( bool extended )

AutoIt:
    cv.KAZE.setExtended( $extended ) -> None

bool cv::KAZE::getExtended()

AutoIt:
    cv.KAZE.getExtended() -> retval

void cv::KAZE::setUpright( bool upright )

AutoIt:
    cv.KAZE.setUpright( $upright ) -> None

bool cv::KAZE::getUpright()

AutoIt:
    cv.KAZE.getUpright() -> retval

void cv::KAZE::setThreshold( double threshold )

AutoIt:
    cv.KAZE.setThreshold( $threshold ) -> None

double cv::KAZE::getThreshold()

AutoIt:
    cv.KAZE.getThreshold() -> retval

void cv::KAZE::setNOctaves( int octaves )

AutoIt:
    cv.KAZE.setNOctaves( $octaves ) -> None

int cv::KAZE::getNOctaves()

AutoIt:
    cv.KAZE.getNOctaves() -> retval

void cv::KAZE::setNOctaveLayers( int octaveLayers )

AutoIt:
    cv.KAZE.setNOctaveLayers( $octaveLayers ) -> None

int cv::KAZE::getNOctaveLayers()

AutoIt:
    cv.KAZE.getNOctaveLayers() -> retval

void cv::KAZE::setDiffusivity( int diff )

AutoIt:
    cv.KAZE.setDiffusivity( $diff ) -> None

int cv::KAZE::getDiffusivity()

AutoIt:
    cv.KAZE.getDiffusivity() -> retval

std::string cv::KAZE::getDefaultName()

AutoIt:
    cv.KAZE.getDefaultName() -> retval

void cv::KAZE::detect( _InputArray                image
                       std::vector<cv::KeyPoint>& keypoints
                       _InputArray                mask = noArray() )

AutoIt:
    cv.KAZE.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::KAZE::detect( _InputArray                             images
                       std::vector<std::vector<cv::KeyPoint>>& keypoints
                       _InputArray                             masks = noArray() )

AutoIt:
    cv.KAZE.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::KAZE::compute( _InputArray                image
                        std::vector<cv::KeyPoint>& keypoints
                        _OutputArray               descriptors )

AutoIt:
    cv.KAZE.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::KAZE::compute( _InputArray                             images
                        std::vector<std::vector<cv::KeyPoint>>& keypoints
                        _OutputArray                            descriptors )

AutoIt:
    cv.KAZE.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::KAZE::detectAndCompute( _InputArray                image
                                 _InputArray                mask
                                 std::vector<cv::KeyPoint>& keypoints
                                 _OutputArray               descriptors
                                 bool                       useProvidedKeypoints = false )

AutoIt:
    cv.KAZE.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::KAZE::descriptorSize()

AutoIt:
    cv.KAZE.descriptorSize() -> retval

int cv::KAZE::descriptorType()

AutoIt:
    cv.KAZE.descriptorType() -> retval

int cv::KAZE::defaultNorm()

AutoIt:
    cv.KAZE.defaultNorm() -> retval

void cv::KAZE::write( const std::string& fileName )

AutoIt:
    cv.KAZE.write( $fileName ) -> None

void cv::KAZE::write( const cv::Ptr<cv::FileStorage>& fs
                      const std::string&              name = String() )

AutoIt:
    cv.KAZE.write( $fs[, $name] ) -> None

void cv::KAZE::read( const std::string& fileName )

AutoIt:
    cv.KAZE.read( $fileName ) -> None

void cv::KAZE::read( const cv::FileNode& arg1 )

AutoIt:
    cv.KAZE.read( $arg1 ) -> None

bool cv::KAZE::empty()

AutoIt:
    cv.KAZE.empty() -> retval

void cv::KAZE::clear()

AutoIt:
    cv.KAZE.clear() -> None

void cv::KAZE::save( const std::string& filename )

AutoIt:
    cv.KAZE.save( $filename ) -> None

static cv::Ptr<cv::AKAZE> cv::AKAZE::create( int   descriptor_type = AKAZE::DESCRIPTOR_MLDB
                                             int   descriptor_size = 0
                                             int   descriptor_channels = 3
                                             float threshold = 0.001f
                                             int   nOctaves = 4
                                             int   nOctaveLayers = 4
                                             int   diffusivity = KAZE::DIFF_PM_G2 )

AutoIt:
    cv.AKAZE.create( [$descriptor_type[, $descriptor_size[, $descriptor_channels[, $threshold[, $nOctaves[, $nOctaveLayers[, $diffusivity]]]]]]] ) -> retval

void cv::AKAZE::setDescriptorType( int dtype )

AutoIt:
    cv.AKAZE.setDescriptorType( $dtype ) -> None

int cv::AKAZE::getDescriptorType()

AutoIt:
    cv.AKAZE.getDescriptorType() -> retval

void cv::AKAZE::setDescriptorSize( int dsize )

AutoIt:
    cv.AKAZE.setDescriptorSize( $dsize ) -> None

int cv::AKAZE::getDescriptorSize()

AutoIt:
    cv.AKAZE.getDescriptorSize() -> retval

void cv::AKAZE::setDescriptorChannels( int dch )

AutoIt:
    cv.AKAZE.setDescriptorChannels( $dch ) -> None

int cv::AKAZE::getDescriptorChannels()

AutoIt:
    cv.AKAZE.getDescriptorChannels() -> retval

void cv::AKAZE::setThreshold( double threshold )

AutoIt:
    cv.AKAZE.setThreshold( $threshold ) -> None

double cv::AKAZE::getThreshold()

AutoIt:
    cv.AKAZE.getThreshold() -> retval

void cv::AKAZE::setNOctaves( int octaves )

AutoIt:
    cv.AKAZE.setNOctaves( $octaves ) -> None

int cv::AKAZE::getNOctaves()

AutoIt:
    cv.AKAZE.getNOctaves() -> retval

void cv::AKAZE::setNOctaveLayers( int octaveLayers )

AutoIt:
    cv.AKAZE.setNOctaveLayers( $octaveLayers ) -> None

int cv::AKAZE::getNOctaveLayers()

AutoIt:
    cv.AKAZE.getNOctaveLayers() -> retval

void cv::AKAZE::setDiffusivity( int diff )

AutoIt:
    cv.AKAZE.setDiffusivity( $diff ) -> None

int cv::AKAZE::getDiffusivity()

AutoIt:
    cv.AKAZE.getDiffusivity() -> retval

std::string cv::AKAZE::getDefaultName()

AutoIt:
    cv.AKAZE.getDefaultName() -> retval

void cv::AKAZE::detect( _InputArray                image
                        std::vector<cv::KeyPoint>& keypoints
                        _InputArray                mask = noArray() )

AutoIt:
    cv.AKAZE.detect( $image[, $mask[, $keypoints]] ) -> keypoints

void cv::AKAZE::detect( _InputArray                             images
                        std::vector<std::vector<cv::KeyPoint>>& keypoints
                        _InputArray                             masks = noArray() )

AutoIt:
    cv.AKAZE.detect( $images[, $masks[, $keypoints]] ) -> keypoints

void cv::AKAZE::compute( _InputArray                image
                         std::vector<cv::KeyPoint>& keypoints
                         _OutputArray               descriptors )

AutoIt:
    cv.AKAZE.compute( $image, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::AKAZE::compute( _InputArray                             images
                         std::vector<std::vector<cv::KeyPoint>>& keypoints
                         _OutputArray                            descriptors )

AutoIt:
    cv.AKAZE.compute( $images, $keypoints[, $descriptors] ) -> keypoints, descriptors

void cv::AKAZE::detectAndCompute( _InputArray                image
                                  _InputArray                mask
                                  std::vector<cv::KeyPoint>& keypoints
                                  _OutputArray               descriptors
                                  bool                       useProvidedKeypoints = false )

AutoIt:
    cv.AKAZE.detectAndCompute( $image, $mask[, $descriptors[, $useProvidedKeypoints[, $keypoints]]] ) -> keypoints, descriptors

int cv::AKAZE::descriptorSize()

AutoIt:
    cv.AKAZE.descriptorSize() -> retval

int cv::AKAZE::descriptorType()

AutoIt:
    cv.AKAZE.descriptorType() -> retval

int cv::AKAZE::defaultNorm()

AutoIt:
    cv.AKAZE.defaultNorm() -> retval

void cv::AKAZE::write( const std::string& fileName )

AutoIt:
    cv.AKAZE.write( $fileName ) -> None

void cv::AKAZE::write( const cv::Ptr<cv::FileStorage>& fs
                       const std::string&              name = String() )

AutoIt:
    cv.AKAZE.write( $fs[, $name] ) -> None

void cv::AKAZE::read( const std::string& fileName )

AutoIt:
    cv.AKAZE.read( $fileName ) -> None

void cv::AKAZE::read( const cv::FileNode& arg1 )

AutoIt:
    cv.AKAZE.read( $arg1 ) -> None

bool cv::AKAZE::empty()

AutoIt:
    cv.AKAZE.empty() -> retval

void cv::AKAZE::clear()

AutoIt:
    cv.AKAZE.clear() -> None

void cv::AKAZE::save( const std::string& filename )

AutoIt:
    cv.AKAZE.save( $filename ) -> None

void cv::DescriptorMatcher::add( _InputArray descriptors )

AutoIt:
    cv.DescriptorMatcher.add( $descriptors ) -> None

std::vector<cv::Mat> cv::DescriptorMatcher::getTrainDescriptors()

AutoIt:
    cv.DescriptorMatcher.getTrainDescriptors() -> retval

void cv::DescriptorMatcher::clear()

AutoIt:
    cv.DescriptorMatcher.clear() -> None

bool cv::DescriptorMatcher::empty()

AutoIt:
    cv.DescriptorMatcher.empty() -> retval

bool cv::DescriptorMatcher::isMaskSupported()

AutoIt:
    cv.DescriptorMatcher.isMaskSupported() -> retval

void cv::DescriptorMatcher::train()

AutoIt:
    cv.DescriptorMatcher.train() -> None

void cv::DescriptorMatcher::match( _InputArray              queryDescriptors
                                   _InputArray              trainDescriptors
                                   std::vector<cv::DMatch>& matches
                                   _InputArray              mask = noArray() )

AutoIt:
    cv.DescriptorMatcher.match( $queryDescriptors, $trainDescriptors[, $mask[, $matches]] ) -> matches

void cv::DescriptorMatcher::match( _InputArray              queryDescriptors
                                   std::vector<cv::DMatch>& matches
                                   _InputArray              masks = noArray() )

AutoIt:
    cv.DescriptorMatcher.match( $queryDescriptors[, $masks[, $matches]] ) -> matches

void cv::DescriptorMatcher::knnMatch( _InputArray                           queryDescriptors
                                      _InputArray                           trainDescriptors
                                      std::vector<std::vector<cv::DMatch>>& matches
                                      int                                   k
                                      _InputArray                           mask = noArray()
                                      bool                                  compactResult = false )

AutoIt:
    cv.DescriptorMatcher.knnMatch( $queryDescriptors, $trainDescriptors, $k[, $mask[, $compactResult[, $matches]]] ) -> matches

void cv::DescriptorMatcher::knnMatch( _InputArray                           queryDescriptors
                                      std::vector<std::vector<cv::DMatch>>& matches
                                      int                                   k
                                      _InputArray                           masks = noArray()
                                      bool                                  compactResult = false )

AutoIt:
    cv.DescriptorMatcher.knnMatch( $queryDescriptors, $k[, $masks[, $compactResult[, $matches]]] ) -> matches

void cv::DescriptorMatcher::radiusMatch( _InputArray                           queryDescriptors
                                         _InputArray                           trainDescriptors
                                         std::vector<std::vector<cv::DMatch>>& matches
                                         float                                 maxDistance
                                         _InputArray                           mask = noArray()
                                         bool                                  compactResult = false )

AutoIt:
    cv.DescriptorMatcher.radiusMatch( $queryDescriptors, $trainDescriptors, $maxDistance[, $mask[, $compactResult[, $matches]]] ) -> matches

void cv::DescriptorMatcher::radiusMatch( _InputArray                           queryDescriptors
                                         std::vector<std::vector<cv::DMatch>>& matches
                                         float                                 maxDistance
                                         _InputArray                           masks = noArray()
                                         bool                                  compactResult = false )

AutoIt:
    cv.DescriptorMatcher.radiusMatch( $queryDescriptors, $maxDistance[, $masks[, $compactResult[, $matches]]] ) -> matches

void cv::DescriptorMatcher::write( const std::string& fileName )

AutoIt:
    cv.DescriptorMatcher.write( $fileName ) -> None

void cv::DescriptorMatcher::write( const cv::Ptr<cv::FileStorage>& fs
                                   const std::string&              name = String() )

AutoIt:
    cv.DescriptorMatcher.write( $fs[, $name] ) -> None

void cv::DescriptorMatcher::read( const std::string& fileName )

AutoIt:
    cv.DescriptorMatcher.read( $fileName ) -> None

void cv::DescriptorMatcher::read( const cv::FileNode& arg1 )

AutoIt:
    cv.DescriptorMatcher.read( $arg1 ) -> None

cv::Ptr<cv::DescriptorMatcher> cv::DescriptorMatcher::clone( bool emptyTrainData = false )

AutoIt:
    cv.DescriptorMatcher.clone( [$emptyTrainData] ) -> retval

static cv::Ptr<cv::DescriptorMatcher> cv::DescriptorMatcher::create( const std::string& descriptorMatcherType )

AutoIt:
    cv.DescriptorMatcher.create( $descriptorMatcherType ) -> retval

static cv::Ptr<cv::DescriptorMatcher> cv::DescriptorMatcher::create( const int& matcherType )

AutoIt:
    cv.DescriptorMatcher.create( $matcherType ) -> retval

void cv::DescriptorMatcher::save( const std::string& filename )

AutoIt:
    cv.DescriptorMatcher.save( $filename ) -> None

std::string cv::DescriptorMatcher::getDefaultName()

AutoIt:
    cv.DescriptorMatcher.getDefaultName() -> retval

static cv::BFMatcher cv::BFMatcher::create( int  normType = NORM_L2
                                            bool crossCheck = false )

AutoIt:
    cv.BFMatcher.create( [$normType[, $crossCheck]] ) -> <cv.BFMatcher object>

static cv::Ptr<cv::BFMatcher> cv::BFMatcher::create( int  normType = NORM_L2
                                                     bool crossCheck = false )

AutoIt:
    cv.BFMatcher.create( [$normType[, $crossCheck]] ) -> retval

void cv::BFMatcher::add( _InputArray descriptors )

AutoIt:
    cv.BFMatcher.add( $descriptors ) -> None

std::vector<cv::Mat> cv::BFMatcher::getTrainDescriptors()

AutoIt:
    cv.BFMatcher.getTrainDescriptors() -> retval

void cv::BFMatcher::clear()

AutoIt:
    cv.BFMatcher.clear() -> None

bool cv::BFMatcher::empty()

AutoIt:
    cv.BFMatcher.empty() -> retval

bool cv::BFMatcher::isMaskSupported()

AutoIt:
    cv.BFMatcher.isMaskSupported() -> retval

void cv::BFMatcher::train()

AutoIt:
    cv.BFMatcher.train() -> None

void cv::BFMatcher::match( _InputArray              queryDescriptors
                           _InputArray              trainDescriptors
                           std::vector<cv::DMatch>& matches
                           _InputArray              mask = noArray() )

AutoIt:
    cv.BFMatcher.match( $queryDescriptors, $trainDescriptors[, $mask[, $matches]] ) -> matches

void cv::BFMatcher::match( _InputArray              queryDescriptors
                           std::vector<cv::DMatch>& matches
                           _InputArray              masks = noArray() )

AutoIt:
    cv.BFMatcher.match( $queryDescriptors[, $masks[, $matches]] ) -> matches

void cv::BFMatcher::knnMatch( _InputArray                           queryDescriptors
                              _InputArray                           trainDescriptors
                              std::vector<std::vector<cv::DMatch>>& matches
                              int                                   k
                              _InputArray                           mask = noArray()
                              bool                                  compactResult = false )

AutoIt:
    cv.BFMatcher.knnMatch( $queryDescriptors, $trainDescriptors, $k[, $mask[, $compactResult[, $matches]]] ) -> matches

void cv::BFMatcher::knnMatch( _InputArray                           queryDescriptors
                              std::vector<std::vector<cv::DMatch>>& matches
                              int                                   k
                              _InputArray                           masks = noArray()
                              bool                                  compactResult = false )

AutoIt:
    cv.BFMatcher.knnMatch( $queryDescriptors, $k[, $masks[, $compactResult[, $matches]]] ) -> matches

void cv::BFMatcher::radiusMatch( _InputArray                           queryDescriptors
                                 _InputArray                           trainDescriptors
                                 std::vector<std::vector<cv::DMatch>>& matches
                                 float                                 maxDistance
                                 _InputArray                           mask = noArray()
                                 bool                                  compactResult = false )

AutoIt:
    cv.BFMatcher.radiusMatch( $queryDescriptors, $trainDescriptors, $maxDistance[, $mask[, $compactResult[, $matches]]] ) -> matches

void cv::BFMatcher::radiusMatch( _InputArray                           queryDescriptors
                                 std::vector<std::vector<cv::DMatch>>& matches
                                 float                                 maxDistance
                                 _InputArray                           masks = noArray()
                                 bool                                  compactResult = false )

AutoIt:
    cv.BFMatcher.radiusMatch( $queryDescriptors, $maxDistance[, $masks[, $compactResult[, $matches]]] ) -> matches

void cv::BFMatcher::write( const std::string& fileName )

AutoIt:
    cv.BFMatcher.write( $fileName ) -> None

void cv::BFMatcher::write( const cv::Ptr<cv::FileStorage>& fs
                           const std::string&              name = String() )

AutoIt:
    cv.BFMatcher.write( $fs[, $name] ) -> None

void cv::BFMatcher::read( const std::string& fileName )

AutoIt:
    cv.BFMatcher.read( $fileName ) -> None

void cv::BFMatcher::read( const cv::FileNode& arg1 )

AutoIt:
    cv.BFMatcher.read( $arg1 ) -> None

cv::Ptr<cv::DescriptorMatcher> cv::BFMatcher::clone( bool emptyTrainData = false )

AutoIt:
    cv.BFMatcher.clone( [$emptyTrainData] ) -> retval

void cv::BFMatcher::save( const std::string& filename )

AutoIt:
    cv.BFMatcher.save( $filename ) -> None

std::string cv::BFMatcher::getDefaultName()

AutoIt:
    cv.BFMatcher.getDefaultName() -> retval

static cv::FlannBasedMatcher cv::FlannBasedMatcher::create( const cv::Ptr<flann::IndexParams>&  indexParams = makePtr<flann::KDTreeIndexParams>()
                                                            const cv::Ptr<flann::SearchParams>& searchParams = makePtr<flann::SearchParams>() )

AutoIt:
    cv.FlannBasedMatcher.create( [$indexParams[, $searchParams]] ) -> <cv.FlannBasedMatcher object>

static cv::Ptr<cv::FlannBasedMatcher> cv::FlannBasedMatcher::create()

AutoIt:
    cv.FlannBasedMatcher.create() -> retval

void cv::FlannBasedMatcher::add( _InputArray descriptors )

AutoIt:
    cv.FlannBasedMatcher.add( $descriptors ) -> None

std::vector<cv::Mat> cv::FlannBasedMatcher::getTrainDescriptors()

AutoIt:
    cv.FlannBasedMatcher.getTrainDescriptors() -> retval

void cv::FlannBasedMatcher::clear()

AutoIt:
    cv.FlannBasedMatcher.clear() -> None

bool cv::FlannBasedMatcher::empty()

AutoIt:
    cv.FlannBasedMatcher.empty() -> retval

bool cv::FlannBasedMatcher::isMaskSupported()

AutoIt:
    cv.FlannBasedMatcher.isMaskSupported() -> retval

void cv::FlannBasedMatcher::train()

AutoIt:
    cv.FlannBasedMatcher.train() -> None

void cv::FlannBasedMatcher::match( _InputArray              queryDescriptors
                                   _InputArray              trainDescriptors
                                   std::vector<cv::DMatch>& matches
                                   _InputArray              mask = noArray() )

AutoIt:
    cv.FlannBasedMatcher.match( $queryDescriptors, $trainDescriptors[, $mask[, $matches]] ) -> matches

void cv::FlannBasedMatcher::match( _InputArray              queryDescriptors
                                   std::vector<cv::DMatch>& matches
                                   _InputArray              masks = noArray() )

AutoIt:
    cv.FlannBasedMatcher.match( $queryDescriptors[, $masks[, $matches]] ) -> matches

void cv::FlannBasedMatcher::knnMatch( _InputArray                           queryDescriptors
                                      _InputArray                           trainDescriptors
                                      std::vector<std::vector<cv::DMatch>>& matches
                                      int                                   k
                                      _InputArray                           mask = noArray()
                                      bool                                  compactResult = false )

AutoIt:
    cv.FlannBasedMatcher.knnMatch( $queryDescriptors, $trainDescriptors, $k[, $mask[, $compactResult[, $matches]]] ) -> matches

void cv::FlannBasedMatcher::knnMatch( _InputArray                           queryDescriptors
                                      std::vector<std::vector<cv::DMatch>>& matches
                                      int                                   k
                                      _InputArray                           masks = noArray()
                                      bool                                  compactResult = false )

AutoIt:
    cv.FlannBasedMatcher.knnMatch( $queryDescriptors, $k[, $masks[, $compactResult[, $matches]]] ) -> matches

void cv::FlannBasedMatcher::radiusMatch( _InputArray                           queryDescriptors
                                         _InputArray                           trainDescriptors
                                         std::vector<std::vector<cv::DMatch>>& matches
                                         float                                 maxDistance
                                         _InputArray                           mask = noArray()
                                         bool                                  compactResult = false )

AutoIt:
    cv.FlannBasedMatcher.radiusMatch( $queryDescriptors, $trainDescriptors, $maxDistance[, $mask[, $compactResult[, $matches]]] ) -> matches

void cv::FlannBasedMatcher::radiusMatch( _InputArray                           queryDescriptors
                                         std::vector<std::vector<cv::DMatch>>& matches
                                         float                                 maxDistance
                                         _InputArray                           masks = noArray()
                                         bool                                  compactResult = false )

AutoIt:
    cv.FlannBasedMatcher.radiusMatch( $queryDescriptors, $maxDistance[, $masks[, $compactResult[, $matches]]] ) -> matches

void cv::FlannBasedMatcher::write( const std::string& fileName )

AutoIt:
    cv.FlannBasedMatcher.write( $fileName ) -> None

void cv::FlannBasedMatcher::write( const cv::Ptr<cv::FileStorage>& fs
                                   const std::string&              name = String() )

AutoIt:
    cv.FlannBasedMatcher.write( $fs[, $name] ) -> None

void cv::FlannBasedMatcher::read( const std::string& fileName )

AutoIt:
    cv.FlannBasedMatcher.read( $fileName ) -> None

void cv::FlannBasedMatcher::read( const cv::FileNode& arg1 )

AutoIt:
    cv.FlannBasedMatcher.read( $arg1 ) -> None

cv::Ptr<cv::DescriptorMatcher> cv::FlannBasedMatcher::clone( bool emptyTrainData = false )

AutoIt:
    cv.FlannBasedMatcher.clone( [$emptyTrainData] ) -> retval

void cv::FlannBasedMatcher::save( const std::string& filename )

AutoIt:
    cv.FlannBasedMatcher.save( $filename ) -> None

std::string cv::FlannBasedMatcher::getDefaultName()

AutoIt:
    cv.FlannBasedMatcher.getDefaultName() -> retval

void cv::BOWTrainer::add( const cv::Mat& descriptors )

AutoIt:
    cv.BOWTrainer.add( $descriptors ) -> None

std::vector<cv::Mat> cv::BOWTrainer::getDescriptors()

AutoIt:
    cv.BOWTrainer.getDescriptors() -> retval

int cv::BOWTrainer::descriptorsCount()

AutoIt:
    cv.BOWTrainer.descriptorsCount() -> retval

void cv::BOWTrainer::clear()

AutoIt:
    cv.BOWTrainer.clear() -> None

cv::Mat cv::BOWTrainer::cluster()

AutoIt:
    cv.BOWTrainer.cluster() -> retval

cv::Mat cv::BOWTrainer::cluster( const cv::Mat& descriptors )

AutoIt:
    cv.BOWTrainer.cluster( $descriptors ) -> retval

static cv::BOWKMeansTrainer cv::BOWKMeansTrainer::create( int                     clusterCount
                                                          const cv::TermCriteria& termcrit = TermCriteria()
                                                          int                     attempts = 3
                                                          int                     flags = KMEANS_PP_CENTERS )

AutoIt:
    cv.BOWKMeansTrainer.create( $clusterCount[, $termcrit[, $attempts[, $flags]]] ) -> <cv.BOWKMeansTrainer object>

cv::Mat cv::BOWKMeansTrainer::cluster()

AutoIt:
    cv.BOWKMeansTrainer.cluster() -> retval

cv::Mat cv::BOWKMeansTrainer::cluster( const cv::Mat& descriptors )

AutoIt:
    cv.BOWKMeansTrainer.cluster( $descriptors ) -> retval

void cv::BOWKMeansTrainer::add( const cv::Mat& descriptors )

AutoIt:
    cv.BOWKMeansTrainer.add( $descriptors ) -> None

std::vector<cv::Mat> cv::BOWKMeansTrainer::getDescriptors()

AutoIt:
    cv.BOWKMeansTrainer.getDescriptors() -> retval

int cv::BOWKMeansTrainer::descriptorsCount()

AutoIt:
    cv.BOWKMeansTrainer.descriptorsCount() -> retval

void cv::BOWKMeansTrainer::clear()

AutoIt:
    cv.BOWKMeansTrainer.clear() -> None

static cv::BOWImgDescriptorExtractor cv::BOWImgDescriptorExtractor::create( const cv::Ptr<cv::Feature2D>&         dextractor
                                                                            const cv::Ptr<cv::DescriptorMatcher>& dmatcher )

AutoIt:
    cv.BOWImgDescriptorExtractor.create( $dextractor, $dmatcher ) -> <cv.BOWImgDescriptorExtractor object>

void cv::BOWImgDescriptorExtractor::setVocabulary( const cv::Mat& vocabulary )

AutoIt:
    cv.BOWImgDescriptorExtractor.setVocabulary( $vocabulary ) -> None

cv::Mat cv::BOWImgDescriptorExtractor::getVocabulary()

AutoIt:
    cv.BOWImgDescriptorExtractor.getVocabulary() -> retval

void cv::BOWImgDescriptorExtractor::compute( const cv::Mat&             image
                                             std::vector<cv::KeyPoint>& keypoints
                                             cv::Mat&                   imgDescriptor )

AutoIt:
    cv.BOWImgDescriptorExtractor.compute( $image, $keypoints[, $imgDescriptor] ) -> imgDescriptor

int cv::BOWImgDescriptorExtractor::descriptorSize()

AutoIt:
    cv.BOWImgDescriptorExtractor.descriptorSize() -> retval

int cv::BOWImgDescriptorExtractor::descriptorType()

AutoIt:
    cv.BOWImgDescriptorExtractor.descriptorType() -> retval

static cv::VideoCapture cv::VideoCapture::create()

AutoIt:
    cv.VideoCapture.create() -> <cv.VideoCapture object>

static cv::VideoCapture cv::VideoCapture::create( const std::string& filename
                                                  int                apiPreference = CAP_ANY )

AutoIt:
    cv.VideoCapture.create( $filename[, $apiPreference] ) -> <cv.VideoCapture object>

static cv::VideoCapture cv::VideoCapture::create( const std::string&      filename
                                                  int                     apiPreference
                                                  const std::vector<int>& params )

AutoIt:
    cv.VideoCapture.create( $filename, $apiPreference, $params ) -> <cv.VideoCapture object>

static cv::VideoCapture cv::VideoCapture::create( int index
                                                  int apiPreference = CAP_ANY )

AutoIt:
    cv.VideoCapture.create( $index[, $apiPreference] ) -> <cv.VideoCapture object>

static cv::VideoCapture cv::VideoCapture::create( int                     index
                                                  int                     apiPreference
                                                  const std::vector<int>& params )

AutoIt:
    cv.VideoCapture.create( $index, $apiPreference, $params ) -> <cv.VideoCapture object>

bool cv::VideoCapture::open( const std::string& filename
                             int                apiPreference = CAP_ANY )

AutoIt:
    cv.VideoCapture.open( $filename[, $apiPreference] ) -> retval

bool cv::VideoCapture::open( const std::string&      filename
                             int                     apiPreference
                             const std::vector<int>& params )

AutoIt:
    cv.VideoCapture.open( $filename, $apiPreference, $params ) -> retval

bool cv::VideoCapture::open( int index
                             int apiPreference = CAP_ANY )

AutoIt:
    cv.VideoCapture.open( $index[, $apiPreference] ) -> retval

bool cv::VideoCapture::open( int                     index
                             int                     apiPreference
                             const std::vector<int>& params )

AutoIt:
    cv.VideoCapture.open( $index, $apiPreference, $params ) -> retval

bool cv::VideoCapture::isOpened()

AutoIt:
    cv.VideoCapture.isOpened() -> retval

void cv::VideoCapture::release()

AutoIt:
    cv.VideoCapture.release() -> None

bool cv::VideoCapture::grab()

AutoIt:
    cv.VideoCapture.grab() -> retval

bool cv::VideoCapture::retrieve( _OutputArray image
                                 int          flag = 0 )

AutoIt:
    cv.VideoCapture.retrieve( [$image[, $flag]] ) -> retval, image

bool cv::VideoCapture::read( _OutputArray image )

AutoIt:
    cv.VideoCapture.read( [$image] ) -> retval, image

bool cv::VideoCapture::set( int    propId
                            double value )

AutoIt:
    cv.VideoCapture.set( $propId, $value ) -> retval

double cv::VideoCapture::get( int propId )

AutoIt:
    cv.VideoCapture.get( $propId ) -> retval

std::string cv::VideoCapture::getBackendName()

AutoIt:
    cv.VideoCapture.getBackendName() -> retval

void cv::VideoCapture::setExceptionMode( bool enable )

AutoIt:
    cv.VideoCapture.setExceptionMode( $enable ) -> None

bool cv::VideoCapture::getExceptionMode()

AutoIt:
    cv.VideoCapture.getExceptionMode() -> retval

static cv::VideoWriter cv::VideoWriter::create()

AutoIt:
    cv.VideoWriter.create() -> <cv.VideoWriter object>

static cv::VideoWriter cv::VideoWriter::create( const std::string& filename
                                                int                fourcc
                                                double             fps
                                                cv::Size           frameSize
                                                bool               isColor = true )

AutoIt:
    cv.VideoWriter.create( $filename, $fourcc, $fps, $frameSize[, $isColor] ) -> <cv.VideoWriter object>

static cv::VideoWriter cv::VideoWriter::create( const std::string& filename
                                                int                apiPreference
                                                int                fourcc
                                                double             fps
                                                cv::Size           frameSize
                                                bool               isColor = true )

AutoIt:
    cv.VideoWriter.create( $filename, $apiPreference, $fourcc, $fps, $frameSize[, $isColor] ) -> <cv.VideoWriter object>

static cv::VideoWriter cv::VideoWriter::create( const std::string&      filename
                                                int                     fourcc
                                                double                  fps
                                                const cv::Size&         frameSize
                                                const std::vector<int>& params )

AutoIt:
    cv.VideoWriter.create( $filename, $fourcc, $fps, $frameSize, $params ) -> <cv.VideoWriter object>

static cv::VideoWriter cv::VideoWriter::create( const std::string&      filename
                                                int                     apiPreference
                                                int                     fourcc
                                                double                  fps
                                                const cv::Size&         frameSize
                                                const std::vector<int>& params )

AutoIt:
    cv.VideoWriter.create( $filename, $apiPreference, $fourcc, $fps, $frameSize, $params ) -> <cv.VideoWriter object>

bool cv::VideoWriter::open( const std::string& filename
                            int                fourcc
                            double             fps
                            cv::Size           frameSize
                            bool               isColor = true )

AutoIt:
    cv.VideoWriter.open( $filename, $fourcc, $fps, $frameSize[, $isColor] ) -> retval

bool cv::VideoWriter::open( const std::string& filename
                            int                apiPreference
                            int                fourcc
                            double             fps
                            cv::Size           frameSize
                            bool               isColor = true )

AutoIt:
    cv.VideoWriter.open( $filename, $apiPreference, $fourcc, $fps, $frameSize[, $isColor] ) -> retval

bool cv::VideoWriter::open( const std::string&      filename
                            int                     fourcc
                            double                  fps
                            const cv::Size&         frameSize
                            const std::vector<int>& params )

AutoIt:
    cv.VideoWriter.open( $filename, $fourcc, $fps, $frameSize, $params ) -> retval

bool cv::VideoWriter::open( const std::string&      filename
                            int                     apiPreference
                            int                     fourcc
                            double                  fps
                            const cv::Size&         frameSize
                            const std::vector<int>& params )

AutoIt:
    cv.VideoWriter.open( $filename, $apiPreference, $fourcc, $fps, $frameSize, $params ) -> retval

bool cv::VideoWriter::isOpened()

AutoIt:
    cv.VideoWriter.isOpened() -> retval

void cv::VideoWriter::release()

AutoIt:
    cv.VideoWriter.release() -> None

void cv::VideoWriter::write( _InputArray image )

AutoIt:
    cv.VideoWriter.write( $image ) -> None

bool cv::VideoWriter::set( int    propId
                           double value )

AutoIt:
    cv.VideoWriter.set( $propId, $value ) -> retval

double cv::VideoWriter::get( int propId )

AutoIt:
    cv.VideoWriter.get( $propId ) -> retval

static int cv::VideoWriter::fourcc( char c1
                                    char c2
                                    char c3
                                    char c4 )

AutoIt:
    cv.VideoWriter.fourcc( $c1, $c2, $c3, $c4 ) -> retval

std::string cv::VideoWriter::getBackendName()

AutoIt:
    cv.VideoWriter.getBackendName() -> retval

std::string cv::videoio_registry::getBackendName( int api )

AutoIt:
    cv.videoio_registry.getBackendName( $api ) -> retval

std::vector<int> cv::videoio_registry::getBackends()

AutoIt:
    cv.videoio_registry.getBackends() -> retval

std::vector<int> cv::videoio_registry::getCameraBackends()

AutoIt:
    cv.videoio_registry.getCameraBackends() -> retval

std::vector<int> cv::videoio_registry::getStreamBackends()

AutoIt:
    cv.videoio_registry.getStreamBackends() -> retval

std::vector<int> cv::videoio_registry::getWriterBackends()

AutoIt:
    cv.videoio_registry.getWriterBackends() -> retval

bool cv::videoio_registry::hasBackend( int api )

AutoIt:
    cv.videoio_registry.hasBackend( $api ) -> retval

bool cv::videoio_registry::isBackendBuiltIn( int api )

AutoIt:
    cv.videoio_registry.isBackendBuiltIn( $api ) -> retval

std::string cv::videoio_registry::getCameraBackendPluginVersion( int  api
                                                                 int& version_ABI
                                                                 int& version_API )

AutoIt:
    cv.videoio_registry.getCameraBackendPluginVersion( $api[, $version_ABI[, $version_API]] ) -> retval, version_ABI, version_API

std::string cv::videoio_registry::getStreamBackendPluginVersion( int  api
                                                                 int& version_ABI
                                                                 int& version_API )

AutoIt:
    cv.videoio_registry.getStreamBackendPluginVersion( $api[, $version_ABI[, $version_API]] ) -> retval, version_ABI, version_API

std::string cv::videoio_registry::getWriterBackendPluginVersion( int  api
                                                                 int& version_ABI
                                                                 int& version_API )

AutoIt:
    cv.videoio_registry.getWriterBackendPluginVersion( $api[, $version_ABI[, $version_API]] ) -> retval, version_ABI, version_API

static cv::UsacParams cv::UsacParams::create()

AutoIt:
    cv.UsacParams.create() -> <cv.UsacParams object>

static cv::UsacParams cv::UsacParams::create()

AutoIt:
    cv.UsacParams.create() -> <cv.UsacParams object>

static cv::CirclesGridFinderParameters cv::CirclesGridFinderParameters::create()

AutoIt:
    cv.CirclesGridFinderParameters.create() -> <cv.CirclesGridFinderParameters object>

static cv::CirclesGridFinderParameters cv::CirclesGridFinderParameters::create()

AutoIt:
    cv.CirclesGridFinderParameters.create() -> <cv.CirclesGridFinderParameters object>

void cv::StereoMatcher::compute( _InputArray  left
                                 _InputArray  right
                                 _OutputArray disparity )

AutoIt:
    cv.StereoMatcher.compute( $left, $right[, $disparity] ) -> disparity

int cv::StereoMatcher::getMinDisparity()

AutoIt:
    cv.StereoMatcher.getMinDisparity() -> retval

void cv::StereoMatcher::setMinDisparity( int minDisparity )

AutoIt:
    cv.StereoMatcher.setMinDisparity( $minDisparity ) -> None

int cv::StereoMatcher::getNumDisparities()

AutoIt:
    cv.StereoMatcher.getNumDisparities() -> retval

void cv::StereoMatcher::setNumDisparities( int numDisparities )

AutoIt:
    cv.StereoMatcher.setNumDisparities( $numDisparities ) -> None

int cv::StereoMatcher::getBlockSize()

AutoIt:
    cv.StereoMatcher.getBlockSize() -> retval

void cv::StereoMatcher::setBlockSize( int blockSize )

AutoIt:
    cv.StereoMatcher.setBlockSize( $blockSize ) -> None

int cv::StereoMatcher::getSpeckleWindowSize()

AutoIt:
    cv.StereoMatcher.getSpeckleWindowSize() -> retval

void cv::StereoMatcher::setSpeckleWindowSize( int speckleWindowSize )

AutoIt:
    cv.StereoMatcher.setSpeckleWindowSize( $speckleWindowSize ) -> None

int cv::StereoMatcher::getSpeckleRange()

AutoIt:
    cv.StereoMatcher.getSpeckleRange() -> retval

void cv::StereoMatcher::setSpeckleRange( int speckleRange )

AutoIt:
    cv.StereoMatcher.setSpeckleRange( $speckleRange ) -> None

int cv::StereoMatcher::getDisp12MaxDiff()

AutoIt:
    cv.StereoMatcher.getDisp12MaxDiff() -> retval

void cv::StereoMatcher::setDisp12MaxDiff( int disp12MaxDiff )

AutoIt:
    cv.StereoMatcher.setDisp12MaxDiff( $disp12MaxDiff ) -> None

void cv::StereoMatcher::clear()

AutoIt:
    cv.StereoMatcher.clear() -> None

void cv::StereoMatcher::write( const cv::Ptr<cv::FileStorage>& fs
                               const std::string&              name = String() )

AutoIt:
    cv.StereoMatcher.write( $fs[, $name] ) -> None

void cv::StereoMatcher::read( const cv::FileNode& fn )

AutoIt:
    cv.StereoMatcher.read( $fn ) -> None

bool cv::StereoMatcher::empty()

AutoIt:
    cv.StereoMatcher.empty() -> retval

void cv::StereoMatcher::save( const std::string& filename )

AutoIt:
    cv.StereoMatcher.save( $filename ) -> None

std::string cv::StereoMatcher::getDefaultName()

AutoIt:
    cv.StereoMatcher.getDefaultName() -> retval

int cv::StereoBM::getPreFilterType()

AutoIt:
    cv.StereoBM.getPreFilterType() -> retval

void cv::StereoBM::setPreFilterType( int preFilterType )

AutoIt:
    cv.StereoBM.setPreFilterType( $preFilterType ) -> None

int cv::StereoBM::getPreFilterSize()

AutoIt:
    cv.StereoBM.getPreFilterSize() -> retval

void cv::StereoBM::setPreFilterSize( int preFilterSize )

AutoIt:
    cv.StereoBM.setPreFilterSize( $preFilterSize ) -> None

int cv::StereoBM::getPreFilterCap()

AutoIt:
    cv.StereoBM.getPreFilterCap() -> retval

void cv::StereoBM::setPreFilterCap( int preFilterCap )

AutoIt:
    cv.StereoBM.setPreFilterCap( $preFilterCap ) -> None

int cv::StereoBM::getTextureThreshold()

AutoIt:
    cv.StereoBM.getTextureThreshold() -> retval

void cv::StereoBM::setTextureThreshold( int textureThreshold )

AutoIt:
    cv.StereoBM.setTextureThreshold( $textureThreshold ) -> None

int cv::StereoBM::getUniquenessRatio()

AutoIt:
    cv.StereoBM.getUniquenessRatio() -> retval

void cv::StereoBM::setUniquenessRatio( int uniquenessRatio )

AutoIt:
    cv.StereoBM.setUniquenessRatio( $uniquenessRatio ) -> None

int cv::StereoBM::getSmallerBlockSize()

AutoIt:
    cv.StereoBM.getSmallerBlockSize() -> retval

void cv::StereoBM::setSmallerBlockSize( int blockSize )

AutoIt:
    cv.StereoBM.setSmallerBlockSize( $blockSize ) -> None

cv::Rect cv::StereoBM::getROI1()

AutoIt:
    cv.StereoBM.getROI1() -> retval

void cv::StereoBM::setROI1( cv::Rect roi1 )

AutoIt:
    cv.StereoBM.setROI1( $roi1 ) -> None

cv::Rect cv::StereoBM::getROI2()

AutoIt:
    cv.StereoBM.getROI2() -> retval

void cv::StereoBM::setROI2( cv::Rect roi2 )

AutoIt:
    cv.StereoBM.setROI2( $roi2 ) -> None

static cv::Ptr<cv::StereoBM> cv::StereoBM::create( int numDisparities = 0
                                                   int blockSize = 21 )

AutoIt:
    cv.StereoBM.create( [$numDisparities[, $blockSize]] ) -> retval

void cv::StereoBM::compute( _InputArray  left
                            _InputArray  right
                            _OutputArray disparity )

AutoIt:
    cv.StereoBM.compute( $left, $right[, $disparity] ) -> disparity

int cv::StereoBM::getMinDisparity()

AutoIt:
    cv.StereoBM.getMinDisparity() -> retval

void cv::StereoBM::setMinDisparity( int minDisparity )

AutoIt:
    cv.StereoBM.setMinDisparity( $minDisparity ) -> None

int cv::StereoBM::getNumDisparities()

AutoIt:
    cv.StereoBM.getNumDisparities() -> retval

void cv::StereoBM::setNumDisparities( int numDisparities )

AutoIt:
    cv.StereoBM.setNumDisparities( $numDisparities ) -> None

int cv::StereoBM::getBlockSize()

AutoIt:
    cv.StereoBM.getBlockSize() -> retval

void cv::StereoBM::setBlockSize( int blockSize )

AutoIt:
    cv.StereoBM.setBlockSize( $blockSize ) -> None

int cv::StereoBM::getSpeckleWindowSize()

AutoIt:
    cv.StereoBM.getSpeckleWindowSize() -> retval

void cv::StereoBM::setSpeckleWindowSize( int speckleWindowSize )

AutoIt:
    cv.StereoBM.setSpeckleWindowSize( $speckleWindowSize ) -> None

int cv::StereoBM::getSpeckleRange()

AutoIt:
    cv.StereoBM.getSpeckleRange() -> retval

void cv::StereoBM::setSpeckleRange( int speckleRange )

AutoIt:
    cv.StereoBM.setSpeckleRange( $speckleRange ) -> None

int cv::StereoBM::getDisp12MaxDiff()

AutoIt:
    cv.StereoBM.getDisp12MaxDiff() -> retval

void cv::StereoBM::setDisp12MaxDiff( int disp12MaxDiff )

AutoIt:
    cv.StereoBM.setDisp12MaxDiff( $disp12MaxDiff ) -> None

void cv::StereoBM::clear()

AutoIt:
    cv.StereoBM.clear() -> None

void cv::StereoBM::write( const cv::Ptr<cv::FileStorage>& fs
                          const std::string&              name = String() )

AutoIt:
    cv.StereoBM.write( $fs[, $name] ) -> None

void cv::StereoBM::read( const cv::FileNode& fn )

AutoIt:
    cv.StereoBM.read( $fn ) -> None

bool cv::StereoBM::empty()

AutoIt:
    cv.StereoBM.empty() -> retval

void cv::StereoBM::save( const std::string& filename )

AutoIt:
    cv.StereoBM.save( $filename ) -> None

std::string cv::StereoBM::getDefaultName()

AutoIt:
    cv.StereoBM.getDefaultName() -> retval

int cv::StereoSGBM::getPreFilterCap()

AutoIt:
    cv.StereoSGBM.getPreFilterCap() -> retval

void cv::StereoSGBM::setPreFilterCap( int preFilterCap )

AutoIt:
    cv.StereoSGBM.setPreFilterCap( $preFilterCap ) -> None

int cv::StereoSGBM::getUniquenessRatio()

AutoIt:
    cv.StereoSGBM.getUniquenessRatio() -> retval

void cv::StereoSGBM::setUniquenessRatio( int uniquenessRatio )

AutoIt:
    cv.StereoSGBM.setUniquenessRatio( $uniquenessRatio ) -> None

int cv::StereoSGBM::getP1()

AutoIt:
    cv.StereoSGBM.getP1() -> retval

void cv::StereoSGBM::setP1( int P1 )

AutoIt:
    cv.StereoSGBM.setP1( $P1 ) -> None

int cv::StereoSGBM::getP2()

AutoIt:
    cv.StereoSGBM.getP2() -> retval

void cv::StereoSGBM::setP2( int P2 )

AutoIt:
    cv.StereoSGBM.setP2( $P2 ) -> None

int cv::StereoSGBM::getMode()

AutoIt:
    cv.StereoSGBM.getMode() -> retval

void cv::StereoSGBM::setMode( int mode )

AutoIt:
    cv.StereoSGBM.setMode( $mode ) -> None

static cv::Ptr<cv::StereoSGBM> cv::StereoSGBM::create( int minDisparity = 0
                                                       int numDisparities = 16
                                                       int blockSize = 3
                                                       int P1 = 0
                                                       int P2 = 0
                                                       int disp12MaxDiff = 0
                                                       int preFilterCap = 0
                                                       int uniquenessRatio = 0
                                                       int speckleWindowSize = 0
                                                       int speckleRange = 0
                                                       int mode = StereoSGBM::MODE_SGBM )

AutoIt:
    cv.StereoSGBM.create( [$minDisparity[, $numDisparities[, $blockSize[, $P1[, $P2[, $disp12MaxDiff[, $preFilterCap[, $uniquenessRatio[, $speckleWindowSize[, $speckleRange[, $mode]]]]]]]]]]] ) -> retval

void cv::StereoSGBM::compute( _InputArray  left
                              _InputArray  right
                              _OutputArray disparity )

AutoIt:
    cv.StereoSGBM.compute( $left, $right[, $disparity] ) -> disparity

int cv::StereoSGBM::getMinDisparity()

AutoIt:
    cv.StereoSGBM.getMinDisparity() -> retval

void cv::StereoSGBM::setMinDisparity( int minDisparity )

AutoIt:
    cv.StereoSGBM.setMinDisparity( $minDisparity ) -> None

int cv::StereoSGBM::getNumDisparities()

AutoIt:
    cv.StereoSGBM.getNumDisparities() -> retval

void cv::StereoSGBM::setNumDisparities( int numDisparities )

AutoIt:
    cv.StereoSGBM.setNumDisparities( $numDisparities ) -> None

int cv::StereoSGBM::getBlockSize()

AutoIt:
    cv.StereoSGBM.getBlockSize() -> retval

void cv::StereoSGBM::setBlockSize( int blockSize )

AutoIt:
    cv.StereoSGBM.setBlockSize( $blockSize ) -> None

int cv::StereoSGBM::getSpeckleWindowSize()

AutoIt:
    cv.StereoSGBM.getSpeckleWindowSize() -> retval

void cv::StereoSGBM::setSpeckleWindowSize( int speckleWindowSize )

AutoIt:
    cv.StereoSGBM.setSpeckleWindowSize( $speckleWindowSize ) -> None

int cv::StereoSGBM::getSpeckleRange()

AutoIt:
    cv.StereoSGBM.getSpeckleRange() -> retval

void cv::StereoSGBM::setSpeckleRange( int speckleRange )

AutoIt:
    cv.StereoSGBM.setSpeckleRange( $speckleRange ) -> None

int cv::StereoSGBM::getDisp12MaxDiff()

AutoIt:
    cv.StereoSGBM.getDisp12MaxDiff() -> retval

void cv::StereoSGBM::setDisp12MaxDiff( int disp12MaxDiff )

AutoIt:
    cv.StereoSGBM.setDisp12MaxDiff( $disp12MaxDiff ) -> None

void cv::StereoSGBM::clear()

AutoIt:
    cv.StereoSGBM.clear() -> None

void cv::StereoSGBM::write( const cv::Ptr<cv::FileStorage>& fs
                            const std::string&              name = String() )

AutoIt:
    cv.StereoSGBM.write( $fs[, $name] ) -> None

void cv::StereoSGBM::read( const cv::FileNode& fn )

AutoIt:
    cv.StereoSGBM.read( $fn ) -> None

bool cv::StereoSGBM::empty()

AutoIt:
    cv.StereoSGBM.empty() -> retval

void cv::StereoSGBM::save( const std::string& filename )

AutoIt:
    cv.StereoSGBM.save( $filename ) -> None

std::string cv::StereoSGBM::getDefaultName()

AutoIt:
    cv.StereoSGBM.getDefaultName() -> retval

void cv::fisheye::projectPoints( _InputArray  objectPoints
                                 _OutputArray imagePoints
                                 _InputArray  rvec
                                 _InputArray  tvec
                                 _InputArray  K
                                 _InputArray  D
                                 double       alpha = 0
                                 _OutputArray jacobian = noArray() )

AutoIt:
    cv.fisheye.projectPoints( $objectPoints, $rvec, $tvec, $K, $D[, $imagePoints[, $alpha[, $jacobian]]] ) -> imagePoints, jacobian

void cv::fisheye::distortPoints( _InputArray  undistorted
                                 _OutputArray distorted
                                 _InputArray  K
                                 _InputArray  D
                                 double       alpha = 0 )

AutoIt:
    cv.fisheye.distortPoints( $undistorted, $K, $D[, $distorted[, $alpha]] ) -> distorted

void cv::fisheye::undistortPoints( _InputArray  distorted
                                   _OutputArray undistorted
                                   _InputArray  K
                                   _InputArray  D
                                   _InputArray  R = noArray()
                                   _InputArray  P = noArray() )

AutoIt:
    cv.fisheye.undistortPoints( $distorted, $K, $D[, $undistorted[, $R[, $P]]] ) -> undistorted

void cv::fisheye::initUndistortRectifyMap( _InputArray     K
                                           _InputArray     D
                                           _InputArray     R
                                           _InputArray     P
                                           const cv::Size& size
                                           int             m1type
                                           _OutputArray    map1
                                           _OutputArray    map2 )

AutoIt:
    cv.fisheye.initUndistortRectifyMap( $K, $D, $R, $P, $size, $m1type[, $map1[, $map2]] ) -> map1, map2

void cv::fisheye::undistortImage( _InputArray     distorted
                                  _OutputArray    undistorted
                                  _InputArray     K
                                  _InputArray     D
                                  _InputArray     Knew = cv::noArray()
                                  const cv::Size& new_size = Size() )

AutoIt:
    cv.fisheye.undistortImage( $distorted, $K, $D[, $undistorted[, $Knew[, $new_size]]] ) -> undistorted

void cv::fisheye::estimateNewCameraMatrixForUndistortRectify( _InputArray     K
                                                              _InputArray     D
                                                              const cv::Size& image_size
                                                              _InputArray     R
                                                              _OutputArray    P
                                                              double          balance = 0.0
                                                              const cv::Size& new_size = Size()
                                                              double          fov_scale = 1.0 )

AutoIt:
    cv.fisheye.estimateNewCameraMatrixForUndistortRectify( $K, $D, $image_size, $R[, $P[, $balance[, $new_size[, $fov_scale]]]] ) -> P

double cv::fisheye::calibrate( _InputArray       objectPoints
                               _InputArray       imagePoints
                               const cv::Size&   image_size
                               _InputOutputArray K
                               _InputOutputArray D
                               _OutputArray      rvecs
                               _OutputArray      tvecs
                               int               flags = 0
                               cv::TermCriteria  criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) )

AutoIt:
    cv.fisheye.calibrate( $objectPoints, $imagePoints, $image_size, $K, $D[, $rvecs[, $tvecs[, $flags[, $criteria]]]] ) -> retval, K, D, rvecs, tvecs

void cv::fisheye::stereoRectify( _InputArray     K1
                                 _InputArray     D1
                                 _InputArray     K2
                                 _InputArray     D2
                                 const cv::Size& imageSize
                                 _InputArray     R
                                 _InputArray     tvec
                                 _OutputArray    R1
                                 _OutputArray    R2
                                 _OutputArray    P1
                                 _OutputArray    P2
                                 _OutputArray    Q
                                 int             flags
                                 const cv::Size& newImageSize = Size()
                                 double          balance = 0.0
                                 double          fov_scale = 1.0 )

AutoIt:
    cv.fisheye.stereoRectify( $K1, $D1, $K2, $D2, $imageSize, $R, $tvec, $flags[, $R1[, $R2[, $P1[, $P2[, $Q[, $newImageSize[, $balance[, $fov_scale]]]]]]]] ) -> R1, R2, P1, P2, Q

double cv::fisheye::stereoCalibrate( _InputArray       objectPoints
                                     _InputArray       imagePoints1
                                     _InputArray       imagePoints2
                                     _InputOutputArray K1
                                     _InputOutputArray D1
                                     _InputOutputArray K2
                                     _InputOutputArray D2
                                     cv::Size          imageSize
                                     _OutputArray      R
                                     _OutputArray      T
                                     int               flags = fisheye::CALIB_FIX_INTRINSIC
                                     cv::TermCriteria  criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) )

AutoIt:
    cv.fisheye.stereoCalibrate( $objectPoints, $imagePoints1, $imagePoints2, $K1, $D1, $K2, $D2, $imageSize[, $R[, $T[, $flags[, $criteria]]]] ) -> retval, K1, D1, K2, D2, R, T

void cv::BaseCascadeClassifier::clear()

AutoIt:
    cv.BaseCascadeClassifier.clear() -> None

void cv::BaseCascadeClassifier::write( const cv::Ptr<cv::FileStorage>& fs
                                       const std::string&              name = String() )

AutoIt:
    cv.BaseCascadeClassifier.write( $fs[, $name] ) -> None

void cv::BaseCascadeClassifier::read( const cv::FileNode& fn )

AutoIt:
    cv.BaseCascadeClassifier.read( $fn ) -> None

bool cv::BaseCascadeClassifier::empty()

AutoIt:
    cv.BaseCascadeClassifier.empty() -> retval

void cv::BaseCascadeClassifier::save( const std::string& filename )

AutoIt:
    cv.BaseCascadeClassifier.save( $filename ) -> None

std::string cv::BaseCascadeClassifier::getDefaultName()

AutoIt:
    cv.BaseCascadeClassifier.getDefaultName() -> retval

static cv::CascadeClassifier cv::CascadeClassifier::create()

AutoIt:
    cv.CascadeClassifier.create() -> <cv.CascadeClassifier object>

static cv::CascadeClassifier cv::CascadeClassifier::create( const std::string& filename )

AutoIt:
    cv.CascadeClassifier.create( $filename ) -> <cv.CascadeClassifier object>

bool cv::CascadeClassifier::empty()

AutoIt:
    cv.CascadeClassifier.empty() -> retval

bool cv::CascadeClassifier::load( const std::string& filename )

AutoIt:
    cv.CascadeClassifier.load( $filename ) -> retval

bool cv::CascadeClassifier::read( const cv::FileNode& node )

AutoIt:
    cv.CascadeClassifier.read( $node ) -> retval

void cv::CascadeClassifier::detectMultiScale( _InputArray            image
                                              std::vector<cv::Rect>& objects
                                              double                 scaleFactor = 1.1
                                              int                    minNeighbors = 3
                                              int                    flags = 0
                                              cv::Size               minSize = Size()
                                              cv::Size               maxSize = Size() )

AutoIt:
    cv.CascadeClassifier.detectMultiScale( $image[, $scaleFactor[, $minNeighbors[, $flags[, $minSize[, $maxSize[, $objects]]]]]] ) -> objects

void cv::CascadeClassifier::detectMultiScale2( _InputArray            image
                                               std::vector<cv::Rect>& objects
                                               std::vector<int>&      numDetections
                                               double                 scaleFactor = 1.1
                                               int                    minNeighbors = 3
                                               int                    flags = 0
                                               cv::Size               minSize = Size()
                                               cv::Size               maxSize = Size() )

AutoIt:
    cv.CascadeClassifier.detectMultiScale2( $image[, $scaleFactor[, $minNeighbors[, $flags[, $minSize[, $maxSize[, $objects[, $numDetections]]]]]]] ) -> objects, numDetections

void cv::CascadeClassifier::detectMultiScale3( _InputArray            image
                                               std::vector<cv::Rect>& objects
                                               std::vector<int>&      rejectLevels
                                               std::vector<double>&   levelWeights
                                               double                 scaleFactor = 1.1
                                               int                    minNeighbors = 3
                                               int                    flags = 0
                                               cv::Size               minSize = Size()
                                               cv::Size               maxSize = Size()
                                               bool                   outputRejectLevels = false )

AutoIt:
    cv.CascadeClassifier.detectMultiScale3( $image[, $scaleFactor[, $minNeighbors[, $flags[, $minSize[, $maxSize[, $outputRejectLevels[, $objects[, $rejectLevels[, $levelWeights]]]]]]]]] ) -> objects, rejectLevels, levelWeights

bool cv::CascadeClassifier::isOldFormatCascade()

AutoIt:
    cv.CascadeClassifier.isOldFormatCascade() -> retval

cv::Size cv::CascadeClassifier::getOriginalWindowSize()

AutoIt:
    cv.CascadeClassifier.getOriginalWindowSize() -> retval

int cv::CascadeClassifier::getFeatureType()

AutoIt:
    cv.CascadeClassifier.getFeatureType() -> retval

static bool cv::CascadeClassifier::convert( const std::string& oldcascade
                                            const std::string& newcascade )

AutoIt:
    cv.CascadeClassifier.convert( $oldcascade, $newcascade ) -> retval

static cv::HOGDescriptor cv::HOGDescriptor::create()

AutoIt:
    cv.HOGDescriptor.create() -> <cv.HOGDescriptor object>

static cv::HOGDescriptor cv::HOGDescriptor::create()

AutoIt:
    cv.HOGDescriptor.create() -> <cv.HOGDescriptor object>

static cv::HOGDescriptor cv::HOGDescriptor::create( cv::Size _winSize
                                                    cv::Size _blockSize
                                                    cv::Size _blockStride
                                                    cv::Size _cellSize
                                                    int      _nbins
                                                    int      _derivAperture = 1
                                                    double   _winSigma = -1
                                                    int      _histogramNormType = HOGDescriptor::L2Hys
                                                    double   _L2HysThreshold = 0.2
                                                    bool     _gammaCorrection = false
                                                    int      _nlevels = HOGDescriptor::DEFAULT_NLEVELS
                                                    bool     _signedGradient = false )

AutoIt:
    cv.HOGDescriptor.create( $_winSize, $_blockSize, $_blockStride, $_cellSize, $_nbins[, $_derivAperture[, $_winSigma[, $_histogramNormType[, $_L2HysThreshold[, $_gammaCorrection[, $_nlevels[, $_signedGradient]]]]]]] ) -> <cv.HOGDescriptor object>

static cv::HOGDescriptor cv::HOGDescriptor::create( const std::string& filename )

AutoIt:
    cv.HOGDescriptor.create( $filename ) -> <cv.HOGDescriptor object>

size_t cv::HOGDescriptor::getDescriptorSize()

AutoIt:
    cv.HOGDescriptor.getDescriptorSize() -> retval

bool cv::HOGDescriptor::checkDetectorSize()

AutoIt:
    cv.HOGDescriptor.checkDetectorSize() -> retval

double cv::HOGDescriptor::getWinSigma()

AutoIt:
    cv.HOGDescriptor.getWinSigma() -> retval

void cv::HOGDescriptor::setSVMDetector( _InputArray svmdetector )

AutoIt:
    cv.HOGDescriptor.setSVMDetector( $svmdetector ) -> None

bool cv::HOGDescriptor::load( const std::string& filename
                              const std::string& objname = String() )

AutoIt:
    cv.HOGDescriptor.load( $filename[, $objname] ) -> retval

void cv::HOGDescriptor::save( const std::string& filename
                              const std::string& objname = String() )

AutoIt:
    cv.HOGDescriptor.save( $filename[, $objname] ) -> None

void cv::HOGDescriptor::compute( _InputArray                   img
                                 std::vector<float>&           descriptors
                                 cv::Size                      winStride = Size()
                                 cv::Size                      padding = Size()
                                 const std::vector<cv::Point>& locations = std::vector<Point>() )

AutoIt:
    cv.HOGDescriptor.compute( $img[, $winStride[, $padding[, $locations[, $descriptors]]]] ) -> descriptors

void cv::HOGDescriptor::detect( _InputArray                   img
                                std::vector<cv::Point>&       foundLocations
                                std::vector<double>&          weights
                                double                        hitThreshold = 0
                                cv::Size                      winStride = Size()
                                cv::Size                      padding = Size()
                                const std::vector<cv::Point>& searchLocations = std::vector<Point>() )

AutoIt:
    cv.HOGDescriptor.detect( $img[, $hitThreshold[, $winStride[, $padding[, $searchLocations[, $foundLocations[, $weights]]]]]] ) -> foundLocations, weights

void cv::HOGDescriptor::detectMultiScale( _InputArray            img
                                          std::vector<cv::Rect>& foundLocations
                                          std::vector<double>&   foundWeights
                                          double                 hitThreshold = 0
                                          cv::Size               winStride = Size()
                                          cv::Size               padding = Size()
                                          double                 scale = 1.05
                                          double                 finalThreshold = 2.0
                                          bool                   useMeanshiftGrouping = false )

AutoIt:
    cv.HOGDescriptor.detectMultiScale( $img[, $hitThreshold[, $winStride[, $padding[, $scale[, $finalThreshold[, $useMeanshiftGrouping[, $foundLocations[, $foundWeights]]]]]]]] ) -> foundLocations, foundWeights

void cv::HOGDescriptor::computeGradient( _InputArray       img
                                         _InputOutputArray grad
                                         _InputOutputArray angleOfs
                                         cv::Size          paddingTL = Size()
                                         cv::Size          paddingBR = Size() )

AutoIt:
    cv.HOGDescriptor.computeGradient( $img, $grad, $angleOfs[, $paddingTL[, $paddingBR]] ) -> grad, angleOfs

static std::vector<float> cv::HOGDescriptor::getDefaultPeopleDetector()

AutoIt:
    cv.HOGDescriptor.getDefaultPeopleDetector() -> retval

static std::vector<float> cv::HOGDescriptor::getDaimlerPeopleDetector()

AutoIt:
    cv.HOGDescriptor.getDaimlerPeopleDetector() -> retval

static cv::Ptr<cv::QRCodeEncoder> cv::QRCodeEncoder::create( const cv::QRCodeEncoder::Params& parameters = QRCodeEncoder::Params() )

AutoIt:
    cv.QRCodeEncoder.create( [$parameters] ) -> retval

void cv::QRCodeEncoder::encode( const std::string& encoded_info
                                _OutputArray       qrcode )

AutoIt:
    cv.QRCodeEncoder.encode( $encoded_info[, $qrcode] ) -> qrcode

void cv::QRCodeEncoder::encodeStructuredAppend( const std::string& encoded_info
                                                _OutputArray       qrcodes )

AutoIt:
    cv.QRCodeEncoder.encodeStructuredAppend( $encoded_info[, $qrcodes] ) -> qrcodes

static cv::QRCodeEncoder::Params cv::QRCodeEncoder::Params::create()

AutoIt:
    cv.QRCodeEncoder.Params.create() -> <cv.QRCodeEncoder.Params object>

static cv::QRCodeEncoder::Params cv::QRCodeEncoder::Params::create()

AutoIt:
    cv.QRCodeEncoder.Params.create() -> <cv.QRCodeEncoder.Params object>

static cv::QRCodeDetector cv::QRCodeDetector::create()

AutoIt:
    cv.QRCodeDetector.create() -> <cv.QRCodeDetector object>

void cv::QRCodeDetector::setEpsX( double epsX )

AutoIt:
    cv.QRCodeDetector.setEpsX( $epsX ) -> None

void cv::QRCodeDetector::setEpsY( double epsY )

AutoIt:
    cv.QRCodeDetector.setEpsY( $epsY ) -> None

bool cv::QRCodeDetector::detect( _InputArray  img
                                 _OutputArray points )

AutoIt:
    cv.QRCodeDetector.detect( $img[, $points] ) -> retval, points

std::string cv::QRCodeDetector::decode( _InputArray  img
                                        _InputArray  points
                                        _OutputArray straight_qrcode = noArray() )

AutoIt:
    cv.QRCodeDetector.decode( $img, $points[, $straight_qrcode] ) -> retval, straight_qrcode

std::string cv::QRCodeDetector::decodeCurved( _InputArray  img
                                              _InputArray  points
                                              _OutputArray straight_qrcode = noArray() )

AutoIt:
    cv.QRCodeDetector.decodeCurved( $img, $points[, $straight_qrcode] ) -> retval, straight_qrcode

std::string cv::QRCodeDetector::detectAndDecode( _InputArray  img
                                                 _OutputArray points = noArray()
                                                 _OutputArray straight_qrcode = noArray() )

AutoIt:
    cv.QRCodeDetector.detectAndDecode( $img[, $points[, $straight_qrcode]] ) -> retval, points, straight_qrcode

std::string cv::QRCodeDetector::detectAndDecodeCurved( _InputArray  img
                                                       _OutputArray points = noArray()
                                                       _OutputArray straight_qrcode = noArray() )

AutoIt:
    cv.QRCodeDetector.detectAndDecodeCurved( $img[, $points[, $straight_qrcode]] ) -> retval, points, straight_qrcode

bool cv::QRCodeDetector::detectMulti( _InputArray  img
                                      _OutputArray points )

AutoIt:
    cv.QRCodeDetector.detectMulti( $img[, $points] ) -> retval, points

bool cv::QRCodeDetector::decodeMulti( _InputArray               img
                                      _InputArray               points
                                      std::vector<std::string>& decoded_info
                                      _OutputArray              straight_qrcode = noArray() )

AutoIt:
    cv.QRCodeDetector.decodeMulti( $img, $points[, $straight_qrcode[, $decoded_info]] ) -> retval, decoded_info, straight_qrcode

bool cv::QRCodeDetector::detectAndDecodeMulti( _InputArray               img
                                               std::vector<std::string>& decoded_info
                                               _OutputArray              points = noArray()
                                               _OutputArray              straight_qrcode = noArray() )

AutoIt:
    cv.QRCodeDetector.detectAndDecodeMulti( $img[, $points[, $straight_qrcode[, $decoded_info]]] ) -> retval, decoded_info, points, straight_qrcode

void cv::FaceDetectorYN::setInputSize( const cv::Size& input_size )

AutoIt:
    cv.FaceDetectorYN.setInputSize( $input_size ) -> None

cv::Size cv::FaceDetectorYN::getInputSize()

AutoIt:
    cv.FaceDetectorYN.getInputSize() -> retval

void cv::FaceDetectorYN::setScoreThreshold( float score_threshold )

AutoIt:
    cv.FaceDetectorYN.setScoreThreshold( $score_threshold ) -> None

float cv::FaceDetectorYN::getScoreThreshold()

AutoIt:
    cv.FaceDetectorYN.getScoreThreshold() -> retval

void cv::FaceDetectorYN::setNMSThreshold( float nms_threshold )

AutoIt:
    cv.FaceDetectorYN.setNMSThreshold( $nms_threshold ) -> None

float cv::FaceDetectorYN::getNMSThreshold()

AutoIt:
    cv.FaceDetectorYN.getNMSThreshold() -> retval

void cv::FaceDetectorYN::setTopK( int top_k )

AutoIt:
    cv.FaceDetectorYN.setTopK( $top_k ) -> None

int cv::FaceDetectorYN::getTopK()

AutoIt:
    cv.FaceDetectorYN.getTopK() -> retval

int cv::FaceDetectorYN::detect( _InputArray  image
                                _OutputArray faces )

AutoIt:
    cv.FaceDetectorYN.detect( $image[, $faces] ) -> retval, faces

static cv::Ptr<cv::FaceDetectorYN> cv::FaceDetectorYN::create( const std::string& model
                                                               const std::string& config
                                                               const cv::Size&    input_size
                                                               float              score_threshold = 0.9f
                                                               float              nms_threshold = 0.3f
                                                               int                top_k = 5000
                                                               int                backend_id = 0
                                                               int                target_id = 0 )

AutoIt:
    cv.FaceDetectorYN.create( $model, $config, $input_size[, $score_threshold[, $nms_threshold[, $top_k[, $backend_id[, $target_id]]]]] ) -> retval

void cv::FaceRecognizerSF::alignCrop( _InputArray  src_img
                                      _InputArray  face_box
                                      _OutputArray aligned_img )

AutoIt:
    cv.FaceRecognizerSF.alignCrop( $src_img, $face_box[, $aligned_img] ) -> aligned_img

void cv::FaceRecognizerSF::feature( _InputArray  aligned_img
                                    _OutputArray face_feature )

AutoIt:
    cv.FaceRecognizerSF.feature( $aligned_img[, $face_feature] ) -> face_feature

double cv::FaceRecognizerSF::match( _InputArray _face_feature1
                                    _InputArray _face_feature2
                                    int         dis_type = FaceRecognizerSF::FR_COSINE )

AutoIt:
    cv.FaceRecognizerSF.match( $_face_feature1, $_face_feature2[, $dis_type] ) -> retval

static cv::Ptr<cv::FaceRecognizerSF> cv::FaceRecognizerSF::create( const std::string& model
                                                                   const std::string& config
                                                                   int                backend_id = 0
                                                                   int                target_id = 0 )

AutoIt:
    cv.FaceRecognizerSF.create( $model, $config[, $backend_id[, $target_id]] ) -> retval

static cv::Ptr<cv::Stitcher> cv::Stitcher::create( int mode = Stitcher::PANORAMA )

AutoIt:
    cv.Stitcher.create( [$mode] ) -> retval

double cv::Stitcher::registrationResol()

AutoIt:
    cv.Stitcher.registrationResol() -> retval

void cv::Stitcher::setRegistrationResol( double resol_mpx )

AutoIt:
    cv.Stitcher.setRegistrationResol( $resol_mpx ) -> None

double cv::Stitcher::seamEstimationResol()

AutoIt:
    cv.Stitcher.seamEstimationResol() -> retval

void cv::Stitcher::setSeamEstimationResol( double resol_mpx )

AutoIt:
    cv.Stitcher.setSeamEstimationResol( $resol_mpx ) -> None

double cv::Stitcher::compositingResol()

AutoIt:
    cv.Stitcher.compositingResol() -> retval

void cv::Stitcher::setCompositingResol( double resol_mpx )

AutoIt:
    cv.Stitcher.setCompositingResol( $resol_mpx ) -> None

double cv::Stitcher::panoConfidenceThresh()

AutoIt:
    cv.Stitcher.panoConfidenceThresh() -> retval

void cv::Stitcher::setPanoConfidenceThresh( double conf_thresh )

AutoIt:
    cv.Stitcher.setPanoConfidenceThresh( $conf_thresh ) -> None

bool cv::Stitcher::waveCorrection()

AutoIt:
    cv.Stitcher.waveCorrection() -> retval

void cv::Stitcher::setWaveCorrection( bool flag )

AutoIt:
    cv.Stitcher.setWaveCorrection( $flag ) -> None

int cv::Stitcher::interpolationFlags()

AutoIt:
    cv.Stitcher.interpolationFlags() -> retval

void cv::Stitcher::setInterpolationFlags( int interp_flags )

AutoIt:
    cv.Stitcher.setInterpolationFlags( $interp_flags ) -> None

int cv::Stitcher::estimateTransform( _InputArray images
                                     _InputArray masks = noArray() )

AutoIt:
    cv.Stitcher.estimateTransform( $images[, $masks] ) -> retval

int cv::Stitcher::composePanorama( _OutputArray pano )

AutoIt:
    cv.Stitcher.composePanorama( [$pano] ) -> retval, pano

int cv::Stitcher::composePanorama( _InputArray  images
                                   _OutputArray pano )

AutoIt:
    cv.Stitcher.composePanorama( $images[, $pano] ) -> retval, pano

int cv::Stitcher::stitch( _InputArray  images
                          _OutputArray pano )

AutoIt:
    cv.Stitcher.stitch( $images[, $pano] ) -> retval, pano

int cv::Stitcher::stitch( _InputArray  images
                          _InputArray  masks
                          _OutputArray pano )

AutoIt:
    cv.Stitcher.stitch( $images, $masks[, $pano] ) -> retval, pano

double cv::Stitcher::workScale()

AutoIt:
    cv.Stitcher.workScale() -> retval

static cv::PyRotationWarper cv::PyRotationWarper::create( std::string type
                                                          float       scale )

AutoIt:
    cv.PyRotationWarper.create( $type, $scale ) -> <cv.PyRotationWarper object>

static cv::PyRotationWarper cv::PyRotationWarper::create()

AutoIt:
    cv.PyRotationWarper.create() -> <cv.PyRotationWarper object>

cv::Point2f cv::PyRotationWarper::warpPoint( const cv::Point2f& pt
                                             _InputArray        K
                                             _InputArray        R )

AutoIt:
    cv.PyRotationWarper.warpPoint( $pt, $K, $R ) -> retval

cv::Point2f cv::PyRotationWarper::warpPointBackward( const cv::Point2f& pt
                                                     _InputArray        K
                                                     _InputArray        R )

AutoIt:
    cv.PyRotationWarper.warpPointBackward( $pt, $K, $R ) -> retval

cv::Point2f cv::PyRotationWarper::warpPointBackward( const cv::Point2f& pt
                                                     _InputArray        K
                                                     _InputArray        R )

AutoIt:
    cv.PyRotationWarper.warpPointBackward( $pt, $K, $R ) -> retval

cv::Rect cv::PyRotationWarper::buildMaps( cv::Size     src_size
                                          _InputArray  K
                                          _InputArray  R
                                          _OutputArray xmap
                                          _OutputArray ymap )

AutoIt:
    cv.PyRotationWarper.buildMaps( $src_size, $K, $R[, $xmap[, $ymap]] ) -> retval, xmap, ymap

cv::Point cv::PyRotationWarper::warp( _InputArray  src
                                      _InputArray  K
                                      _InputArray  R
                                      int          interp_mode
                                      int          border_mode
                                      _OutputArray dst )

AutoIt:
    cv.PyRotationWarper.warp( $src, $K, $R, $interp_mode, $border_mode[, $dst] ) -> retval, dst

void cv::PyRotationWarper::warpBackward( _InputArray  src
                                         _InputArray  K
                                         _InputArray  R
                                         int          interp_mode
                                         int          border_mode
                                         cv::Size     dst_size
                                         _OutputArray dst )

AutoIt:
    cv.PyRotationWarper.warpBackward( $src, $K, $R, $interp_mode, $border_mode, $dst_size[, $dst] ) -> dst

cv::Rect cv::PyRotationWarper::warpRoi( cv::Size    src_size
                                        _InputArray K
                                        _InputArray R )

AutoIt:
    cv.PyRotationWarper.warpRoi( $src_size, $K, $R ) -> retval

float cv::PyRotationWarper::getScale()

AutoIt:
    cv.PyRotationWarper.getScale() -> retval

void cv::PyRotationWarper::setScale( float arg1 )

AutoIt:
    cv.PyRotationWarper.setScale( $arg1 ) -> None

static cv::Ptr<cv::detail::Blender> cv::detail::Blender::createDefault( int  type
                                                                        bool try_gpu = false )

AutoIt:
    cv.detail.Blender.createDefault( $type[, $try_gpu] ) -> retval

void cv::detail::Blender::prepare( const std::vector<cv::Point>& corners
                                   const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.Blender.prepare( $corners, $sizes ) -> None

void cv::detail::Blender::prepare( cv::Rect dst_roi )

AutoIt:
    cv.detail.Blender.prepare( $dst_roi ) -> None

void cv::detail::Blender::feed( _InputArray img
                                _InputArray mask
                                cv::Point   tl )

AutoIt:
    cv.detail.Blender.feed( $img, $mask, $tl ) -> None

void cv::detail::Blender::blend( _InputOutputArray dst
                                 _InputOutputArray dst_mask )

AutoIt:
    cv.detail.Blender.blend( $dst, $dst_mask ) -> dst, dst_mask

static cv::detail::FeatherBlender cv::detail::FeatherBlender::create( float sharpness = 0.02f )

AutoIt:
    cv.detail.FeatherBlender.create( [$sharpness] ) -> <cv.detail.FeatherBlender object>

float cv::detail::FeatherBlender::sharpness()

AutoIt:
    cv.detail.FeatherBlender.sharpness() -> retval

void cv::detail::FeatherBlender::setSharpness( float val )

AutoIt:
    cv.detail.FeatherBlender.setSharpness( $val ) -> None

void cv::detail::FeatherBlender::prepare( cv::Rect dst_roi )

AutoIt:
    cv.detail.FeatherBlender.prepare( $dst_roi ) -> None

void cv::detail::FeatherBlender::prepare( const std::vector<cv::Point>& corners
                                          const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.FeatherBlender.prepare( $corners, $sizes ) -> None

void cv::detail::FeatherBlender::feed( _InputArray img
                                       _InputArray mask
                                       cv::Point   tl )

AutoIt:
    cv.detail.FeatherBlender.feed( $img, $mask, $tl ) -> None

void cv::detail::FeatherBlender::blend( _InputOutputArray dst
                                        _InputOutputArray dst_mask )

AutoIt:
    cv.detail.FeatherBlender.blend( $dst, $dst_mask ) -> dst, dst_mask

cv::Rect cv::detail::FeatherBlender::createWeightMaps( const std::vector<cv::UMat>&  masks
                                                       const std::vector<cv::Point>& corners
                                                       std::vector<cv::UMat>&        weight_maps )

AutoIt:
    cv.detail.FeatherBlender.createWeightMaps( $masks, $corners, $weight_maps ) -> retval, weight_maps

static cv::Ptr<cv::detail::Blender> cv::detail::FeatherBlender::createDefault( int  type
                                                                               bool try_gpu = false )

AutoIt:
    cv.detail.FeatherBlender.createDefault( $type[, $try_gpu] ) -> retval

static cv::detail::MultiBandBlender cv::detail::MultiBandBlender::create( int try_gpu = false
                                                                          int num_bands = 5
                                                                          int weight_type = CV_32F )

AutoIt:
    cv.detail.MultiBandBlender.create( [$try_gpu[, $num_bands[, $weight_type]]] ) -> <cv.detail.MultiBandBlender object>

int cv::detail::MultiBandBlender::numBands()

AutoIt:
    cv.detail.MultiBandBlender.numBands() -> retval

void cv::detail::MultiBandBlender::setNumBands( int val )

AutoIt:
    cv.detail.MultiBandBlender.setNumBands( $val ) -> None

void cv::detail::MultiBandBlender::prepare( cv::Rect dst_roi )

AutoIt:
    cv.detail.MultiBandBlender.prepare( $dst_roi ) -> None

void cv::detail::MultiBandBlender::prepare( const std::vector<cv::Point>& corners
                                            const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.MultiBandBlender.prepare( $corners, $sizes ) -> None

void cv::detail::MultiBandBlender::feed( _InputArray img
                                         _InputArray mask
                                         cv::Point   tl )

AutoIt:
    cv.detail.MultiBandBlender.feed( $img, $mask, $tl ) -> None

void cv::detail::MultiBandBlender::blend( _InputOutputArray dst
                                          _InputOutputArray dst_mask )

AutoIt:
    cv.detail.MultiBandBlender.blend( $dst, $dst_mask ) -> dst, dst_mask

static cv::Ptr<cv::detail::Blender> cv::detail::MultiBandBlender::createDefault( int  type
                                                                                 bool try_gpu = false )

AutoIt:
    cv.detail.MultiBandBlender.createDefault( $type[, $try_gpu] ) -> retval

static cv::detail::CameraParams cv::detail::CameraParams::create()

AutoIt:
    cv.detail.CameraParams.create() -> <cv.detail.CameraParams object>

cv::Mat cv::detail::CameraParams::K()

AutoIt:
    cv.detail.CameraParams.K() -> retval

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::ExposureCompensator::createDefault( int type )

AutoIt:
    cv.detail.ExposureCompensator.createDefault( $type ) -> retval

void cv::detail::ExposureCompensator::feed( const std::vector<cv::Point>& corners
                                            const std::vector<cv::UMat>&  images
                                            const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.ExposureCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::ExposureCompensator::apply( int               index
                                             cv::Point         corner
                                             _InputOutputArray image
                                             _InputArray       mask )

AutoIt:
    cv.detail.ExposureCompensator.apply( $index, $corner, $image, $mask ) -> image

void cv::detail::ExposureCompensator::getMatGains( std::vector<cv::Mat>& arg1 )

AutoIt:
    cv.detail.ExposureCompensator.getMatGains( [$arg1] ) -> arg1

void cv::detail::ExposureCompensator::setMatGains( std::vector<cv::Mat>& arg1 )

AutoIt:
    cv.detail.ExposureCompensator.setMatGains( $arg1 ) -> None

void cv::detail::ExposureCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.ExposureCompensator.setUpdateGain( $b ) -> None

bool cv::detail::ExposureCompensator::getUpdateGain()

AutoIt:
    cv.detail.ExposureCompensator.getUpdateGain() -> retval

void cv::detail::NoExposureCompensator::apply( int               arg1
                                               cv::Point         arg2
                                               _InputOutputArray arg3
                                               _InputArray       arg4 )

AutoIt:
    cv.detail.NoExposureCompensator.apply( $arg1, $arg2, $arg3, $arg4 ) -> arg3

void cv::detail::NoExposureCompensator::getMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.NoExposureCompensator.getMatGains( [$umv] ) -> umv

void cv::detail::NoExposureCompensator::setMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.NoExposureCompensator.setMatGains( $umv ) -> None

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::NoExposureCompensator::createDefault( int type )

AutoIt:
    cv.detail.NoExposureCompensator.createDefault( $type ) -> retval

void cv::detail::NoExposureCompensator::feed( const std::vector<cv::Point>& corners
                                              const std::vector<cv::UMat>&  images
                                              const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.NoExposureCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::NoExposureCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.NoExposureCompensator.setUpdateGain( $b ) -> None

bool cv::detail::NoExposureCompensator::getUpdateGain()

AutoIt:
    cv.detail.NoExposureCompensator.getUpdateGain() -> retval

static cv::detail::GainCompensator cv::detail::GainCompensator::create()

AutoIt:
    cv.detail.GainCompensator.create() -> <cv.detail.GainCompensator object>

static cv::detail::GainCompensator cv::detail::GainCompensator::create( int nr_feeds )

AutoIt:
    cv.detail.GainCompensator.create( $nr_feeds ) -> <cv.detail.GainCompensator object>

void cv::detail::GainCompensator::apply( int               index
                                         cv::Point         corner
                                         _InputOutputArray image
                                         _InputArray       mask )

AutoIt:
    cv.detail.GainCompensator.apply( $index, $corner, $image, $mask ) -> image

void cv::detail::GainCompensator::getMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.GainCompensator.getMatGains( [$umv] ) -> umv

void cv::detail::GainCompensator::setMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.GainCompensator.setMatGains( $umv ) -> None

void cv::detail::GainCompensator::setNrFeeds( int nr_feeds )

AutoIt:
    cv.detail.GainCompensator.setNrFeeds( $nr_feeds ) -> None

int cv::detail::GainCompensator::getNrFeeds()

AutoIt:
    cv.detail.GainCompensator.getNrFeeds() -> retval

void cv::detail::GainCompensator::setSimilarityThreshold( double similarity_threshold )

AutoIt:
    cv.detail.GainCompensator.setSimilarityThreshold( $similarity_threshold ) -> None

double cv::detail::GainCompensator::getSimilarityThreshold()

AutoIt:
    cv.detail.GainCompensator.getSimilarityThreshold() -> retval

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::GainCompensator::createDefault( int type )

AutoIt:
    cv.detail.GainCompensator.createDefault( $type ) -> retval

void cv::detail::GainCompensator::feed( const std::vector<cv::Point>& corners
                                        const std::vector<cv::UMat>&  images
                                        const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.GainCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::GainCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.GainCompensator.setUpdateGain( $b ) -> None

bool cv::detail::GainCompensator::getUpdateGain()

AutoIt:
    cv.detail.GainCompensator.getUpdateGain() -> retval

static cv::detail::ChannelsCompensator cv::detail::ChannelsCompensator::create( int nr_feeds = 1 )

AutoIt:
    cv.detail.ChannelsCompensator.create( [$nr_feeds] ) -> <cv.detail.ChannelsCompensator object>

void cv::detail::ChannelsCompensator::apply( int               index
                                             cv::Point         corner
                                             _InputOutputArray image
                                             _InputArray       mask )

AutoIt:
    cv.detail.ChannelsCompensator.apply( $index, $corner, $image, $mask ) -> image

void cv::detail::ChannelsCompensator::getMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.ChannelsCompensator.getMatGains( [$umv] ) -> umv

void cv::detail::ChannelsCompensator::setMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.ChannelsCompensator.setMatGains( $umv ) -> None

void cv::detail::ChannelsCompensator::setNrFeeds( int nr_feeds )

AutoIt:
    cv.detail.ChannelsCompensator.setNrFeeds( $nr_feeds ) -> None

int cv::detail::ChannelsCompensator::getNrFeeds()

AutoIt:
    cv.detail.ChannelsCompensator.getNrFeeds() -> retval

void cv::detail::ChannelsCompensator::setSimilarityThreshold( double similarity_threshold )

AutoIt:
    cv.detail.ChannelsCompensator.setSimilarityThreshold( $similarity_threshold ) -> None

double cv::detail::ChannelsCompensator::getSimilarityThreshold()

AutoIt:
    cv.detail.ChannelsCompensator.getSimilarityThreshold() -> retval

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::ChannelsCompensator::createDefault( int type )

AutoIt:
    cv.detail.ChannelsCompensator.createDefault( $type ) -> retval

void cv::detail::ChannelsCompensator::feed( const std::vector<cv::Point>& corners
                                            const std::vector<cv::UMat>&  images
                                            const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.ChannelsCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::ChannelsCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.ChannelsCompensator.setUpdateGain( $b ) -> None

bool cv::detail::ChannelsCompensator::getUpdateGain()

AutoIt:
    cv.detail.ChannelsCompensator.getUpdateGain() -> retval

void cv::detail::BlocksCompensator::apply( int               index
                                           cv::Point         corner
                                           _InputOutputArray image
                                           _InputArray       mask )

AutoIt:
    cv.detail.BlocksCompensator.apply( $index, $corner, $image, $mask ) -> image

void cv::detail::BlocksCompensator::getMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.BlocksCompensator.getMatGains( [$umv] ) -> umv

void cv::detail::BlocksCompensator::setMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.BlocksCompensator.setMatGains( $umv ) -> None

void cv::detail::BlocksCompensator::setNrFeeds( int nr_feeds )

AutoIt:
    cv.detail.BlocksCompensator.setNrFeeds( $nr_feeds ) -> None

int cv::detail::BlocksCompensator::getNrFeeds()

AutoIt:
    cv.detail.BlocksCompensator.getNrFeeds() -> retval

void cv::detail::BlocksCompensator::setSimilarityThreshold( double similarity_threshold )

AutoIt:
    cv.detail.BlocksCompensator.setSimilarityThreshold( $similarity_threshold ) -> None

double cv::detail::BlocksCompensator::getSimilarityThreshold()

AutoIt:
    cv.detail.BlocksCompensator.getSimilarityThreshold() -> retval

void cv::detail::BlocksCompensator::setBlockSize( int width
                                                  int height )

AutoIt:
    cv.detail.BlocksCompensator.setBlockSize( $width, $height ) -> None

void cv::detail::BlocksCompensator::setBlockSize( cv::Size size )

AutoIt:
    cv.detail.BlocksCompensator.setBlockSize( $size ) -> None

cv::Size cv::detail::BlocksCompensator::getBlockSize()

AutoIt:
    cv.detail.BlocksCompensator.getBlockSize() -> retval

void cv::detail::BlocksCompensator::setNrGainsFilteringIterations( int nr_iterations )

AutoIt:
    cv.detail.BlocksCompensator.setNrGainsFilteringIterations( $nr_iterations ) -> None

int cv::detail::BlocksCompensator::getNrGainsFilteringIterations()

AutoIt:
    cv.detail.BlocksCompensator.getNrGainsFilteringIterations() -> retval

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::BlocksCompensator::createDefault( int type )

AutoIt:
    cv.detail.BlocksCompensator.createDefault( $type ) -> retval

void cv::detail::BlocksCompensator::feed( const std::vector<cv::Point>& corners
                                          const std::vector<cv::UMat>&  images
                                          const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.BlocksCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::BlocksCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.BlocksCompensator.setUpdateGain( $b ) -> None

bool cv::detail::BlocksCompensator::getUpdateGain()

AutoIt:
    cv.detail.BlocksCompensator.getUpdateGain() -> retval

static cv::detail::BlocksGainCompensator cv::detail::BlocksGainCompensator::create( int bl_width = 32
                                                                                    int bl_height = 32 )

AutoIt:
    cv.detail.BlocksGainCompensator.create( [$bl_width[, $bl_height]] ) -> <cv.detail.BlocksGainCompensator object>

static cv::detail::BlocksGainCompensator cv::detail::BlocksGainCompensator::create( int bl_width
                                                                                    int bl_height
                                                                                    int nr_feeds )

AutoIt:
    cv.detail.BlocksGainCompensator.create( $bl_width, $bl_height, $nr_feeds ) -> <cv.detail.BlocksGainCompensator object>

void cv::detail::BlocksGainCompensator::apply( int               index
                                               cv::Point         corner
                                               _InputOutputArray image
                                               _InputArray       mask )

AutoIt:
    cv.detail.BlocksGainCompensator.apply( $index, $corner, $image, $mask ) -> image

void cv::detail::BlocksGainCompensator::getMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.BlocksGainCompensator.getMatGains( [$umv] ) -> umv

void cv::detail::BlocksGainCompensator::setMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.BlocksGainCompensator.setMatGains( $umv ) -> None

void cv::detail::BlocksGainCompensator::setNrFeeds( int nr_feeds )

AutoIt:
    cv.detail.BlocksGainCompensator.setNrFeeds( $nr_feeds ) -> None

int cv::detail::BlocksGainCompensator::getNrFeeds()

AutoIt:
    cv.detail.BlocksGainCompensator.getNrFeeds() -> retval

void cv::detail::BlocksGainCompensator::setSimilarityThreshold( double similarity_threshold )

AutoIt:
    cv.detail.BlocksGainCompensator.setSimilarityThreshold( $similarity_threshold ) -> None

double cv::detail::BlocksGainCompensator::getSimilarityThreshold()

AutoIt:
    cv.detail.BlocksGainCompensator.getSimilarityThreshold() -> retval

void cv::detail::BlocksGainCompensator::setBlockSize( int width
                                                      int height )

AutoIt:
    cv.detail.BlocksGainCompensator.setBlockSize( $width, $height ) -> None

void cv::detail::BlocksGainCompensator::setBlockSize( cv::Size size )

AutoIt:
    cv.detail.BlocksGainCompensator.setBlockSize( $size ) -> None

cv::Size cv::detail::BlocksGainCompensator::getBlockSize()

AutoIt:
    cv.detail.BlocksGainCompensator.getBlockSize() -> retval

void cv::detail::BlocksGainCompensator::setNrGainsFilteringIterations( int nr_iterations )

AutoIt:
    cv.detail.BlocksGainCompensator.setNrGainsFilteringIterations( $nr_iterations ) -> None

int cv::detail::BlocksGainCompensator::getNrGainsFilteringIterations()

AutoIt:
    cv.detail.BlocksGainCompensator.getNrGainsFilteringIterations() -> retval

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::BlocksGainCompensator::createDefault( int type )

AutoIt:
    cv.detail.BlocksGainCompensator.createDefault( $type ) -> retval

void cv::detail::BlocksGainCompensator::feed( const std::vector<cv::Point>& corners
                                              const std::vector<cv::UMat>&  images
                                              const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.BlocksGainCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::BlocksGainCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.BlocksGainCompensator.setUpdateGain( $b ) -> None

bool cv::detail::BlocksGainCompensator::getUpdateGain()

AutoIt:
    cv.detail.BlocksGainCompensator.getUpdateGain() -> retval

static cv::detail::BlocksChannelsCompensator cv::detail::BlocksChannelsCompensator::create( int bl_width = 32
                                                                                            int bl_height = 32
                                                                                            int nr_feeds = 1 )

AutoIt:
    cv.detail.BlocksChannelsCompensator.create( [$bl_width[, $bl_height[, $nr_feeds]]] ) -> <cv.detail.BlocksChannelsCompensator object>

void cv::detail::BlocksChannelsCompensator::apply( int               index
                                                   cv::Point         corner
                                                   _InputOutputArray image
                                                   _InputArray       mask )

AutoIt:
    cv.detail.BlocksChannelsCompensator.apply( $index, $corner, $image, $mask ) -> image

void cv::detail::BlocksChannelsCompensator::getMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.BlocksChannelsCompensator.getMatGains( [$umv] ) -> umv

void cv::detail::BlocksChannelsCompensator::setMatGains( std::vector<cv::Mat>& umv )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setMatGains( $umv ) -> None

void cv::detail::BlocksChannelsCompensator::setNrFeeds( int nr_feeds )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setNrFeeds( $nr_feeds ) -> None

int cv::detail::BlocksChannelsCompensator::getNrFeeds()

AutoIt:
    cv.detail.BlocksChannelsCompensator.getNrFeeds() -> retval

void cv::detail::BlocksChannelsCompensator::setSimilarityThreshold( double similarity_threshold )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setSimilarityThreshold( $similarity_threshold ) -> None

double cv::detail::BlocksChannelsCompensator::getSimilarityThreshold()

AutoIt:
    cv.detail.BlocksChannelsCompensator.getSimilarityThreshold() -> retval

void cv::detail::BlocksChannelsCompensator::setBlockSize( int width
                                                          int height )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setBlockSize( $width, $height ) -> None

void cv::detail::BlocksChannelsCompensator::setBlockSize( cv::Size size )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setBlockSize( $size ) -> None

cv::Size cv::detail::BlocksChannelsCompensator::getBlockSize()

AutoIt:
    cv.detail.BlocksChannelsCompensator.getBlockSize() -> retval

void cv::detail::BlocksChannelsCompensator::setNrGainsFilteringIterations( int nr_iterations )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setNrGainsFilteringIterations( $nr_iterations ) -> None

int cv::detail::BlocksChannelsCompensator::getNrGainsFilteringIterations()

AutoIt:
    cv.detail.BlocksChannelsCompensator.getNrGainsFilteringIterations() -> retval

static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::BlocksChannelsCompensator::createDefault( int type )

AutoIt:
    cv.detail.BlocksChannelsCompensator.createDefault( $type ) -> retval

void cv::detail::BlocksChannelsCompensator::feed( const std::vector<cv::Point>& corners
                                                  const std::vector<cv::UMat>&  images
                                                  const std::vector<cv::UMat>&  masks )

AutoIt:
    cv.detail.BlocksChannelsCompensator.feed( $corners, $images, $masks ) -> None

void cv::detail::BlocksChannelsCompensator::setUpdateGain( bool b )

AutoIt:
    cv.detail.BlocksChannelsCompensator.setUpdateGain( $b ) -> None

bool cv::detail::BlocksChannelsCompensator::getUpdateGain()

AutoIt:
    cv.detail.BlocksChannelsCompensator.getUpdateGain() -> retval

static cv::detail::ImageFeatures cv::detail::ImageFeatures::create()

AutoIt:
    cv.detail.ImageFeatures.create() -> <cv.detail.ImageFeatures object>

std::vector<cv::KeyPoint> cv::detail::ImageFeatures::getKeypoints()

AutoIt:
    cv.detail.ImageFeatures.getKeypoints() -> retval

static cv::detail::MatchesInfo cv::detail::MatchesInfo::create()

AutoIt:
    cv.detail.MatchesInfo.create() -> <cv.detail.MatchesInfo object>

std::vector<cv::DMatch> cv::detail::MatchesInfo::getMatches()

AutoIt:
    cv.detail.MatchesInfo.getMatches() -> retval

std::vector<uchar> cv::detail::MatchesInfo::getInliers()

AutoIt:
    cv.detail.MatchesInfo.getInliers() -> retval

void cv::detail::FeaturesMatcher::apply( const cv::detail::ImageFeatures& features1
                                         const cv::detail::ImageFeatures& features2
                                         cv::detail::MatchesInfo&         matches_info )

AutoIt:
    cv.detail.FeaturesMatcher.apply( $features1, $features2[, $matches_info] ) -> matches_info

void cv::detail::FeaturesMatcher::apply2( const std::vector<cv::detail::ImageFeatures>& features
                                          std::vector<cv::detail::MatchesInfo>&         pairwise_matches
                                          const cv::UMat&                               mask = cv::UMat() )

AutoIt:
    cv.detail.FeaturesMatcher.apply2( $features[, $mask[, $pairwise_matches]] ) -> pairwise_matches

bool cv::detail::FeaturesMatcher::isThreadSafe()

AutoIt:
    cv.detail.FeaturesMatcher.isThreadSafe() -> retval

void cv::detail::FeaturesMatcher::collectGarbage()

AutoIt:
    cv.detail.FeaturesMatcher.collectGarbage() -> None

static cv::detail::BestOf2NearestMatcher cv::detail::BestOf2NearestMatcher::create( bool  try_use_gpu = false
                                                                                    float match_conf = 0.3f
                                                                                    int   num_matches_thresh1 = 6
                                                                                    int   num_matches_thresh2 = 6 )

AutoIt:
    cv.detail.BestOf2NearestMatcher.create( [$try_use_gpu[, $match_conf[, $num_matches_thresh1[, $num_matches_thresh2]]]] ) -> <cv.detail.BestOf2NearestMatcher object>

static cv::Ptr<cv::detail::BestOf2NearestMatcher> cv::detail::BestOf2NearestMatcher::create( bool  try_use_gpu = false
                                                                                             float match_conf = 0.3f
                                                                                             int   num_matches_thresh1 = 6
                                                                                             int   num_matches_thresh2 = 6 )

AutoIt:
    cv.detail.BestOf2NearestMatcher.create( [$try_use_gpu[, $match_conf[, $num_matches_thresh1[, $num_matches_thresh2]]]] ) -> retval

void cv::detail::BestOf2NearestMatcher::collectGarbage()

AutoIt:
    cv.detail.BestOf2NearestMatcher.collectGarbage() -> None

void cv::detail::BestOf2NearestMatcher::apply( const cv::detail::ImageFeatures& features1
                                               const cv::detail::ImageFeatures& features2
                                               cv::detail::MatchesInfo&         matches_info )

AutoIt:
    cv.detail.BestOf2NearestMatcher.apply( $features1, $features2[, $matches_info] ) -> matches_info

void cv::detail::BestOf2NearestMatcher::apply2( const std::vector<cv::detail::ImageFeatures>& features
                                                std::vector<cv::detail::MatchesInfo>&         pairwise_matches
                                                const cv::UMat&                               mask = cv::UMat() )

AutoIt:
    cv.detail.BestOf2NearestMatcher.apply2( $features[, $mask[, $pairwise_matches]] ) -> pairwise_matches

bool cv::detail::BestOf2NearestMatcher::isThreadSafe()

AutoIt:
    cv.detail.BestOf2NearestMatcher.isThreadSafe() -> retval

static cv::detail::BestOf2NearestRangeMatcher cv::detail::BestOf2NearestRangeMatcher::create( int   range_width = 5
                                                                                              bool  try_use_gpu = false
                                                                                              float match_conf = 0.3f
                                                                                              int   num_matches_thresh1 = 6
                                                                                              int   num_matches_thresh2 = 6 )

AutoIt:
    cv.detail.BestOf2NearestRangeMatcher.create( [$range_width[, $try_use_gpu[, $match_conf[, $num_matches_thresh1[, $num_matches_thresh2]]]]] ) -> <cv.detail.BestOf2NearestRangeMatcher object>

void cv::detail::BestOf2NearestRangeMatcher::collectGarbage()

AutoIt:
    cv.detail.BestOf2NearestRangeMatcher.collectGarbage() -> None

void cv::detail::BestOf2NearestRangeMatcher::apply( const cv::detail::ImageFeatures& features1
                                                    const cv::detail::ImageFeatures& features2
                                                    cv::detail::MatchesInfo&         matches_info )

AutoIt:
    cv.detail.BestOf2NearestRangeMatcher.apply( $features1, $features2[, $matches_info] ) -> matches_info

void cv::detail::BestOf2NearestRangeMatcher::apply2( const std::vector<cv::detail::ImageFeatures>& features
                                                     std::vector<cv::detail::MatchesInfo>&         pairwise_matches
                                                     const cv::UMat&                               mask = cv::UMat() )

AutoIt:
    cv.detail.BestOf2NearestRangeMatcher.apply2( $features[, $mask[, $pairwise_matches]] ) -> pairwise_matches

bool cv::detail::BestOf2NearestRangeMatcher::isThreadSafe()

AutoIt:
    cv.detail.BestOf2NearestRangeMatcher.isThreadSafe() -> retval

static cv::detail::AffineBestOf2NearestMatcher cv::detail::AffineBestOf2NearestMatcher::create( bool  full_affine = false
                                                                                                bool  try_use_gpu = false
                                                                                                float match_conf = 0.3f
                                                                                                int   num_matches_thresh1 = 6 )

AutoIt:
    cv.detail.AffineBestOf2NearestMatcher.create( [$full_affine[, $try_use_gpu[, $match_conf[, $num_matches_thresh1]]]] ) -> <cv.detail.AffineBestOf2NearestMatcher object>

void cv::detail::AffineBestOf2NearestMatcher::collectGarbage()

AutoIt:
    cv.detail.AffineBestOf2NearestMatcher.collectGarbage() -> None

void cv::detail::AffineBestOf2NearestMatcher::apply( const cv::detail::ImageFeatures& features1
                                                     const cv::detail::ImageFeatures& features2
                                                     cv::detail::MatchesInfo&         matches_info )

AutoIt:
    cv.detail.AffineBestOf2NearestMatcher.apply( $features1, $features2[, $matches_info] ) -> matches_info

void cv::detail::AffineBestOf2NearestMatcher::apply2( const std::vector<cv::detail::ImageFeatures>& features
                                                      std::vector<cv::detail::MatchesInfo>&         pairwise_matches
                                                      const cv::UMat&                               mask = cv::UMat() )

AutoIt:
    cv.detail.AffineBestOf2NearestMatcher.apply2( $features[, $mask[, $pairwise_matches]] ) -> pairwise_matches

bool cv::detail::AffineBestOf2NearestMatcher::isThreadSafe()

AutoIt:
    cv.detail.AffineBestOf2NearestMatcher.isThreadSafe() -> retval

bool cv::detail::Estimator::apply( const std::vector<cv::detail::ImageFeatures>& features
                                   const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                   std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.Estimator.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::HomographyBasedEstimator cv::detail::HomographyBasedEstimator::create( bool is_focals_estimated = false )

AutoIt:
    cv.detail.HomographyBasedEstimator.create( [$is_focals_estimated] ) -> <cv.detail.HomographyBasedEstimator object>

bool cv::detail::HomographyBasedEstimator::apply( const std::vector<cv::detail::ImageFeatures>& features
                                                  const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                                  std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.HomographyBasedEstimator.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::AffineBasedEstimator cv::detail::AffineBasedEstimator::create()

AutoIt:
    cv.detail.AffineBasedEstimator.create() -> <cv.detail.AffineBasedEstimator object>

bool cv::detail::AffineBasedEstimator::apply( const std::vector<cv::detail::ImageFeatures>& features
                                              const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                              std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.AffineBasedEstimator.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

cv::Mat cv::detail::BundleAdjusterBase::refinementMask()

AutoIt:
    cv.detail.BundleAdjusterBase.refinementMask() -> retval

void cv::detail::BundleAdjusterBase::setRefinementMask( const cv::Mat& mask )

AutoIt:
    cv.detail.BundleAdjusterBase.setRefinementMask( $mask ) -> None

double cv::detail::BundleAdjusterBase::confThresh()

AutoIt:
    cv.detail.BundleAdjusterBase.confThresh() -> retval

void cv::detail::BundleAdjusterBase::setConfThresh( double conf_thresh )

AutoIt:
    cv.detail.BundleAdjusterBase.setConfThresh( $conf_thresh ) -> None

cv::TermCriteria cv::detail::BundleAdjusterBase::termCriteria()

AutoIt:
    cv.detail.BundleAdjusterBase.termCriteria() -> retval

void cv::detail::BundleAdjusterBase::setTermCriteria( const cv::TermCriteria& term_criteria )

AutoIt:
    cv.detail.BundleAdjusterBase.setTermCriteria( $term_criteria ) -> None

bool cv::detail::BundleAdjusterBase::apply( const std::vector<cv::detail::ImageFeatures>& features
                                            const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                            std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.BundleAdjusterBase.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::NoBundleAdjuster cv::detail::NoBundleAdjuster::create()

AutoIt:
    cv.detail.NoBundleAdjuster.create() -> <cv.detail.NoBundleAdjuster object>

cv::Mat cv::detail::NoBundleAdjuster::refinementMask()

AutoIt:
    cv.detail.NoBundleAdjuster.refinementMask() -> retval

void cv::detail::NoBundleAdjuster::setRefinementMask( const cv::Mat& mask )

AutoIt:
    cv.detail.NoBundleAdjuster.setRefinementMask( $mask ) -> None

double cv::detail::NoBundleAdjuster::confThresh()

AutoIt:
    cv.detail.NoBundleAdjuster.confThresh() -> retval

void cv::detail::NoBundleAdjuster::setConfThresh( double conf_thresh )

AutoIt:
    cv.detail.NoBundleAdjuster.setConfThresh( $conf_thresh ) -> None

cv::TermCriteria cv::detail::NoBundleAdjuster::termCriteria()

AutoIt:
    cv.detail.NoBundleAdjuster.termCriteria() -> retval

void cv::detail::NoBundleAdjuster::setTermCriteria( const cv::TermCriteria& term_criteria )

AutoIt:
    cv.detail.NoBundleAdjuster.setTermCriteria( $term_criteria ) -> None

bool cv::detail::NoBundleAdjuster::apply( const std::vector<cv::detail::ImageFeatures>& features
                                          const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                          std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.NoBundleAdjuster.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::BundleAdjusterReproj cv::detail::BundleAdjusterReproj::create()

AutoIt:
    cv.detail.BundleAdjusterReproj.create() -> <cv.detail.BundleAdjusterReproj object>

cv::Mat cv::detail::BundleAdjusterReproj::refinementMask()

AutoIt:
    cv.detail.BundleAdjusterReproj.refinementMask() -> retval

void cv::detail::BundleAdjusterReproj::setRefinementMask( const cv::Mat& mask )

AutoIt:
    cv.detail.BundleAdjusterReproj.setRefinementMask( $mask ) -> None

double cv::detail::BundleAdjusterReproj::confThresh()

AutoIt:
    cv.detail.BundleAdjusterReproj.confThresh() -> retval

void cv::detail::BundleAdjusterReproj::setConfThresh( double conf_thresh )

AutoIt:
    cv.detail.BundleAdjusterReproj.setConfThresh( $conf_thresh ) -> None

cv::TermCriteria cv::detail::BundleAdjusterReproj::termCriteria()

AutoIt:
    cv.detail.BundleAdjusterReproj.termCriteria() -> retval

void cv::detail::BundleAdjusterReproj::setTermCriteria( const cv::TermCriteria& term_criteria )

AutoIt:
    cv.detail.BundleAdjusterReproj.setTermCriteria( $term_criteria ) -> None

bool cv::detail::BundleAdjusterReproj::apply( const std::vector<cv::detail::ImageFeatures>& features
                                              const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                              std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.BundleAdjusterReproj.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::BundleAdjusterRay cv::detail::BundleAdjusterRay::create()

AutoIt:
    cv.detail.BundleAdjusterRay.create() -> <cv.detail.BundleAdjusterRay object>

cv::Mat cv::detail::BundleAdjusterRay::refinementMask()

AutoIt:
    cv.detail.BundleAdjusterRay.refinementMask() -> retval

void cv::detail::BundleAdjusterRay::setRefinementMask( const cv::Mat& mask )

AutoIt:
    cv.detail.BundleAdjusterRay.setRefinementMask( $mask ) -> None

double cv::detail::BundleAdjusterRay::confThresh()

AutoIt:
    cv.detail.BundleAdjusterRay.confThresh() -> retval

void cv::detail::BundleAdjusterRay::setConfThresh( double conf_thresh )

AutoIt:
    cv.detail.BundleAdjusterRay.setConfThresh( $conf_thresh ) -> None

cv::TermCriteria cv::detail::BundleAdjusterRay::termCriteria()

AutoIt:
    cv.detail.BundleAdjusterRay.termCriteria() -> retval

void cv::detail::BundleAdjusterRay::setTermCriteria( const cv::TermCriteria& term_criteria )

AutoIt:
    cv.detail.BundleAdjusterRay.setTermCriteria( $term_criteria ) -> None

bool cv::detail::BundleAdjusterRay::apply( const std::vector<cv::detail::ImageFeatures>& features
                                           const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                           std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.BundleAdjusterRay.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::BundleAdjusterAffine cv::detail::BundleAdjusterAffine::create()

AutoIt:
    cv.detail.BundleAdjusterAffine.create() -> <cv.detail.BundleAdjusterAffine object>

cv::Mat cv::detail::BundleAdjusterAffine::refinementMask()

AutoIt:
    cv.detail.BundleAdjusterAffine.refinementMask() -> retval

void cv::detail::BundleAdjusterAffine::setRefinementMask( const cv::Mat& mask )

AutoIt:
    cv.detail.BundleAdjusterAffine.setRefinementMask( $mask ) -> None

double cv::detail::BundleAdjusterAffine::confThresh()

AutoIt:
    cv.detail.BundleAdjusterAffine.confThresh() -> retval

void cv::detail::BundleAdjusterAffine::setConfThresh( double conf_thresh )

AutoIt:
    cv.detail.BundleAdjusterAffine.setConfThresh( $conf_thresh ) -> None

cv::TermCriteria cv::detail::BundleAdjusterAffine::termCriteria()

AutoIt:
    cv.detail.BundleAdjusterAffine.termCriteria() -> retval

void cv::detail::BundleAdjusterAffine::setTermCriteria( const cv::TermCriteria& term_criteria )

AutoIt:
    cv.detail.BundleAdjusterAffine.setTermCriteria( $term_criteria ) -> None

bool cv::detail::BundleAdjusterAffine::apply( const std::vector<cv::detail::ImageFeatures>& features
                                              const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                              std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.BundleAdjusterAffine.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

static cv::detail::BundleAdjusterAffinePartial cv::detail::BundleAdjusterAffinePartial::create()

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.create() -> <cv.detail.BundleAdjusterAffinePartial object>

cv::Mat cv::detail::BundleAdjusterAffinePartial::refinementMask()

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.refinementMask() -> retval

void cv::detail::BundleAdjusterAffinePartial::setRefinementMask( const cv::Mat& mask )

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.setRefinementMask( $mask ) -> None

double cv::detail::BundleAdjusterAffinePartial::confThresh()

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.confThresh() -> retval

void cv::detail::BundleAdjusterAffinePartial::setConfThresh( double conf_thresh )

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.setConfThresh( $conf_thresh ) -> None

cv::TermCriteria cv::detail::BundleAdjusterAffinePartial::termCriteria()

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.termCriteria() -> retval

void cv::detail::BundleAdjusterAffinePartial::setTermCriteria( const cv::TermCriteria& term_criteria )

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.setTermCriteria( $term_criteria ) -> None

bool cv::detail::BundleAdjusterAffinePartial::apply( const std::vector<cv::detail::ImageFeatures>& features
                                                     const std::vector<cv::detail::MatchesInfo>&   pairwise_matches
                                                     std::vector<cv::detail::CameraParams>&        cameras )

AutoIt:
    cv.detail.BundleAdjusterAffinePartial.apply( $features, $pairwise_matches, $cameras ) -> retval, cameras

void cv::detail::SeamFinder::find( const std::vector<cv::UMat>&  src
                                   const std::vector<cv::Point>& corners
                                   std::vector<cv::UMat>&        masks )

AutoIt:
    cv.detail.SeamFinder.find( $src, $corners, $masks ) -> masks

static cv::Ptr<cv::detail::SeamFinder> cv::detail::SeamFinder::createDefault( int type )

AutoIt:
    cv.detail.SeamFinder.createDefault( $type ) -> retval

void cv::detail::NoSeamFinder::find( const std::vector<cv::UMat>&  arg1
                                     const std::vector<cv::Point>& arg2
                                     std::vector<cv::UMat>&        arg3 )

AutoIt:
    cv.detail.NoSeamFinder.find( $arg1, $arg2, $arg3 ) -> arg3

static cv::Ptr<cv::detail::SeamFinder> cv::detail::NoSeamFinder::createDefault( int type )

AutoIt:
    cv.detail.NoSeamFinder.createDefault( $type ) -> retval

void cv::detail::PairwiseSeamFinder::find( const std::vector<cv::UMat>&  src
                                           const std::vector<cv::Point>& corners
                                           std::vector<cv::UMat>&        masks )

AutoIt:
    cv.detail.PairwiseSeamFinder.find( $src, $corners, $masks ) -> masks

static cv::Ptr<cv::detail::SeamFinder> cv::detail::PairwiseSeamFinder::createDefault( int type )

AutoIt:
    cv.detail.PairwiseSeamFinder.createDefault( $type ) -> retval

void cv::detail::VoronoiSeamFinder::find( const std::vector<cv::UMat>&  src
                                          const std::vector<cv::Point>& corners
                                          std::vector<cv::UMat>&        masks )

AutoIt:
    cv.detail.VoronoiSeamFinder.find( $src, $corners, $masks ) -> masks

static cv::Ptr<cv::detail::SeamFinder> cv::detail::VoronoiSeamFinder::createDefault( int type )

AutoIt:
    cv.detail.VoronoiSeamFinder.createDefault( $type ) -> retval

static cv::detail::DpSeamFinder cv::detail::DpSeamFinder::create( std::string costFunc )

AutoIt:
    cv.detail.DpSeamFinder.create( $costFunc ) -> <cv.detail.DpSeamFinder object>

void cv::detail::DpSeamFinder::setCostFunction( std::string val )

AutoIt:
    cv.detail.DpSeamFinder.setCostFunction( $val ) -> None

void cv::detail::DpSeamFinder::find( const std::vector<cv::UMat>&  src
                                     const std::vector<cv::Point>& corners
                                     std::vector<cv::UMat>&        masks )

AutoIt:
    cv.detail.DpSeamFinder.find( $src, $corners, $masks ) -> masks

static cv::Ptr<cv::detail::SeamFinder> cv::detail::DpSeamFinder::createDefault( int type )

AutoIt:
    cv.detail.DpSeamFinder.createDefault( $type ) -> retval

static cv::detail::GraphCutSeamFinder cv::detail::GraphCutSeamFinder::create( std::string cost_type
                                                                              float       terminal_cost = 10000.f
                                                                              float       bad_region_penalty = 1000.f )

AutoIt:
    cv.detail.GraphCutSeamFinder.create( $cost_type[, $terminal_cost[, $bad_region_penalty]] ) -> <cv.detail.GraphCutSeamFinder object>

void cv::detail::GraphCutSeamFinder::find( const std::vector<cv::UMat>&  src
                                           const std::vector<cv::Point>& corners
                                           std::vector<cv::UMat>&        masks )

AutoIt:
    cv.detail.GraphCutSeamFinder.find( $src, $corners, $masks ) -> None

static cv::Ptr<cv::detail::SeamFinder> cv::detail::GraphCutSeamFinder::createDefault( int type )

AutoIt:
    cv.detail.GraphCutSeamFinder.createDefault( $type ) -> retval

static cv::Ptr<cv::detail::Timelapser> cv::detail::Timelapser::createDefault( int type )

AutoIt:
    cv.detail.Timelapser.createDefault( $type ) -> retval

void cv::detail::Timelapser::initialize( const std::vector<cv::Point>& corners
                                         const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.Timelapser.initialize( $corners, $sizes ) -> None

void cv::detail::Timelapser::process( _InputArray img
                                      _InputArray mask
                                      cv::Point   tl )

AutoIt:
    cv.detail.Timelapser.process( $img, $mask, $tl ) -> None

cv::UMat cv::detail::Timelapser::getDst()

AutoIt:
    cv.detail.Timelapser.getDst() -> retval

static cv::Ptr<cv::detail::Timelapser> cv::detail::TimelapserCrop::createDefault( int type )

AutoIt:
    cv.detail.TimelapserCrop.createDefault( $type ) -> retval

void cv::detail::TimelapserCrop::initialize( const std::vector<cv::Point>& corners
                                             const std::vector<cv::Size>&  sizes )

AutoIt:
    cv.detail.TimelapserCrop.initialize( $corners, $sizes ) -> None

void cv::detail::TimelapserCrop::process( _InputArray img
                                          _InputArray mask
                                          cv::Point   tl )

AutoIt:
    cv.detail.TimelapserCrop.process( $img, $mask, $tl ) -> None

cv::UMat cv::detail::TimelapserCrop::getDst()

AutoIt:
    cv.detail.TimelapserCrop.getDst() -> retval

static cv::detail::ProjectorBase cv::detail::ProjectorBase::create()

AutoIt:
    cv.detail.ProjectorBase.create() -> <cv.detail.ProjectorBase object>

static cv::detail::SphericalProjector cv::detail::SphericalProjector::create()

AutoIt:
    cv.detail.SphericalProjector.create() -> <cv.detail.SphericalProjector object>

void cv::detail::SphericalProjector::mapForward( float  x
                                                 float  y
                                                 float& u
                                                 float& v )

AutoIt:
    cv.detail.SphericalProjector.mapForward( $x, $y, $u, $v ) -> None

void cv::detail::SphericalProjector::mapBackward( float  u
                                                  float  v
                                                  float& x
                                                  float& y )

AutoIt:
    cv.detail.SphericalProjector.mapBackward( $u, $v, $x, $y ) -> None

void cv::BackgroundSubtractor::apply( _InputArray  image
                                      _OutputArray fgmask
                                      double       learningRate = -1 )

AutoIt:
    cv.BackgroundSubtractor.apply( $image[, $fgmask[, $learningRate]] ) -> fgmask

void cv::BackgroundSubtractor::getBackgroundImage( _OutputArray backgroundImage )

AutoIt:
    cv.BackgroundSubtractor.getBackgroundImage( [$backgroundImage] ) -> backgroundImage

void cv::BackgroundSubtractor::clear()

AutoIt:
    cv.BackgroundSubtractor.clear() -> None

void cv::BackgroundSubtractor::write( const cv::Ptr<cv::FileStorage>& fs
                                      const std::string&              name = String() )

AutoIt:
    cv.BackgroundSubtractor.write( $fs[, $name] ) -> None

void cv::BackgroundSubtractor::read( const cv::FileNode& fn )

AutoIt:
    cv.BackgroundSubtractor.read( $fn ) -> None

bool cv::BackgroundSubtractor::empty()

AutoIt:
    cv.BackgroundSubtractor.empty() -> retval

void cv::BackgroundSubtractor::save( const std::string& filename )

AutoIt:
    cv.BackgroundSubtractor.save( $filename ) -> None

std::string cv::BackgroundSubtractor::getDefaultName()

AutoIt:
    cv.BackgroundSubtractor.getDefaultName() -> retval

int cv::BackgroundSubtractorMOG2::getHistory()

AutoIt:
    cv.BackgroundSubtractorMOG2.getHistory() -> retval

void cv::BackgroundSubtractorMOG2::setHistory( int history )

AutoIt:
    cv.BackgroundSubtractorMOG2.setHistory( $history ) -> None

int cv::BackgroundSubtractorMOG2::getNMixtures()

AutoIt:
    cv.BackgroundSubtractorMOG2.getNMixtures() -> retval

void cv::BackgroundSubtractorMOG2::setNMixtures( int nmixtures )

AutoIt:
    cv.BackgroundSubtractorMOG2.setNMixtures( $nmixtures ) -> None

double cv::BackgroundSubtractorMOG2::getBackgroundRatio()

AutoIt:
    cv.BackgroundSubtractorMOG2.getBackgroundRatio() -> retval

void cv::BackgroundSubtractorMOG2::setBackgroundRatio( double ratio )

AutoIt:
    cv.BackgroundSubtractorMOG2.setBackgroundRatio( $ratio ) -> None

double cv::BackgroundSubtractorMOG2::getVarThreshold()

AutoIt:
    cv.BackgroundSubtractorMOG2.getVarThreshold() -> retval

void cv::BackgroundSubtractorMOG2::setVarThreshold( double varThreshold )

AutoIt:
    cv.BackgroundSubtractorMOG2.setVarThreshold( $varThreshold ) -> None

double cv::BackgroundSubtractorMOG2::getVarThresholdGen()

AutoIt:
    cv.BackgroundSubtractorMOG2.getVarThresholdGen() -> retval

void cv::BackgroundSubtractorMOG2::setVarThresholdGen( double varThresholdGen )

AutoIt:
    cv.BackgroundSubtractorMOG2.setVarThresholdGen( $varThresholdGen ) -> None

double cv::BackgroundSubtractorMOG2::getVarInit()

AutoIt:
    cv.BackgroundSubtractorMOG2.getVarInit() -> retval

void cv::BackgroundSubtractorMOG2::setVarInit( double varInit )

AutoIt:
    cv.BackgroundSubtractorMOG2.setVarInit( $varInit ) -> None

double cv::BackgroundSubtractorMOG2::getVarMin()

AutoIt:
    cv.BackgroundSubtractorMOG2.getVarMin() -> retval

void cv::BackgroundSubtractorMOG2::setVarMin( double varMin )

AutoIt:
    cv.BackgroundSubtractorMOG2.setVarMin( $varMin ) -> None

double cv::BackgroundSubtractorMOG2::getVarMax()

AutoIt:
    cv.BackgroundSubtractorMOG2.getVarMax() -> retval

void cv::BackgroundSubtractorMOG2::setVarMax( double varMax )

AutoIt:
    cv.BackgroundSubtractorMOG2.setVarMax( $varMax ) -> None

double cv::BackgroundSubtractorMOG2::getComplexityReductionThreshold()

AutoIt:
    cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold() -> retval

void cv::BackgroundSubtractorMOG2::setComplexityReductionThreshold( double ct )

AutoIt:
    cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold( $ct ) -> None

bool cv::BackgroundSubtractorMOG2::getDetectShadows()

AutoIt:
    cv.BackgroundSubtractorMOG2.getDetectShadows() -> retval

void cv::BackgroundSubtractorMOG2::setDetectShadows( bool detectShadows )

AutoIt:
    cv.BackgroundSubtractorMOG2.setDetectShadows( $detectShadows ) -> None

int cv::BackgroundSubtractorMOG2::getShadowValue()

AutoIt:
    cv.BackgroundSubtractorMOG2.getShadowValue() -> retval

void cv::BackgroundSubtractorMOG2::setShadowValue( int value )

AutoIt:
    cv.BackgroundSubtractorMOG2.setShadowValue( $value ) -> None

double cv::BackgroundSubtractorMOG2::getShadowThreshold()

AutoIt:
    cv.BackgroundSubtractorMOG2.getShadowThreshold() -> retval

void cv::BackgroundSubtractorMOG2::setShadowThreshold( double threshold )

AutoIt:
    cv.BackgroundSubtractorMOG2.setShadowThreshold( $threshold ) -> None

void cv::BackgroundSubtractorMOG2::apply( _InputArray  image
                                          _OutputArray fgmask
                                          double       learningRate = -1 )

AutoIt:
    cv.BackgroundSubtractorMOG2.apply( $image[, $fgmask[, $learningRate]] ) -> fgmask

void cv::BackgroundSubtractorMOG2::getBackgroundImage( _OutputArray backgroundImage )

AutoIt:
    cv.BackgroundSubtractorMOG2.getBackgroundImage( [$backgroundImage] ) -> backgroundImage

void cv::BackgroundSubtractorMOG2::clear()

AutoIt:
    cv.BackgroundSubtractorMOG2.clear() -> None

void cv::BackgroundSubtractorMOG2::write( const cv::Ptr<cv::FileStorage>& fs
                                          const std::string&              name = String() )

AutoIt:
    cv.BackgroundSubtractorMOG2.write( $fs[, $name] ) -> None

void cv::BackgroundSubtractorMOG2::read( const cv::FileNode& fn )

AutoIt:
    cv.BackgroundSubtractorMOG2.read( $fn ) -> None

bool cv::BackgroundSubtractorMOG2::empty()

AutoIt:
    cv.BackgroundSubtractorMOG2.empty() -> retval

void cv::BackgroundSubtractorMOG2::save( const std::string& filename )

AutoIt:
    cv.BackgroundSubtractorMOG2.save( $filename ) -> None

std::string cv::BackgroundSubtractorMOG2::getDefaultName()

AutoIt:
    cv.BackgroundSubtractorMOG2.getDefaultName() -> retval

int cv::BackgroundSubtractorKNN::getHistory()

AutoIt:
    cv.BackgroundSubtractorKNN.getHistory() -> retval

void cv::BackgroundSubtractorKNN::setHistory( int history )

AutoIt:
    cv.BackgroundSubtractorKNN.setHistory( $history ) -> None

int cv::BackgroundSubtractorKNN::getNSamples()

AutoIt:
    cv.BackgroundSubtractorKNN.getNSamples() -> retval

void cv::BackgroundSubtractorKNN::setNSamples( int _nN )

AutoIt:
    cv.BackgroundSubtractorKNN.setNSamples( $_nN ) -> None

double cv::BackgroundSubtractorKNN::getDist2Threshold()

AutoIt:
    cv.BackgroundSubtractorKNN.getDist2Threshold() -> retval

void cv::BackgroundSubtractorKNN::setDist2Threshold( double _dist2Threshold )

AutoIt:
    cv.BackgroundSubtractorKNN.setDist2Threshold( $_dist2Threshold ) -> None

int cv::BackgroundSubtractorKNN::getkNNSamples()

AutoIt:
    cv.BackgroundSubtractorKNN.getkNNSamples() -> retval

void cv::BackgroundSubtractorKNN::setkNNSamples( int _nkNN )

AutoIt:
    cv.BackgroundSubtractorKNN.setkNNSamples( $_nkNN ) -> None

bool cv::BackgroundSubtractorKNN::getDetectShadows()

AutoIt:
    cv.BackgroundSubtractorKNN.getDetectShadows() -> retval

void cv::BackgroundSubtractorKNN::setDetectShadows( bool detectShadows )

AutoIt:
    cv.BackgroundSubtractorKNN.setDetectShadows( $detectShadows ) -> None

int cv::BackgroundSubtractorKNN::getShadowValue()

AutoIt:
    cv.BackgroundSubtractorKNN.getShadowValue() -> retval

void cv::BackgroundSubtractorKNN::setShadowValue( int value )

AutoIt:
    cv.BackgroundSubtractorKNN.setShadowValue( $value ) -> None

double cv::BackgroundSubtractorKNN::getShadowThreshold()

AutoIt:
    cv.BackgroundSubtractorKNN.getShadowThreshold() -> retval

void cv::BackgroundSubtractorKNN::setShadowThreshold( double threshold )

AutoIt:
    cv.BackgroundSubtractorKNN.setShadowThreshold( $threshold ) -> None

void cv::BackgroundSubtractorKNN::apply( _InputArray  image
                                         _OutputArray fgmask
                                         double       learningRate = -1 )

AutoIt:
    cv.BackgroundSubtractorKNN.apply( $image[, $fgmask[, $learningRate]] ) -> fgmask

void cv::BackgroundSubtractorKNN::getBackgroundImage( _OutputArray backgroundImage )

AutoIt:
    cv.BackgroundSubtractorKNN.getBackgroundImage( [$backgroundImage] ) -> backgroundImage

void cv::BackgroundSubtractorKNN::clear()

AutoIt:
    cv.BackgroundSubtractorKNN.clear() -> None

void cv::BackgroundSubtractorKNN::write( const cv::Ptr<cv::FileStorage>& fs
                                         const std::string&              name = String() )

AutoIt:
    cv.BackgroundSubtractorKNN.write( $fs[, $name] ) -> None

void cv::BackgroundSubtractorKNN::read( const cv::FileNode& fn )

AutoIt:
    cv.BackgroundSubtractorKNN.read( $fn ) -> None

bool cv::BackgroundSubtractorKNN::empty()

AutoIt:
    cv.BackgroundSubtractorKNN.empty() -> retval

void cv::BackgroundSubtractorKNN::save( const std::string& filename )

AutoIt:
    cv.BackgroundSubtractorKNN.save( $filename ) -> None

std::string cv::BackgroundSubtractorKNN::getDefaultName()

AutoIt:
    cv.BackgroundSubtractorKNN.getDefaultName() -> retval

static cv::KalmanFilter cv::KalmanFilter::create()

AutoIt:
    cv.KalmanFilter.create() -> <cv.KalmanFilter object>

static cv::KalmanFilter cv::KalmanFilter::create( int dynamParams
                                                  int measureParams
                                                  int controlParams = 0
                                                  int type = CV_32F )

AutoIt:
    cv.KalmanFilter.create( $dynamParams, $measureParams[, $controlParams[, $type]] ) -> <cv.KalmanFilter object>

cv::Mat cv::KalmanFilter::predict( const cv::Mat& control = Mat() )

AutoIt:
    cv.KalmanFilter.predict( [$control] ) -> retval

cv::Mat cv::KalmanFilter::correct( const cv::Mat& measurement )

AutoIt:
    cv.KalmanFilter.correct( $measurement ) -> retval

void cv::DenseOpticalFlow::calc( _InputArray       I0
                                 _InputArray       I1
                                 _InputOutputArray flow )

AutoIt:
    cv.DenseOpticalFlow.calc( $I0, $I1, $flow ) -> flow

void cv::DenseOpticalFlow::collectGarbage()

AutoIt:
    cv.DenseOpticalFlow.collectGarbage() -> None

void cv::DenseOpticalFlow::clear()

AutoIt:
    cv.DenseOpticalFlow.clear() -> None

void cv::DenseOpticalFlow::write( const cv::Ptr<cv::FileStorage>& fs
                                  const std::string&              name = String() )

AutoIt:
    cv.DenseOpticalFlow.write( $fs[, $name] ) -> None

void cv::DenseOpticalFlow::read( const cv::FileNode& fn )

AutoIt:
    cv.DenseOpticalFlow.read( $fn ) -> None

bool cv::DenseOpticalFlow::empty()

AutoIt:
    cv.DenseOpticalFlow.empty() -> retval

void cv::DenseOpticalFlow::save( const std::string& filename )

AutoIt:
    cv.DenseOpticalFlow.save( $filename ) -> None

std::string cv::DenseOpticalFlow::getDefaultName()

AutoIt:
    cv.DenseOpticalFlow.getDefaultName() -> retval

void cv::SparseOpticalFlow::calc( _InputArray       prevImg
                                  _InputArray       nextImg
                                  _InputArray       prevPts
                                  _InputOutputArray nextPts
                                  _OutputArray      status
                                  _OutputArray      err = cv::noArray() )

AutoIt:
    cv.SparseOpticalFlow.calc( $prevImg, $nextImg, $prevPts, $nextPts[, $status[, $err]] ) -> nextPts, status, err

void cv::SparseOpticalFlow::clear()

AutoIt:
    cv.SparseOpticalFlow.clear() -> None

void cv::SparseOpticalFlow::write( const cv::Ptr<cv::FileStorage>& fs
                                   const std::string&              name = String() )

AutoIt:
    cv.SparseOpticalFlow.write( $fs[, $name] ) -> None

void cv::SparseOpticalFlow::read( const cv::FileNode& fn )

AutoIt:
    cv.SparseOpticalFlow.read( $fn ) -> None

bool cv::SparseOpticalFlow::empty()

AutoIt:
    cv.SparseOpticalFlow.empty() -> retval

void cv::SparseOpticalFlow::save( const std::string& filename )

AutoIt:
    cv.SparseOpticalFlow.save( $filename ) -> None

std::string cv::SparseOpticalFlow::getDefaultName()

AutoIt:
    cv.SparseOpticalFlow.getDefaultName() -> retval

int cv::FarnebackOpticalFlow::getNumLevels()

AutoIt:
    cv.FarnebackOpticalFlow.getNumLevels() -> retval

void cv::FarnebackOpticalFlow::setNumLevels( int numLevels )

AutoIt:
    cv.FarnebackOpticalFlow.setNumLevels( $numLevels ) -> None

double cv::FarnebackOpticalFlow::getPyrScale()

AutoIt:
    cv.FarnebackOpticalFlow.getPyrScale() -> retval

void cv::FarnebackOpticalFlow::setPyrScale( double pyrScale )

AutoIt:
    cv.FarnebackOpticalFlow.setPyrScale( $pyrScale ) -> None

bool cv::FarnebackOpticalFlow::getFastPyramids()

AutoIt:
    cv.FarnebackOpticalFlow.getFastPyramids() -> retval

void cv::FarnebackOpticalFlow::setFastPyramids( bool fastPyramids )

AutoIt:
    cv.FarnebackOpticalFlow.setFastPyramids( $fastPyramids ) -> None

int cv::FarnebackOpticalFlow::getWinSize()

AutoIt:
    cv.FarnebackOpticalFlow.getWinSize() -> retval

void cv::FarnebackOpticalFlow::setWinSize( int winSize )

AutoIt:
    cv.FarnebackOpticalFlow.setWinSize( $winSize ) -> None

int cv::FarnebackOpticalFlow::getNumIters()

AutoIt:
    cv.FarnebackOpticalFlow.getNumIters() -> retval

void cv::FarnebackOpticalFlow::setNumIters( int numIters )

AutoIt:
    cv.FarnebackOpticalFlow.setNumIters( $numIters ) -> None

int cv::FarnebackOpticalFlow::getPolyN()

AutoIt:
    cv.FarnebackOpticalFlow.getPolyN() -> retval

void cv::FarnebackOpticalFlow::setPolyN( int polyN )

AutoIt:
    cv.FarnebackOpticalFlow.setPolyN( $polyN ) -> None

double cv::FarnebackOpticalFlow::getPolySigma()

AutoIt:
    cv.FarnebackOpticalFlow.getPolySigma() -> retval

void cv::FarnebackOpticalFlow::setPolySigma( double polySigma )

AutoIt:
    cv.FarnebackOpticalFlow.setPolySigma( $polySigma ) -> None

int cv::FarnebackOpticalFlow::getFlags()

AutoIt:
    cv.FarnebackOpticalFlow.getFlags() -> retval

void cv::FarnebackOpticalFlow::setFlags( int flags )

AutoIt:
    cv.FarnebackOpticalFlow.setFlags( $flags ) -> None

static cv::Ptr<cv::FarnebackOpticalFlow> cv::FarnebackOpticalFlow::create( int    numLevels = 5
                                                                           double pyrScale = 0.5
                                                                           bool   fastPyramids = false
                                                                           int    winSize = 13
                                                                           int    numIters = 10
                                                                           int    polyN = 5
                                                                           double polySigma = 1.1
                                                                           int    flags = 0 )

AutoIt:
    cv.FarnebackOpticalFlow.create( [$numLevels[, $pyrScale[, $fastPyramids[, $winSize[, $numIters[, $polyN[, $polySigma[, $flags]]]]]]]] ) -> retval

void cv::FarnebackOpticalFlow::calc( _InputArray       I0
                                     _InputArray       I1
                                     _InputOutputArray flow )

AutoIt:
    cv.FarnebackOpticalFlow.calc( $I0, $I1, $flow ) -> flow

void cv::FarnebackOpticalFlow::collectGarbage()

AutoIt:
    cv.FarnebackOpticalFlow.collectGarbage() -> None

void cv::FarnebackOpticalFlow::clear()

AutoIt:
    cv.FarnebackOpticalFlow.clear() -> None

void cv::FarnebackOpticalFlow::write( const cv::Ptr<cv::FileStorage>& fs
                                      const std::string&              name = String() )

AutoIt:
    cv.FarnebackOpticalFlow.write( $fs[, $name] ) -> None

void cv::FarnebackOpticalFlow::read( const cv::FileNode& fn )

AutoIt:
    cv.FarnebackOpticalFlow.read( $fn ) -> None

bool cv::FarnebackOpticalFlow::empty()

AutoIt:
    cv.FarnebackOpticalFlow.empty() -> retval

void cv::FarnebackOpticalFlow::save( const std::string& filename )

AutoIt:
    cv.FarnebackOpticalFlow.save( $filename ) -> None

std::string cv::FarnebackOpticalFlow::getDefaultName()

AutoIt:
    cv.FarnebackOpticalFlow.getDefaultName() -> retval

void cv::VariationalRefinement::calcUV( _InputArray       I0
                                        _InputArray       I1
                                        _InputOutputArray flow_u
                                        _InputOutputArray flow_v )

AutoIt:
    cv.VariationalRefinement.calcUV( $I0, $I1, $flow_u, $flow_v ) -> flow_u, flow_v

int cv::VariationalRefinement::getFixedPointIterations()

AutoIt:
    cv.VariationalRefinement.getFixedPointIterations() -> retval

void cv::VariationalRefinement::setFixedPointIterations( int val )

AutoIt:
    cv.VariationalRefinement.setFixedPointIterations( $val ) -> None

int cv::VariationalRefinement::getSorIterations()

AutoIt:
    cv.VariationalRefinement.getSorIterations() -> retval

void cv::VariationalRefinement::setSorIterations( int val )

AutoIt:
    cv.VariationalRefinement.setSorIterations( $val ) -> None

float cv::VariationalRefinement::getOmega()

AutoIt:
    cv.VariationalRefinement.getOmega() -> retval

void cv::VariationalRefinement::setOmega( float val )

AutoIt:
    cv.VariationalRefinement.setOmega( $val ) -> None

float cv::VariationalRefinement::getAlpha()

AutoIt:
    cv.VariationalRefinement.getAlpha() -> retval

void cv::VariationalRefinement::setAlpha( float val )

AutoIt:
    cv.VariationalRefinement.setAlpha( $val ) -> None

float cv::VariationalRefinement::getDelta()

AutoIt:
    cv.VariationalRefinement.getDelta() -> retval

void cv::VariationalRefinement::setDelta( float val )

AutoIt:
    cv.VariationalRefinement.setDelta( $val ) -> None

float cv::VariationalRefinement::getGamma()

AutoIt:
    cv.VariationalRefinement.getGamma() -> retval

void cv::VariationalRefinement::setGamma( float val )

AutoIt:
    cv.VariationalRefinement.setGamma( $val ) -> None

static cv::Ptr<cv::VariationalRefinement> cv::VariationalRefinement::create()

AutoIt:
    cv.VariationalRefinement.create() -> retval

void cv::VariationalRefinement::calc( _InputArray       I0
                                      _InputArray       I1
                                      _InputOutputArray flow )

AutoIt:
    cv.VariationalRefinement.calc( $I0, $I1, $flow ) -> flow

void cv::VariationalRefinement::collectGarbage()

AutoIt:
    cv.VariationalRefinement.collectGarbage() -> None

void cv::VariationalRefinement::clear()

AutoIt:
    cv.VariationalRefinement.clear() -> None

void cv::VariationalRefinement::write( const cv::Ptr<cv::FileStorage>& fs
                                       const std::string&              name = String() )

AutoIt:
    cv.VariationalRefinement.write( $fs[, $name] ) -> None

void cv::VariationalRefinement::read( const cv::FileNode& fn )

AutoIt:
    cv.VariationalRefinement.read( $fn ) -> None

bool cv::VariationalRefinement::empty()

AutoIt:
    cv.VariationalRefinement.empty() -> retval

void cv::VariationalRefinement::save( const std::string& filename )

AutoIt:
    cv.VariationalRefinement.save( $filename ) -> None

std::string cv::VariationalRefinement::getDefaultName()

AutoIt:
    cv.VariationalRefinement.getDefaultName() -> retval

int cv::DISOpticalFlow::getFinestScale()

AutoIt:
    cv.DISOpticalFlow.getFinestScale() -> retval

void cv::DISOpticalFlow::setFinestScale( int val )

AutoIt:
    cv.DISOpticalFlow.setFinestScale( $val ) -> None

int cv::DISOpticalFlow::getPatchSize()

AutoIt:
    cv.DISOpticalFlow.getPatchSize() -> retval

void cv::DISOpticalFlow::setPatchSize( int val )

AutoIt:
    cv.DISOpticalFlow.setPatchSize( $val ) -> None

int cv::DISOpticalFlow::getPatchStride()

AutoIt:
    cv.DISOpticalFlow.getPatchStride() -> retval

void cv::DISOpticalFlow::setPatchStride( int val )

AutoIt:
    cv.DISOpticalFlow.setPatchStride( $val ) -> None

int cv::DISOpticalFlow::getGradientDescentIterations()

AutoIt:
    cv.DISOpticalFlow.getGradientDescentIterations() -> retval

void cv::DISOpticalFlow::setGradientDescentIterations( int val )

AutoIt:
    cv.DISOpticalFlow.setGradientDescentIterations( $val ) -> None

int cv::DISOpticalFlow::getVariationalRefinementIterations()

AutoIt:
    cv.DISOpticalFlow.getVariationalRefinementIterations() -> retval

void cv::DISOpticalFlow::setVariationalRefinementIterations( int val )

AutoIt:
    cv.DISOpticalFlow.setVariationalRefinementIterations( $val ) -> None

float cv::DISOpticalFlow::getVariationalRefinementAlpha()

AutoIt:
    cv.DISOpticalFlow.getVariationalRefinementAlpha() -> retval

void cv::DISOpticalFlow::setVariationalRefinementAlpha( float val )

AutoIt:
    cv.DISOpticalFlow.setVariationalRefinementAlpha( $val ) -> None

float cv::DISOpticalFlow::getVariationalRefinementDelta()

AutoIt:
    cv.DISOpticalFlow.getVariationalRefinementDelta() -> retval

void cv::DISOpticalFlow::setVariationalRefinementDelta( float val )

AutoIt:
    cv.DISOpticalFlow.setVariationalRefinementDelta( $val ) -> None

float cv::DISOpticalFlow::getVariationalRefinementGamma()

AutoIt:
    cv.DISOpticalFlow.getVariationalRefinementGamma() -> retval

void cv::DISOpticalFlow::setVariationalRefinementGamma( float val )

AutoIt:
    cv.DISOpticalFlow.setVariationalRefinementGamma( $val ) -> None

bool cv::DISOpticalFlow::getUseMeanNormalization()

AutoIt:
    cv.DISOpticalFlow.getUseMeanNormalization() -> retval

void cv::DISOpticalFlow::setUseMeanNormalization( bool val )

AutoIt:
    cv.DISOpticalFlow.setUseMeanNormalization( $val ) -> None

bool cv::DISOpticalFlow::getUseSpatialPropagation()

AutoIt:
    cv.DISOpticalFlow.getUseSpatialPropagation() -> retval

void cv::DISOpticalFlow::setUseSpatialPropagation( bool val )

AutoIt:
    cv.DISOpticalFlow.setUseSpatialPropagation( $val ) -> None

static cv::Ptr<cv::DISOpticalFlow> cv::DISOpticalFlow::create( int preset = DISOpticalFlow::PRESET_FAST )

AutoIt:
    cv.DISOpticalFlow.create( [$preset] ) -> retval

void cv::DISOpticalFlow::calc( _InputArray       I0
                               _InputArray       I1
                               _InputOutputArray flow )

AutoIt:
    cv.DISOpticalFlow.calc( $I0, $I1, $flow ) -> flow

void cv::DISOpticalFlow::collectGarbage()

AutoIt:
    cv.DISOpticalFlow.collectGarbage() -> None

void cv::DISOpticalFlow::clear()

AutoIt:
    cv.DISOpticalFlow.clear() -> None

void cv::DISOpticalFlow::write( const cv::Ptr<cv::FileStorage>& fs
                                const std::string&              name = String() )

AutoIt:
    cv.DISOpticalFlow.write( $fs[, $name] ) -> None

void cv::DISOpticalFlow::read( const cv::FileNode& fn )

AutoIt:
    cv.DISOpticalFlow.read( $fn ) -> None

bool cv::DISOpticalFlow::empty()

AutoIt:
    cv.DISOpticalFlow.empty() -> retval

void cv::DISOpticalFlow::save( const std::string& filename )

AutoIt:
    cv.DISOpticalFlow.save( $filename ) -> None

std::string cv::DISOpticalFlow::getDefaultName()

AutoIt:
    cv.DISOpticalFlow.getDefaultName() -> retval

cv::Size cv::SparsePyrLKOpticalFlow::getWinSize()

AutoIt:
    cv.SparsePyrLKOpticalFlow.getWinSize() -> retval

void cv::SparsePyrLKOpticalFlow::setWinSize( cv::Size winSize )

AutoIt:
    cv.SparsePyrLKOpticalFlow.setWinSize( $winSize ) -> None

int cv::SparsePyrLKOpticalFlow::getMaxLevel()

AutoIt:
    cv.SparsePyrLKOpticalFlow.getMaxLevel() -> retval

void cv::SparsePyrLKOpticalFlow::setMaxLevel( int maxLevel )

AutoIt:
    cv.SparsePyrLKOpticalFlow.setMaxLevel( $maxLevel ) -> None

cv::TermCriteria cv::SparsePyrLKOpticalFlow::getTermCriteria()

AutoIt:
    cv.SparsePyrLKOpticalFlow.getTermCriteria() -> retval

void cv::SparsePyrLKOpticalFlow::setTermCriteria( cv::TermCriteria& crit )

AutoIt:
    cv.SparsePyrLKOpticalFlow.setTermCriteria( $crit ) -> None

int cv::SparsePyrLKOpticalFlow::getFlags()

AutoIt:
    cv.SparsePyrLKOpticalFlow.getFlags() -> retval

void cv::SparsePyrLKOpticalFlow::setFlags( int flags )

AutoIt:
    cv.SparsePyrLKOpticalFlow.setFlags( $flags ) -> None

double cv::SparsePyrLKOpticalFlow::getMinEigThreshold()

AutoIt:
    cv.SparsePyrLKOpticalFlow.getMinEigThreshold() -> retval

void cv::SparsePyrLKOpticalFlow::setMinEigThreshold( double minEigThreshold )

AutoIt:
    cv.SparsePyrLKOpticalFlow.setMinEigThreshold( $minEigThreshold ) -> None

static cv::Ptr<cv::SparsePyrLKOpticalFlow> cv::SparsePyrLKOpticalFlow::create( cv::Size         winSize = Size(21, 21)
                                                                               int              maxLevel = 3
                                                                               cv::TermCriteria crit = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)
                                                                               int              flags = 0
                                                                               double           minEigThreshold = 1e-4 )

AutoIt:
    cv.SparsePyrLKOpticalFlow.create( [$winSize[, $maxLevel[, $crit[, $flags[, $minEigThreshold]]]]] ) -> retval

void cv::SparsePyrLKOpticalFlow::calc( _InputArray       prevImg
                                       _InputArray       nextImg
                                       _InputArray       prevPts
                                       _InputOutputArray nextPts
                                       _OutputArray      status
                                       _OutputArray      err = cv::noArray() )

AutoIt:
    cv.SparsePyrLKOpticalFlow.calc( $prevImg, $nextImg, $prevPts, $nextPts[, $status[, $err]] ) -> nextPts, status, err

void cv::SparsePyrLKOpticalFlow::clear()

AutoIt:
    cv.SparsePyrLKOpticalFlow.clear() -> None

void cv::SparsePyrLKOpticalFlow::write( const cv::Ptr<cv::FileStorage>& fs
                                        const std::string&              name = String() )

AutoIt:
    cv.SparsePyrLKOpticalFlow.write( $fs[, $name] ) -> None

void cv::SparsePyrLKOpticalFlow::read( const cv::FileNode& fn )

AutoIt:
    cv.SparsePyrLKOpticalFlow.read( $fn ) -> None

bool cv::SparsePyrLKOpticalFlow::empty()

AutoIt:
    cv.SparsePyrLKOpticalFlow.empty() -> retval

void cv::SparsePyrLKOpticalFlow::save( const std::string& filename )

AutoIt:
    cv.SparsePyrLKOpticalFlow.save( $filename ) -> None

std::string cv::SparsePyrLKOpticalFlow::getDefaultName()

AutoIt:
    cv.SparsePyrLKOpticalFlow.getDefaultName() -> retval

void cv::Tracker::init( _InputArray     image
                        const cv::Rect& boundingBox )

AutoIt:
    cv.Tracker.init( $image, $boundingBox ) -> None

bool cv::Tracker::update( _InputArray image
                          cv::Rect&   boundingBox )

AutoIt:
    cv.Tracker.update( $image[, $boundingBox] ) -> retval, boundingBox

static cv::Ptr<cv::TrackerMIL> cv::TrackerMIL::create( const cv::TrackerMIL::Params& parameters = TrackerMIL::Params() )

AutoIt:
    cv.TrackerMIL.create( [$parameters] ) -> retval

void cv::TrackerMIL::init( _InputArray     image
                           const cv::Rect& boundingBox )

AutoIt:
    cv.TrackerMIL.init( $image, $boundingBox ) -> None

bool cv::TrackerMIL::update( _InputArray image
                             cv::Rect&   boundingBox )

AutoIt:
    cv.TrackerMIL.update( $image[, $boundingBox] ) -> retval, boundingBox

static cv::TrackerMIL::Params cv::TrackerMIL::Params::create()

AutoIt:
    cv.TrackerMIL.Params.create() -> <cv.TrackerMIL.Params object>

static cv::TrackerMIL::Params cv::TrackerMIL::Params::create()

AutoIt:
    cv.TrackerMIL.Params.create() -> <cv.TrackerMIL.Params object>

static cv::Ptr<cv::TrackerGOTURN> cv::TrackerGOTURN::create( const cv::TrackerGOTURN::Params& parameters = TrackerGOTURN::Params() )

AutoIt:
    cv.TrackerGOTURN.create( [$parameters] ) -> retval

void cv::TrackerGOTURN::init( _InputArray     image
                              const cv::Rect& boundingBox )

AutoIt:
    cv.TrackerGOTURN.init( $image, $boundingBox ) -> None

bool cv::TrackerGOTURN::update( _InputArray image
                                cv::Rect&   boundingBox )

AutoIt:
    cv.TrackerGOTURN.update( $image[, $boundingBox] ) -> retval, boundingBox

static cv::TrackerGOTURN::Params cv::TrackerGOTURN::Params::create()

AutoIt:
    cv.TrackerGOTURN.Params.create() -> <cv.TrackerGOTURN.Params object>

static cv::TrackerGOTURN::Params cv::TrackerGOTURN::Params::create()

AutoIt:
    cv.TrackerGOTURN.Params.create() -> <cv.TrackerGOTURN.Params object>

static cv::Ptr<cv::TrackerDaSiamRPN> cv::TrackerDaSiamRPN::create( const cv::TrackerDaSiamRPN::Params& parameters = TrackerDaSiamRPN::Params() )

AutoIt:
    cv.TrackerDaSiamRPN.create( [$parameters] ) -> retval

float cv::TrackerDaSiamRPN::getTrackingScore()

AutoIt:
    cv.TrackerDaSiamRPN.getTrackingScore() -> retval

void cv::TrackerDaSiamRPN::init( _InputArray     image
                                 const cv::Rect& boundingBox )

AutoIt:
    cv.TrackerDaSiamRPN.init( $image, $boundingBox ) -> None

bool cv::TrackerDaSiamRPN::update( _InputArray image
                                   cv::Rect&   boundingBox )

AutoIt:
    cv.TrackerDaSiamRPN.update( $image[, $boundingBox] ) -> retval, boundingBox

static cv::TrackerDaSiamRPN::Params cv::TrackerDaSiamRPN::Params::create()

AutoIt:
    cv.TrackerDaSiamRPN.Params.create() -> <cv.TrackerDaSiamRPN.Params object>

static cv::TrackerDaSiamRPN::Params cv::TrackerDaSiamRPN::Params::create()

AutoIt:
    cv.TrackerDaSiamRPN.Params.create() -> <cv.TrackerDaSiamRPN.Params object>

cv::GMat cv::gapi::add( const cv::GMat& src1
                        const cv::GMat& src2
                        int             ddepth = -1 )

AutoIt:
    cv.gapi.add( $src1, $src2[, $ddepth] ) -> retval

cv::GMat cv::gapi::addC( const cv::GMat&    src1
                         const cv::GScalar& c
                         int                ddepth = -1 )

AutoIt:
    cv.gapi.addC( $src1, $c[, $ddepth] ) -> retval

cv::GScalar cv::gapi::mean( const cv::GMat& src )

AutoIt:
    cv.gapi.mean( $src ) -> retval

std::tuple<cv::GMat, cv::GScalar> cv::gapi::threshold( const cv::GMat&    src
                                                       const cv::GScalar& maxval
                                                       int                type )

AutoIt:
    cv.gapi.threshold( $src, $maxval, $type ) -> retval

cv::GMat cv::gapi::resize( const cv::GMat& src
                           const cv::Size& dsize
                           double          fx = 0
                           double          fy = 0
                           int             interpolation = INTER_LINEAR )

AutoIt:
    cv.gapi.resize( $src, $dsize[, $fx[, $fy[, $interpolation]]] ) -> retval

std::tuple<cv::GMat, cv::GMat, cv::GMat> cv::gapi::split3( const cv::GMat& src )

AutoIt:
    cv.gapi.split3( $src ) -> retval

std::tuple<cv::GOpaque<double>, cv::GMat, cv::GMat> cv::gapi::kmeans( const cv::GMat&         data
                                                                      const int               K
                                                                      const cv::TermCriteria& criteria
                                                                      const int               attempts
                                                                      const int               flags )

AutoIt:
    cv.gapi.kmeans( $data, $K, $criteria, $attempts, $flags ) -> retval

std::tuple<cv::GOpaque<double>, cv::GArray<int>, cv::GArray<cv::Point2f>> cv::gapi::kmeans( const cv::GArray<cv::Point2f>& data
                                                                                            const int                      K
                                                                                            const cv::GArray<int>&         bestLabels
                                                                                            const cv::TermCriteria&        criteria
                                                                                            const int                      attempts
                                                                                            const int                      flags )

AutoIt:
    cv.gapi.kmeans( $data, $K, $bestLabels, $criteria, $attempts, $flags ) -> retval

cv::GMat cv::gapi::medianBlur( const cv::GMat& src
                               int             ksize )

AutoIt:
    cv.gapi.medianBlur( $src, $ksize ) -> retval

cv::GArray<cv::Point2f> cv::gapi::goodFeaturesToTrack( const cv::GMat& image
                                                       int             maxCorners
                                                       double          qualityLevel
                                                       double          minDistance
                                                       const cv::Mat&  mask = Mat()
                                                       int             blockSize = 3
                                                       bool            useHarrisDetector = false
                                                       double          k = 0.04 )

AutoIt:
    cv.gapi.goodFeaturesToTrack( $image, $maxCorners, $qualityLevel, $minDistance[, $mask[, $blockSize[, $useHarrisDetector[, $k]]]] ) -> retval

cv::GOpaque<cv::Rect> cv::gapi::boundingRect( const cv::GMat& src )

AutoIt:
    cv.gapi.boundingRect( $src ) -> retval

cv::GOpaque<cv::Rect> cv::gapi::boundingRect( const cv::GArray<cv::Point2i>& src )

AutoIt:
    cv.gapi.boundingRect( $src ) -> retval

cv::GMat cv::gapi::BGR2RGB( const cv::GMat& src )

AutoIt:
    cv.gapi.BGR2RGB( $src ) -> retval

cv::GMat cv::gapi::RGB2Gray( const cv::GMat& src )

AutoIt:
    cv.gapi.RGB2Gray( $src ) -> retval

std::tuple<cv::GArray<cv::Rect>, cv::GArray<int>> cv::gapi::parseSSD( const cv::GMat&              in
                                                                      const cv::GOpaque<cv::Size>& inSz
                                                                      const float                  confidenceThreshold = 0.5f
                                                                      const int                    filterLabel = -1 )

AutoIt:
    cv.gapi.parseSSD( $in, $inSz[, $confidenceThreshold[, $filterLabel]] ) -> retval

cv::GArray<cv::Rect> cv::gapi::parseSSD( const cv::GMat&              in
                                         const cv::GOpaque<cv::Size>& inSz
                                         const float                  confidenceThreshold
                                         const bool                   alignmentToSquare
                                         const bool                   filterOutOfBounds )

AutoIt:
    cv.gapi.parseSSD( $in, $inSz, $confidenceThreshold, $alignmentToSquare, $filterOutOfBounds ) -> retval

std::tuple<cv::GArray<cv::Rect>, cv::GArray<int>> cv::gapi::parseYolo( const cv::GMat&              in
                                                                       const cv::GOpaque<cv::Size>& inSz
                                                                       const float                  confidenceThreshold = 0.5f
                                                                       const float                  nmsThreshold = 0.5f
                                                                       const std::vector<float>&    anchors = nn::parsers::GParseYolo::defaultAnchors() )

AutoIt:
    cv.gapi.parseYolo( $in, $inSz[, $confidenceThreshold[, $nmsThreshold[, $anchors]]] ) -> retval

cv::GMat cv::gapi::copy( const cv::GMat& in )

AutoIt:
    cv.gapi.copy( $in ) -> retval

cv::GOpaque<cv::Size> cv::gapi::streaming::size( const cv::GMat& src )

AutoIt:
    cv.gapi.streaming.size( $src ) -> retval

cv::GOpaque<cv::Size> cv::gapi::streaming::size( const cv::GOpaque<cv::Rect>& r )

AutoIt:
    cv.gapi.streaming.size( $r ) -> retval

cv::gapi::GKernelPackage cv::gapi::core::cpu::kernels()

AutoIt:
    cv.gapi.core.cpu.kernels() -> retval

cv::gapi::GKernelPackage cv::gapi::core::fluid::kernels()

AutoIt:
    cv.gapi.core.fluid.kernels() -> retval

static cv::GArrayDesc cv::GArrayDesc::create()

AutoIt:
    cv.GArrayDesc.create() -> <cv.GArrayDesc object>

static cv::GComputation cv::GComputation::create( cv::GProtoInputArgs  ins
                                                  cv::GProtoOutputArgs outs )

AutoIt:
    cv.GComputation.create( $ins, $outs ) -> <cv.GComputation object>

static cv::GComputation cv::GComputation::create( cv::GMat in
                                                  cv::GMat out )

AutoIt:
    cv.GComputation.create( $in, $out ) -> <cv.GComputation object>

static cv::GComputation cv::GComputation::create( cv::GMat    in
                                                  cv::GScalar out )

AutoIt:
    cv.GComputation.create( $in, $out ) -> <cv.GComputation object>

static cv::GComputation cv::GComputation::create( cv::GMat in1
                                                  cv::GMat in2
                                                  cv::GMat out )

AutoIt:
    cv.GComputation.create( $in1, $in2, $out ) -> <cv.GComputation object>

std::vector<cv::GRunArg> cv::GComputation::apply( const cv::detail::ExtractArgsCallback& callback
                                                  std::vector<cv::GCompileArg>           args = {} )

AutoIt:
    cv.GComputation.apply( $callback[, $args] ) -> retval

cv::GStreamingCompiled cv::GComputation::compileStreaming( std::vector<GMetaArg>        in_metas
                                                           std::vector<cv::GCompileArg> args = {} )

AutoIt:
    cv.GComputation.compileStreaming( $in_metas[, $args] ) -> retval

cv::GStreamingCompiled cv::GComputation::compileStreaming( std::vector<cv::GCompileArg> args = {} )

AutoIt:
    cv.GComputation.compileStreaming( [$args] ) -> retval

cv::GStreamingCompiled cv::GComputation::compileStreaming( const cv::detail::ExtractMetaCallback& callback
                                                           std::vector<cv::GCompileArg>           args = {} )

AutoIt:
    cv.GComputation.compileStreaming( $callback[, $args] ) -> retval

static cv::GFrame cv::GFrame::create()

AutoIt:
    cv.GFrame.create() -> <cv.GFrame object>

static cv::GMat cv::GMat::create()

AutoIt:
    cv.GMat.create() -> <cv.GMat object>

static cv::GMatDesc cv::GMatDesc::create()

AutoIt:
    cv.GMatDesc.create() -> <cv.GMatDesc object>

static cv::GMatDesc cv::GMatDesc::create( int      d
                                          int      c
                                          cv::Size s
                                          bool     p = false )

AutoIt:
    cv.GMatDesc.create( $d, $c, $s[, $p] ) -> <cv.GMatDesc object>

static cv::GMatDesc cv::GMatDesc::create( int                     d
                                          const std::vector<int>& dd )

AutoIt:
    cv.GMatDesc.create( $d, $dd ) -> <cv.GMatDesc object>

static cv::GMatDesc cv::GMatDesc::create( int              d
                                          std::vector<int> dd )

AutoIt:
    cv.GMatDesc.create( $d, $dd ) -> <cv.GMatDesc object>

static cv::GMatDesc cv::GMatDesc::create()

AutoIt:
    cv.GMatDesc.create() -> <cv.GMatDesc object>

cv::GMatDesc cv::GMatDesc::withSizeDelta( cv::Size delta )

AutoIt:
    cv.GMatDesc.withSizeDelta( $delta ) -> retval

cv::GMatDesc cv::GMatDesc::withSizeDelta( int dx
                                          int dy )

AutoIt:
    cv.GMatDesc.withSizeDelta( $dx, $dy ) -> retval

cv::GMatDesc cv::GMatDesc::withSize( cv::Size sz )

AutoIt:
    cv.GMatDesc.withSize( $sz ) -> retval

cv::GMatDesc cv::GMatDesc::withDepth( int ddepth )

AutoIt:
    cv.GMatDesc.withDepth( $ddepth ) -> retval

cv::GMatDesc cv::GMatDesc::withType( int ddepth
                                     int dchan )

AutoIt:
    cv.GMatDesc.withType( $ddepth, $dchan ) -> retval

cv::GMatDesc cv::GMatDesc::asPlanar()

AutoIt:
    cv.GMatDesc.asPlanar() -> retval

cv::GMatDesc cv::GMatDesc::asPlanar( int planes )

AutoIt:
    cv.GMatDesc.asPlanar( $planes ) -> retval

cv::GMatDesc cv::GMatDesc::asInterleaved()

AutoIt:
    cv.GMatDesc.asInterleaved() -> retval

static cv::GOpaqueDesc cv::GOpaqueDesc::create()

AutoIt:
    cv.GOpaqueDesc.create() -> <cv.GOpaqueDesc object>

static cv::GScalar cv::GScalar::create()

AutoIt:
    cv.GScalar.create() -> <cv.GScalar object>

static cv::GScalarDesc cv::GScalarDesc::create()

AutoIt:
    cv.GScalarDesc.create() -> <cv.GScalarDesc object>

static cv::GStreamingCompiled cv::GStreamingCompiled::create()

AutoIt:
    cv.GStreamingCompiled.create() -> <cv.GStreamingCompiled object>

void cv::GStreamingCompiled::setSource( const cv::detail::ExtractArgsCallback& callback )

AutoIt:
    cv.GStreamingCompiled.setSource( $callback ) -> None

void cv::GStreamingCompiled::start()

AutoIt:
    cv.GStreamingCompiled.start() -> None

std::tuple<bool, util_variant_GRunArgs, GOptRunArgs> cv::GStreamingCompiled::pull()

AutoIt:
    cv.GStreamingCompiled.pull() -> retval

void cv::GStreamingCompiled::stop()

AutoIt:
    cv.GStreamingCompiled.stop() -> None

bool cv::GStreamingCompiled::running()

AutoIt:
    cv.GStreamingCompiled.running() -> retval

static cv::gapi::streaming::queue_capacity cv::gapi::streaming::queue_capacity::create()

AutoIt:
    cv.gapi.streaming.queue_capacity.create() -> <cv.gapi.streaming.queue_capacity object>

static cv::gapi::streaming::queue_capacity cv::gapi::streaming::queue_capacity::create( size_t cap = 1 )

AutoIt:
    cv.gapi.streaming.queue_capacity.create( [$cap] ) -> <cv.gapi.streaming.queue_capacity object>

static cv::gapi::GNetParam cv::gapi::GNetParam::create()

AutoIt:
    cv.gapi.GNetParam.create() -> <cv.gapi.GNetParam object>

static cv::gapi::GNetPackage cv::gapi::GNetPackage::create()

AutoIt:
    cv.gapi.GNetPackage.create() -> <cv.gapi.GNetPackage object>

static cv::gapi::GNetPackage cv::gapi::GNetPackage::create()

AutoIt:
    cv.gapi.GNetPackage.create() -> <cv.gapi.GNetPackage object>

static cv::gapi::GNetPackage cv::gapi::GNetPackage::create( std::vector<cv::gapi::GNetParam> nets )

AutoIt:
    cv.gapi.GNetPackage.create( $nets ) -> <cv.gapi.GNetPackage object>

cv::gapi::ie::PyParams cv::gapi::ie::params( const std::string& tag
                                             const std::string& model
                                             const std::string& weights
                                             const std::string& device )

AutoIt:
    cv.gapi.ie.params( $tag, $model, $weights, $device ) -> retval

cv::gapi::ie::PyParams cv::gapi::ie::params( const std::string& tag
                                             const std::string& model
                                             const std::string& device )

AutoIt:
    cv.gapi.ie.params( $tag, $model, $device ) -> retval

static cv::gapi::ie::PyParams cv::gapi::ie::PyParams::create()

AutoIt:
    cv.gapi.ie.PyParams.create() -> <cv.gapi.ie.PyParams object>

static cv::gapi::ie::PyParams cv::gapi::ie::PyParams::create( const std::string& tag
                                                              const std::string& model
                                                              const std::string& weights
                                                              const std::string& device )

AutoIt:
    cv.gapi.ie.PyParams.create( $tag, $model, $weights, $device ) -> <cv.gapi.ie.PyParams object>

static cv::gapi::ie::PyParams cv::gapi::ie::PyParams::create( const std::string& tag
                                                              const std::string& model
                                                              const std::string& device )

AutoIt:
    cv.gapi.ie.PyParams.create( $tag, $model, $device ) -> <cv.gapi.ie.PyParams object>

cv::gapi::ie::PyParams cv::gapi::ie::PyParams::constInput( const std::string& layer_name
                                                           const cv::Mat&     data
                                                           int                hint = TraitAs::TENSOR )

AutoIt:
    cv.gapi.ie.PyParams.constInput( $layer_name, $data[, $hint] ) -> retval

cv::gapi::ie::PyParams cv::gapi::ie::PyParams::cfgNumRequests( size_t nireq )

AutoIt:
    cv.gapi.ie.PyParams.cfgNumRequests( $nireq ) -> retval

cv::gapi::ie::PyParams cv::gapi::ie::PyParams::cfgBatchSize( const size_t size )

AutoIt:
    cv.gapi.ie.PyParams.cfgBatchSize( $size ) -> retval

cv::gapi::GKernelPackage cv::gapi::core::ocl::kernels()

AutoIt:
    cv.gapi.core.ocl.kernels() -> retval

cv::Ptr<cv::gapi::wip::IStreamSource> cv::gapi::wip::make_capture_src( const std::string& path )

AutoIt:
    cv.gapi.wip.make_capture_src( $path ) -> retval

void cv::gapi::wip::draw::render( cv::Mat&                                      bgr
                                  const std::vector<cv::gapi::wip::draw::Prim>& prims
                                  std::vector<cv::GCompileArg>                  args = {} )

AutoIt:
    cv.gapi.wip.draw.render( $bgr, $prims[, $args] ) -> None

void cv::gapi::wip::draw::render( cv::Mat&                                      y_plane
                                  cv::Mat&                                      uv_plane
                                  const std::vector<cv::gapi::wip::draw::Prim>& prims
                                  std::vector<cv::GCompileArg>                  args = {} )

AutoIt:
    cv.gapi.wip.draw.render( $y_plane, $uv_plane, $prims[, $args] ) -> None

cv::GMat cv::gapi::wip::draw::render3ch( const cv::GMat&                              src
                                         const cv::GArray<cv::gapi::wip::draw::Prim>& prims )

AutoIt:
    cv.gapi.wip.draw.render3ch( $src, $prims ) -> retval

std::tuple<cv::GMat, cv::GMat> cv::gapi::wip::draw::renderNV12( const cv::GMat&                              y
                                                                const cv::GMat&                              uv
                                                                const cv::GArray<cv::gapi::wip::draw::Prim>& prims )

AutoIt:
    cv.gapi.wip.draw.renderNV12( $y, $uv, $prims ) -> retval

cv::gapi::GKernelPackage cv::gapi::render::ocv::kernels()

AutoIt:
    cv.gapi.render.ocv.kernels() -> retval

static cv::gapi::wip::draw::Text cv::gapi::wip::draw::Text::create()

AutoIt:
    cv.gapi.wip.draw.Text.create() -> <cv.gapi.wip.draw.Text object>

static cv::gapi::wip::draw::Text cv::gapi::wip::draw::Text::create( const std::string& text_
                                                                    const cv::Point&   org_
                                                                    int                ff_
                                                                    double             fs_
                                                                    const cv::Scalar&  color_
                                                                    int                thick_ = 1
                                                                    int                lt_ = 8
                                                                    bool               bottom_left_origin_ = false )

AutoIt:
    cv.gapi.wip.draw.Text.create( $text_, $org_, $ff_, $fs_, $color_[, $thick_[, $lt_[, $bottom_left_origin_]]] ) -> <cv.gapi.wip.draw.Text object>

static cv::gapi::wip::draw::Text cv::gapi::wip::draw::Text::create()

AutoIt:
    cv.gapi.wip.draw.Text.create() -> <cv.gapi.wip.draw.Text object>

static cv::gapi::wip::draw::Rect cv::gapi::wip::draw::Rect::create()

AutoIt:
    cv.gapi.wip.draw.Rect.create() -> <cv.gapi.wip.draw.Rect object>

static cv::gapi::wip::draw::Rect cv::gapi::wip::draw::Rect::create()

AutoIt:
    cv.gapi.wip.draw.Rect.create() -> <cv.gapi.wip.draw.Rect object>

static cv::gapi::wip::draw::Circle cv::gapi::wip::draw::Circle::create()

AutoIt:
    cv.gapi.wip.draw.Circle.create() -> <cv.gapi.wip.draw.Circle object>

static cv::gapi::wip::draw::Circle cv::gapi::wip::draw::Circle::create( const cv::Point&  center_
                                                                        int               radius_
                                                                        const cv::Scalar& color_
                                                                        int               thick_ = 1
                                                                        int               lt_ = 8
                                                                        int               shift_ = 0 )

AutoIt:
    cv.gapi.wip.draw.Circle.create( $center_, $radius_, $color_[, $thick_[, $lt_[, $shift_]]] ) -> <cv.gapi.wip.draw.Circle object>

static cv::gapi::wip::draw::Circle cv::gapi::wip::draw::Circle::create()

AutoIt:
    cv.gapi.wip.draw.Circle.create() -> <cv.gapi.wip.draw.Circle object>

static cv::gapi::wip::draw::Line cv::gapi::wip::draw::Line::create()

AutoIt:
    cv.gapi.wip.draw.Line.create() -> <cv.gapi.wip.draw.Line object>

static cv::gapi::wip::draw::Line cv::gapi::wip::draw::Line::create( const cv::Point&  pt1_
                                                                    const cv::Point&  pt2_
                                                                    const cv::Scalar& color_
                                                                    int               thick_ = 1
                                                                    int               lt_ = 8
                                                                    int               shift_ = 0 )

AutoIt:
    cv.gapi.wip.draw.Line.create( $pt1_, $pt2_, $color_[, $thick_[, $lt_[, $shift_]]] ) -> <cv.gapi.wip.draw.Line object>

static cv::gapi::wip::draw::Line cv::gapi::wip::draw::Line::create()

AutoIt:
    cv.gapi.wip.draw.Line.create() -> <cv.gapi.wip.draw.Line object>

static cv::gapi::wip::draw::Mosaic cv::gapi::wip::draw::Mosaic::create()

AutoIt:
    cv.gapi.wip.draw.Mosaic.create() -> <cv.gapi.wip.draw.Mosaic object>

static cv::gapi::wip::draw::Mosaic cv::gapi::wip::draw::Mosaic::create()

AutoIt:
    cv.gapi.wip.draw.Mosaic.create() -> <cv.gapi.wip.draw.Mosaic object>

static cv::gapi::wip::draw::Image cv::gapi::wip::draw::Image::create()

AutoIt:
    cv.gapi.wip.draw.Image.create() -> <cv.gapi.wip.draw.Image object>

static cv::gapi::wip::draw::Image cv::gapi::wip::draw::Image::create( const cv::Point& org_
                                                                      const cv::Mat&   img_
                                                                      const cv::Mat&   alpha_ )

AutoIt:
    cv.gapi.wip.draw.Image.create( $org_, $img_, $alpha_ ) -> <cv.gapi.wip.draw.Image object>

static cv::gapi::wip::draw::Image cv::gapi::wip::draw::Image::create()

AutoIt:
    cv.gapi.wip.draw.Image.create() -> <cv.gapi.wip.draw.Image object>

static cv::gapi::wip::draw::Poly cv::gapi::wip::draw::Poly::create()

AutoIt:
    cv.gapi.wip.draw.Poly.create() -> <cv.gapi.wip.draw.Poly object>

static cv::gapi::wip::draw::Poly cv::gapi::wip::draw::Poly::create( const std::vector<cv::Point>& points_
                                                                    const cv::Scalar&             color_
                                                                    int                           thick_ = 1
                                                                    int                           lt_ = 8
                                                                    int                           shift_ = 0 )

AutoIt:
    cv.gapi.wip.draw.Poly.create( $points_, $color_[, $thick_[, $lt_[, $shift_]]] ) -> <cv.gapi.wip.draw.Poly object>

static cv::gapi::wip::draw::Poly cv::gapi::wip::draw::Poly::create()

AutoIt:
    cv.gapi.wip.draw.Poly.create() -> <cv.gapi.wip.draw.Poly object>

bool cv::wgc::isWGCSupported()

AutoIt:
    cv.wgc.isWGCSupported() -> retval

cv::Ptr<cv::wgc::SimpleCapture> cv::wgc::createSimpleCapture()

AutoIt:
    cv.wgc.createSimpleCapture() -> retval

cv::Ptr<cv::wgc::SimpleCapture> cv::wgc::createSimpleCapture( WGCFrameCallback handleFrame )

AutoIt:
    cv.wgc.createSimpleCapture( $handleFrame ) -> retval

void cv::wgc::BitBltCapture( HWND     hWnd
                             cv::Mat& dst
                             WORD     channels = 4 )

AutoIt:
    cv.wgc.BitBltCapture( $hWnd[, $channels[, $dst]] ) -> dst

bool cv::wgc::SimpleCapture::setHandle( HWND hWnd
                                        WORD channels = 4 )

AutoIt:
    cv.wgc.SimpleCapture.setHandle( $hWnd[, $channels] ) -> retval

bool cv::wgc::SimpleCapture::Start()

AutoIt:
    cv.wgc.SimpleCapture.Start() -> retval

bool cv::wgc::SimpleCapture::Pause()

AutoIt:
    cv.wgc.SimpleCapture.Pause() -> retval

bool cv::wgc::SimpleCapture::Resume()

AutoIt:
    cv.wgc.SimpleCapture.Resume() -> retval

bool cv::wgc::SimpleCapture::Stop()

AutoIt:
    cv.wgc.SimpleCapture.Stop() -> retval

bool cv::wgc::SimpleCapture::Paused()

AutoIt:
    cv.wgc.SimpleCapture.Paused() -> retval

static cv::Range cv::Range::create()

AutoIt:
    cv.Range.create() -> <cv.Range object>

static cv::Range cv::Range::create( int start
                                    int end )

AutoIt:
    cv.Range.create( $start, $end ) -> <cv.Range object>

int cv::Range::size()

AutoIt:
    cv.Range.size() -> retval

bool cv::Range::empty()

AutoIt:
    cv.Range.empty() -> retval

static cv::Range cv::Range::all()

AutoIt:
    cv.Range.all() -> retval

static cv::RotatedRect cv::RotatedRect::create()

AutoIt:
    cv.RotatedRect.create() -> <cv.RotatedRect object>

static cv::RotatedRect cv::RotatedRect::create( cv::Point2f center
                                                cv::Size2f  size
                                                float       angle )

AutoIt:
    cv.RotatedRect.create( $center, $size, $angle ) -> <cv.RotatedRect object>

static cv::RotatedRect cv::RotatedRect::create( cv::Point2f point1
                                                cv::Point2f point2
                                                cv::Point2f point3 )

AutoIt:
    cv.RotatedRect.create( $point1, $point2, $point3 ) -> <cv.RotatedRect object>

cv::Rect cv::RotatedRect::boundingRect()

AutoIt:
    cv.RotatedRect.boundingRect() -> retval

static cv::GCompileArg cv::GCompileArg::create()

AutoIt:
    cv.GCompileArg.create() -> <cv.GCompileArg object>

static cv::GRunArg cv::GRunArg::create()

AutoIt:
    cv.GRunArg.create() -> <cv.GRunArg object>

static VectorOfVariant VectorOfVariant::create()

AutoIt:
    VectorOfVariant.create() -> <VectorOfVariant object>

static VectorOfVariant VectorOfVariant::create( size_t size )

AutoIt:
    VectorOfVariant.create( $size ) -> <VectorOfVariant object>

static VectorOfVariant VectorOfVariant::create( VectorOfVariant other )

AutoIt:
    VectorOfVariant.create( $other ) -> <VectorOfVariant object>

std::vector<int> VectorOfVariant::Keys()

AutoIt:
    VectorOfVariant.Keys() -> retval

VectorOfVariant VectorOfVariant::Items()

AutoIt:
    VectorOfVariant.Items() -> retval

void VectorOfVariant::push_back( _variant_t value )

AutoIt:
    VectorOfVariant.push_back( $value ) -> None

void VectorOfVariant::Add( _variant_t value )

AutoIt:
    VectorOfVariant.Add( $value ) -> None

void VectorOfVariant::Remove( size_t index )

AutoIt:
    VectorOfVariant.Remove( $index ) -> None

_variant_t VectorOfVariant::at( size_t index )

AutoIt:
    VectorOfVariant.at( $index ) -> retval

void VectorOfVariant::at( size_t     index
                          _variant_t value )

AutoIt:
    VectorOfVariant.at( $index, $value ) -> None

size_t VectorOfVariant::size()

AutoIt:
    VectorOfVariant.size() -> retval

bool VectorOfVariant::empty()

AutoIt:
    VectorOfVariant.empty() -> retval

void VectorOfVariant::clear()

AutoIt:
    VectorOfVariant.clear() -> None

void VectorOfVariant::push_vector( VectorOfVariant other )

AutoIt:
    VectorOfVariant.push_vector( $other ) -> None

void VectorOfVariant::push_vector( VectorOfVariant other
                                   size_t          count
                                   size_t          start = 0 )

AutoIt:
    VectorOfVariant.push_vector( $other, $count[, $start] ) -> None

VectorOfVariant VectorOfVariant::slice( size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVariant.slice( [$start[, $count]] ) -> retval

void VectorOfVariant::sort( void*  comparator
                            size_t start = 0
                            size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVariant.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVariant::sort_variant( void*  comparator
                                    size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVariant.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVariant::start()

AutoIt:
    VectorOfVariant.start() -> retval

void* VectorOfVariant::end()

AutoIt:
    VectorOfVariant.end() -> retval

_variant_t VectorOfVariant::get_Item( size_t vIndex )

AutoIt:
    VectorOfVariant.Item( $vIndex ) -> retval
    VectorOfVariant( $vIndex ) -> retval

void VectorOfVariant::put_Item( size_t     vIndex
                                _variant_t vItem )

AutoIt:
    VectorOfVariant.Item( $vIndex ) = $vItem

static VectorOfMat VectorOfMat::create()

AutoIt:
    VectorOfMat.create() -> <VectorOfMat object>

static VectorOfMat VectorOfMat::create( size_t size )

AutoIt:
    VectorOfMat.create( $size ) -> <VectorOfMat object>

static VectorOfMat VectorOfMat::create( VectorOfMat other )

AutoIt:
    VectorOfMat.create( $other ) -> <VectorOfMat object>

std::vector<int> VectorOfMat::Keys()

AutoIt:
    VectorOfMat.Keys() -> retval

VectorOfMat VectorOfMat::Items()

AutoIt:
    VectorOfMat.Items() -> retval

void VectorOfMat::push_back( cv::Mat value )

AutoIt:
    VectorOfMat.push_back( $value ) -> None

void VectorOfMat::Add( cv::Mat value )

AutoIt:
    VectorOfMat.Add( $value ) -> None

void VectorOfMat::Remove( size_t index )

AutoIt:
    VectorOfMat.Remove( $index ) -> None

cv::Mat VectorOfMat::at( size_t index )

AutoIt:
    VectorOfMat.at( $index ) -> retval

void VectorOfMat::at( size_t  index
                      cv::Mat value )

AutoIt:
    VectorOfMat.at( $index, $value ) -> None

size_t VectorOfMat::size()

AutoIt:
    VectorOfMat.size() -> retval

bool VectorOfMat::empty()

AutoIt:
    VectorOfMat.empty() -> retval

void VectorOfMat::clear()

AutoIt:
    VectorOfMat.clear() -> None

void VectorOfMat::push_vector( VectorOfMat other )

AutoIt:
    VectorOfMat.push_vector( $other ) -> None

void VectorOfMat::push_vector( VectorOfMat other
                               size_t      count
                               size_t      start = 0 )

AutoIt:
    VectorOfMat.push_vector( $other, $count[, $start] ) -> None

VectorOfMat VectorOfMat::slice( size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfMat.slice( [$start[, $count]] ) -> retval

void VectorOfMat::sort( void*  comparator
                        size_t start = 0
                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfMat.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfMat::sort_variant( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfMat.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfMat::start()

AutoIt:
    VectorOfMat.start() -> retval

void* VectorOfMat::end()

AutoIt:
    VectorOfMat.end() -> retval

cv::Mat VectorOfMat::get_Item( size_t vIndex )

AutoIt:
    VectorOfMat.Item( $vIndex ) -> retval
    VectorOfMat( $vIndex ) -> retval

void VectorOfMat::put_Item( size_t  vIndex
                            cv::Mat vItem )

AutoIt:
    VectorOfMat.Item( $vIndex ) = $vItem

static VectorOfInt VectorOfInt::create()

AutoIt:
    VectorOfInt.create() -> <VectorOfInt object>

static VectorOfInt VectorOfInt::create( size_t size )

AutoIt:
    VectorOfInt.create( $size ) -> <VectorOfInt object>

static VectorOfInt VectorOfInt::create( VectorOfInt other )

AutoIt:
    VectorOfInt.create( $other ) -> <VectorOfInt object>

std::vector<int> VectorOfInt::Keys()

AutoIt:
    VectorOfInt.Keys() -> retval

VectorOfInt VectorOfInt::Items()

AutoIt:
    VectorOfInt.Items() -> retval

void VectorOfInt::push_back( int value )

AutoIt:
    VectorOfInt.push_back( $value ) -> None

void VectorOfInt::Add( int value )

AutoIt:
    VectorOfInt.Add( $value ) -> None

void VectorOfInt::Remove( size_t index )

AutoIt:
    VectorOfInt.Remove( $index ) -> None

int VectorOfInt::at( size_t index )

AutoIt:
    VectorOfInt.at( $index ) -> retval

void VectorOfInt::at( size_t index
                      int    value )

AutoIt:
    VectorOfInt.at( $index, $value ) -> None

size_t VectorOfInt::size()

AutoIt:
    VectorOfInt.size() -> retval

bool VectorOfInt::empty()

AutoIt:
    VectorOfInt.empty() -> retval

void VectorOfInt::clear()

AutoIt:
    VectorOfInt.clear() -> None

void VectorOfInt::push_vector( VectorOfInt other )

AutoIt:
    VectorOfInt.push_vector( $other ) -> None

void VectorOfInt::push_vector( VectorOfInt other
                               size_t      count
                               size_t      start = 0 )

AutoIt:
    VectorOfInt.push_vector( $other, $count[, $start] ) -> None

VectorOfInt VectorOfInt::slice( size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfInt.slice( [$start[, $count]] ) -> retval

void VectorOfInt::sort( void*  comparator
                        size_t start = 0
                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfInt.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfInt::sort_variant( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfInt.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfInt::start()

AutoIt:
    VectorOfInt.start() -> retval

void* VectorOfInt::end()

AutoIt:
    VectorOfInt.end() -> retval

int VectorOfInt::get_Item( size_t vIndex )

AutoIt:
    VectorOfInt.Item( $vIndex ) -> retval
    VectorOfInt( $vIndex ) -> retval

void VectorOfInt::put_Item( size_t vIndex
                            int    vItem )

AutoIt:
    VectorOfInt.Item( $vIndex ) = $vItem

static VectorOfFloat VectorOfFloat::create()

AutoIt:
    VectorOfFloat.create() -> <VectorOfFloat object>

static VectorOfFloat VectorOfFloat::create( size_t size )

AutoIt:
    VectorOfFloat.create( $size ) -> <VectorOfFloat object>

static VectorOfFloat VectorOfFloat::create( VectorOfFloat other )

AutoIt:
    VectorOfFloat.create( $other ) -> <VectorOfFloat object>

std::vector<int> VectorOfFloat::Keys()

AutoIt:
    VectorOfFloat.Keys() -> retval

VectorOfFloat VectorOfFloat::Items()

AutoIt:
    VectorOfFloat.Items() -> retval

void VectorOfFloat::push_back( float value )

AutoIt:
    VectorOfFloat.push_back( $value ) -> None

void VectorOfFloat::Add( float value )

AutoIt:
    VectorOfFloat.Add( $value ) -> None

void VectorOfFloat::Remove( size_t index )

AutoIt:
    VectorOfFloat.Remove( $index ) -> None

float VectorOfFloat::at( size_t index )

AutoIt:
    VectorOfFloat.at( $index ) -> retval

void VectorOfFloat::at( size_t index
                        float  value )

AutoIt:
    VectorOfFloat.at( $index, $value ) -> None

size_t VectorOfFloat::size()

AutoIt:
    VectorOfFloat.size() -> retval

bool VectorOfFloat::empty()

AutoIt:
    VectorOfFloat.empty() -> retval

void VectorOfFloat::clear()

AutoIt:
    VectorOfFloat.clear() -> None

void VectorOfFloat::push_vector( VectorOfFloat other )

AutoIt:
    VectorOfFloat.push_vector( $other ) -> None

void VectorOfFloat::push_vector( VectorOfFloat other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfFloat.push_vector( $other, $count[, $start] ) -> None

VectorOfFloat VectorOfFloat::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfFloat.slice( [$start[, $count]] ) -> retval

void VectorOfFloat::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfFloat.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfFloat::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfFloat.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfFloat::start()

AutoIt:
    VectorOfFloat.start() -> retval

void* VectorOfFloat::end()

AutoIt:
    VectorOfFloat.end() -> retval

float VectorOfFloat::get_Item( size_t vIndex )

AutoIt:
    VectorOfFloat.Item( $vIndex ) -> retval
    VectorOfFloat( $vIndex ) -> retval

void VectorOfFloat::put_Item( size_t vIndex
                              float  vItem )

AutoIt:
    VectorOfFloat.Item( $vIndex ) = $vItem

static VectorOfPoint VectorOfPoint::create()

AutoIt:
    VectorOfPoint.create() -> <VectorOfPoint object>

static VectorOfPoint VectorOfPoint::create( size_t size )

AutoIt:
    VectorOfPoint.create( $size ) -> <VectorOfPoint object>

static VectorOfPoint VectorOfPoint::create( VectorOfPoint other )

AutoIt:
    VectorOfPoint.create( $other ) -> <VectorOfPoint object>

std::vector<int> VectorOfPoint::Keys()

AutoIt:
    VectorOfPoint.Keys() -> retval

VectorOfPoint VectorOfPoint::Items()

AutoIt:
    VectorOfPoint.Items() -> retval

void VectorOfPoint::push_back( cv::Point value )

AutoIt:
    VectorOfPoint.push_back( $value ) -> None

void VectorOfPoint::Add( cv::Point value )

AutoIt:
    VectorOfPoint.Add( $value ) -> None

void VectorOfPoint::Remove( size_t index )

AutoIt:
    VectorOfPoint.Remove( $index ) -> None

cv::Point VectorOfPoint::at( size_t index )

AutoIt:
    VectorOfPoint.at( $index ) -> retval

void VectorOfPoint::at( size_t    index
                        cv::Point value )

AutoIt:
    VectorOfPoint.at( $index, $value ) -> None

size_t VectorOfPoint::size()

AutoIt:
    VectorOfPoint.size() -> retval

bool VectorOfPoint::empty()

AutoIt:
    VectorOfPoint.empty() -> retval

void VectorOfPoint::clear()

AutoIt:
    VectorOfPoint.clear() -> None

void VectorOfPoint::push_vector( VectorOfPoint other )

AutoIt:
    VectorOfPoint.push_vector( $other ) -> None

void VectorOfPoint::push_vector( VectorOfPoint other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfPoint.push_vector( $other, $count[, $start] ) -> None

VectorOfPoint VectorOfPoint::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPoint.slice( [$start[, $count]] ) -> retval

void VectorOfPoint::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPoint.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfPoint::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPoint.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfPoint::start()

AutoIt:
    VectorOfPoint.start() -> retval

void* VectorOfPoint::end()

AutoIt:
    VectorOfPoint.end() -> retval

cv::Point VectorOfPoint::get_Item( size_t vIndex )

AutoIt:
    VectorOfPoint.Item( $vIndex ) -> retval
    VectorOfPoint( $vIndex ) -> retval

void VectorOfPoint::put_Item( size_t    vIndex
                              cv::Point vItem )

AutoIt:
    VectorOfPoint.Item( $vIndex ) = $vItem

static VectorOfKeyPoint VectorOfKeyPoint::create()

AutoIt:
    VectorOfKeyPoint.create() -> <VectorOfKeyPoint object>

static VectorOfKeyPoint VectorOfKeyPoint::create( size_t size )

AutoIt:
    VectorOfKeyPoint.create( $size ) -> <VectorOfKeyPoint object>

static VectorOfKeyPoint VectorOfKeyPoint::create( VectorOfKeyPoint other )

AutoIt:
    VectorOfKeyPoint.create( $other ) -> <VectorOfKeyPoint object>

std::vector<int> VectorOfKeyPoint::Keys()

AutoIt:
    VectorOfKeyPoint.Keys() -> retval

VectorOfKeyPoint VectorOfKeyPoint::Items()

AutoIt:
    VectorOfKeyPoint.Items() -> retval

void VectorOfKeyPoint::push_back( cv::KeyPoint value )

AutoIt:
    VectorOfKeyPoint.push_back( $value ) -> None

void VectorOfKeyPoint::Add( cv::KeyPoint value )

AutoIt:
    VectorOfKeyPoint.Add( $value ) -> None

void VectorOfKeyPoint::Remove( size_t index )

AutoIt:
    VectorOfKeyPoint.Remove( $index ) -> None

cv::KeyPoint VectorOfKeyPoint::at( size_t index )

AutoIt:
    VectorOfKeyPoint.at( $index ) -> retval

void VectorOfKeyPoint::at( size_t       index
                           cv::KeyPoint value )

AutoIt:
    VectorOfKeyPoint.at( $index, $value ) -> None

size_t VectorOfKeyPoint::size()

AutoIt:
    VectorOfKeyPoint.size() -> retval

bool VectorOfKeyPoint::empty()

AutoIt:
    VectorOfKeyPoint.empty() -> retval

void VectorOfKeyPoint::clear()

AutoIt:
    VectorOfKeyPoint.clear() -> None

void VectorOfKeyPoint::push_vector( VectorOfKeyPoint other )

AutoIt:
    VectorOfKeyPoint.push_vector( $other ) -> None

void VectorOfKeyPoint::push_vector( VectorOfKeyPoint other
                                    size_t           count
                                    size_t           start = 0 )

AutoIt:
    VectorOfKeyPoint.push_vector( $other, $count[, $start] ) -> None

VectorOfKeyPoint VectorOfKeyPoint::slice( size_t start = 0
                                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfKeyPoint.slice( [$start[, $count]] ) -> retval

void VectorOfKeyPoint::sort( void*  comparator
                             size_t start = 0
                             size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfKeyPoint.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfKeyPoint::sort_variant( void*  comparator
                                     size_t start = 0
                                     size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfKeyPoint.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfKeyPoint::start()

AutoIt:
    VectorOfKeyPoint.start() -> retval

void* VectorOfKeyPoint::end()

AutoIt:
    VectorOfKeyPoint.end() -> retval

cv::KeyPoint VectorOfKeyPoint::get_Item( size_t vIndex )

AutoIt:
    VectorOfKeyPoint.Item( $vIndex ) -> retval
    VectorOfKeyPoint( $vIndex ) -> retval

void VectorOfKeyPoint::put_Item( size_t       vIndex
                                 cv::KeyPoint vItem )

AutoIt:
    VectorOfKeyPoint.Item( $vIndex ) = $vItem

static VectorOfDMatch VectorOfDMatch::create()

AutoIt:
    VectorOfDMatch.create() -> <VectorOfDMatch object>

static VectorOfDMatch VectorOfDMatch::create( size_t size )

AutoIt:
    VectorOfDMatch.create( $size ) -> <VectorOfDMatch object>

static VectorOfDMatch VectorOfDMatch::create( VectorOfDMatch other )

AutoIt:
    VectorOfDMatch.create( $other ) -> <VectorOfDMatch object>

std::vector<int> VectorOfDMatch::Keys()

AutoIt:
    VectorOfDMatch.Keys() -> retval

VectorOfDMatch VectorOfDMatch::Items()

AutoIt:
    VectorOfDMatch.Items() -> retval

void VectorOfDMatch::push_back( cv::DMatch value )

AutoIt:
    VectorOfDMatch.push_back( $value ) -> None

void VectorOfDMatch::Add( cv::DMatch value )

AutoIt:
    VectorOfDMatch.Add( $value ) -> None

void VectorOfDMatch::Remove( size_t index )

AutoIt:
    VectorOfDMatch.Remove( $index ) -> None

cv::DMatch VectorOfDMatch::at( size_t index )

AutoIt:
    VectorOfDMatch.at( $index ) -> retval

void VectorOfDMatch::at( size_t     index
                         cv::DMatch value )

AutoIt:
    VectorOfDMatch.at( $index, $value ) -> None

size_t VectorOfDMatch::size()

AutoIt:
    VectorOfDMatch.size() -> retval

bool VectorOfDMatch::empty()

AutoIt:
    VectorOfDMatch.empty() -> retval

void VectorOfDMatch::clear()

AutoIt:
    VectorOfDMatch.clear() -> None

void VectorOfDMatch::push_vector( VectorOfDMatch other )

AutoIt:
    VectorOfDMatch.push_vector( $other ) -> None

void VectorOfDMatch::push_vector( VectorOfDMatch other
                                  size_t         count
                                  size_t         start = 0 )

AutoIt:
    VectorOfDMatch.push_vector( $other, $count[, $start] ) -> None

VectorOfDMatch VectorOfDMatch::slice( size_t start = 0
                                      size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfDMatch.slice( [$start[, $count]] ) -> retval

void VectorOfDMatch::sort( void*  comparator
                           size_t start = 0
                           size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfDMatch.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfDMatch::sort_variant( void*  comparator
                                   size_t start = 0
                                   size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfDMatch.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfDMatch::start()

AutoIt:
    VectorOfDMatch.start() -> retval

void* VectorOfDMatch::end()

AutoIt:
    VectorOfDMatch.end() -> retval

cv::DMatch VectorOfDMatch::get_Item( size_t vIndex )

AutoIt:
    VectorOfDMatch.Item( $vIndex ) -> retval
    VectorOfDMatch( $vIndex ) -> retval

void VectorOfDMatch::put_Item( size_t     vIndex
                               cv::DMatch vItem )

AutoIt:
    VectorOfDMatch.Item( $vIndex ) = $vItem

static VectorOfChar VectorOfChar::create()

AutoIt:
    VectorOfChar.create() -> <VectorOfChar object>

static VectorOfChar VectorOfChar::create( size_t size )

AutoIt:
    VectorOfChar.create( $size ) -> <VectorOfChar object>

static VectorOfChar VectorOfChar::create( VectorOfChar other )

AutoIt:
    VectorOfChar.create( $other ) -> <VectorOfChar object>

std::vector<int> VectorOfChar::Keys()

AutoIt:
    VectorOfChar.Keys() -> retval

VectorOfChar VectorOfChar::Items()

AutoIt:
    VectorOfChar.Items() -> retval

void VectorOfChar::push_back( char value )

AutoIt:
    VectorOfChar.push_back( $value ) -> None

void VectorOfChar::Add( char value )

AutoIt:
    VectorOfChar.Add( $value ) -> None

void VectorOfChar::Remove( size_t index )

AutoIt:
    VectorOfChar.Remove( $index ) -> None

char VectorOfChar::at( size_t index )

AutoIt:
    VectorOfChar.at( $index ) -> retval

void VectorOfChar::at( size_t index
                       char   value )

AutoIt:
    VectorOfChar.at( $index, $value ) -> None

size_t VectorOfChar::size()

AutoIt:
    VectorOfChar.size() -> retval

bool VectorOfChar::empty()

AutoIt:
    VectorOfChar.empty() -> retval

void VectorOfChar::clear()

AutoIt:
    VectorOfChar.clear() -> None

void VectorOfChar::push_vector( VectorOfChar other )

AutoIt:
    VectorOfChar.push_vector( $other ) -> None

void VectorOfChar::push_vector( VectorOfChar other
                                size_t       count
                                size_t       start = 0 )

AutoIt:
    VectorOfChar.push_vector( $other, $count[, $start] ) -> None

VectorOfChar VectorOfChar::slice( size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfChar.slice( [$start[, $count]] ) -> retval

void VectorOfChar::sort( void*  comparator
                         size_t start = 0
                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfChar.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfChar::sort_variant( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfChar.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfChar::start()

AutoIt:
    VectorOfChar.start() -> retval

void* VectorOfChar::end()

AutoIt:
    VectorOfChar.end() -> retval

char VectorOfChar::get_Item( size_t vIndex )

AutoIt:
    VectorOfChar.Item( $vIndex ) -> retval
    VectorOfChar( $vIndex ) -> retval

void VectorOfChar::put_Item( size_t vIndex
                             char   vItem )

AutoIt:
    VectorOfChar.Item( $vIndex ) = $vItem

static VectorOfVectorOfDMatch VectorOfVectorOfDMatch::create()

AutoIt:
    VectorOfVectorOfDMatch.create() -> <VectorOfVectorOfDMatch object>

static VectorOfVectorOfDMatch VectorOfVectorOfDMatch::create( size_t size )

AutoIt:
    VectorOfVectorOfDMatch.create( $size ) -> <VectorOfVectorOfDMatch object>

static VectorOfVectorOfDMatch VectorOfVectorOfDMatch::create( VectorOfVectorOfDMatch other )

AutoIt:
    VectorOfVectorOfDMatch.create( $other ) -> <VectorOfVectorOfDMatch object>

std::vector<int> VectorOfVectorOfDMatch::Keys()

AutoIt:
    VectorOfVectorOfDMatch.Keys() -> retval

VectorOfVectorOfDMatch VectorOfVectorOfDMatch::Items()

AutoIt:
    VectorOfVectorOfDMatch.Items() -> retval

void VectorOfVectorOfDMatch::push_back( std::vector<cv::DMatch> value )

AutoIt:
    VectorOfVectorOfDMatch.push_back( $value ) -> None

void VectorOfVectorOfDMatch::Add( std::vector<cv::DMatch> value )

AutoIt:
    VectorOfVectorOfDMatch.Add( $value ) -> None

void VectorOfVectorOfDMatch::Remove( size_t index )

AutoIt:
    VectorOfVectorOfDMatch.Remove( $index ) -> None

std::vector<cv::DMatch> VectorOfVectorOfDMatch::at( size_t index )

AutoIt:
    VectorOfVectorOfDMatch.at( $index ) -> retval

void VectorOfVectorOfDMatch::at( size_t                  index
                                 std::vector<cv::DMatch> value )

AutoIt:
    VectorOfVectorOfDMatch.at( $index, $value ) -> None

size_t VectorOfVectorOfDMatch::size()

AutoIt:
    VectorOfVectorOfDMatch.size() -> retval

bool VectorOfVectorOfDMatch::empty()

AutoIt:
    VectorOfVectorOfDMatch.empty() -> retval

void VectorOfVectorOfDMatch::clear()

AutoIt:
    VectorOfVectorOfDMatch.clear() -> None

void VectorOfVectorOfDMatch::push_vector( VectorOfVectorOfDMatch other )

AutoIt:
    VectorOfVectorOfDMatch.push_vector( $other ) -> None

void VectorOfVectorOfDMatch::push_vector( VectorOfVectorOfDMatch other
                                          size_t                 count
                                          size_t                 start = 0 )

AutoIt:
    VectorOfVectorOfDMatch.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfDMatch VectorOfVectorOfDMatch::slice( size_t start = 0
                                                      size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfDMatch.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfDMatch::sort( void*  comparator
                                   size_t start = 0
                                   size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfDMatch.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfDMatch::sort_variant( void*  comparator
                                           size_t start = 0
                                           size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfDMatch.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfDMatch::start()

AutoIt:
    VectorOfVectorOfDMatch.start() -> retval

void* VectorOfVectorOfDMatch::end()

AutoIt:
    VectorOfVectorOfDMatch.end() -> retval

std::vector<cv::DMatch> VectorOfVectorOfDMatch::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfDMatch.Item( $vIndex ) -> retval
    VectorOfVectorOfDMatch( $vIndex ) -> retval

void VectorOfVectorOfDMatch::put_Item( size_t                  vIndex
                                       std::vector<cv::DMatch> vItem )

AutoIt:
    VectorOfVectorOfDMatch.Item( $vIndex ) = $vItem

static VectorOfVectorOfChar VectorOfVectorOfChar::create()

AutoIt:
    VectorOfVectorOfChar.create() -> <VectorOfVectorOfChar object>

static VectorOfVectorOfChar VectorOfVectorOfChar::create( size_t size )

AutoIt:
    VectorOfVectorOfChar.create( $size ) -> <VectorOfVectorOfChar object>

static VectorOfVectorOfChar VectorOfVectorOfChar::create( VectorOfVectorOfChar other )

AutoIt:
    VectorOfVectorOfChar.create( $other ) -> <VectorOfVectorOfChar object>

std::vector<int> VectorOfVectorOfChar::Keys()

AutoIt:
    VectorOfVectorOfChar.Keys() -> retval

VectorOfVectorOfChar VectorOfVectorOfChar::Items()

AutoIt:
    VectorOfVectorOfChar.Items() -> retval

void VectorOfVectorOfChar::push_back( std::vector<char> value )

AutoIt:
    VectorOfVectorOfChar.push_back( $value ) -> None

void VectorOfVectorOfChar::Add( std::vector<char> value )

AutoIt:
    VectorOfVectorOfChar.Add( $value ) -> None

void VectorOfVectorOfChar::Remove( size_t index )

AutoIt:
    VectorOfVectorOfChar.Remove( $index ) -> None

std::vector<char> VectorOfVectorOfChar::at( size_t index )

AutoIt:
    VectorOfVectorOfChar.at( $index ) -> retval

void VectorOfVectorOfChar::at( size_t            index
                               std::vector<char> value )

AutoIt:
    VectorOfVectorOfChar.at( $index, $value ) -> None

size_t VectorOfVectorOfChar::size()

AutoIt:
    VectorOfVectorOfChar.size() -> retval

bool VectorOfVectorOfChar::empty()

AutoIt:
    VectorOfVectorOfChar.empty() -> retval

void VectorOfVectorOfChar::clear()

AutoIt:
    VectorOfVectorOfChar.clear() -> None

void VectorOfVectorOfChar::push_vector( VectorOfVectorOfChar other )

AutoIt:
    VectorOfVectorOfChar.push_vector( $other ) -> None

void VectorOfVectorOfChar::push_vector( VectorOfVectorOfChar other
                                        size_t               count
                                        size_t               start = 0 )

AutoIt:
    VectorOfVectorOfChar.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfChar VectorOfVectorOfChar::slice( size_t start = 0
                                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfChar.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfChar::sort( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfChar.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfChar::sort_variant( void*  comparator
                                         size_t start = 0
                                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfChar.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfChar::start()

AutoIt:
    VectorOfVectorOfChar.start() -> retval

void* VectorOfVectorOfChar::end()

AutoIt:
    VectorOfVectorOfChar.end() -> retval

std::vector<char> VectorOfVectorOfChar::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfChar.Item( $vIndex ) -> retval
    VectorOfVectorOfChar( $vIndex ) -> retval

void VectorOfVectorOfChar::put_Item( size_t            vIndex
                                     std::vector<char> vItem )

AutoIt:
    VectorOfVectorOfChar.Item( $vIndex ) = $vItem

static VectorOfUchar VectorOfUchar::create()

AutoIt:
    VectorOfUchar.create() -> <VectorOfUchar object>

static VectorOfUchar VectorOfUchar::create( size_t size )

AutoIt:
    VectorOfUchar.create( $size ) -> <VectorOfUchar object>

static VectorOfUchar VectorOfUchar::create( VectorOfUchar other )

AutoIt:
    VectorOfUchar.create( $other ) -> <VectorOfUchar object>

std::vector<int> VectorOfUchar::Keys()

AutoIt:
    VectorOfUchar.Keys() -> retval

VectorOfUchar VectorOfUchar::Items()

AutoIt:
    VectorOfUchar.Items() -> retval

void VectorOfUchar::push_back( uchar value )

AutoIt:
    VectorOfUchar.push_back( $value ) -> None

void VectorOfUchar::Add( uchar value )

AutoIt:
    VectorOfUchar.Add( $value ) -> None

void VectorOfUchar::Remove( size_t index )

AutoIt:
    VectorOfUchar.Remove( $index ) -> None

uchar VectorOfUchar::at( size_t index )

AutoIt:
    VectorOfUchar.at( $index ) -> retval

void VectorOfUchar::at( size_t index
                        uchar  value )

AutoIt:
    VectorOfUchar.at( $index, $value ) -> None

size_t VectorOfUchar::size()

AutoIt:
    VectorOfUchar.size() -> retval

bool VectorOfUchar::empty()

AutoIt:
    VectorOfUchar.empty() -> retval

void VectorOfUchar::clear()

AutoIt:
    VectorOfUchar.clear() -> None

void VectorOfUchar::push_vector( VectorOfUchar other )

AutoIt:
    VectorOfUchar.push_vector( $other ) -> None

void VectorOfUchar::push_vector( VectorOfUchar other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfUchar.push_vector( $other, $count[, $start] ) -> None

VectorOfUchar VectorOfUchar::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfUchar.slice( [$start[, $count]] ) -> retval

void VectorOfUchar::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfUchar.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfUchar::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfUchar.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfUchar::start()

AutoIt:
    VectorOfUchar.start() -> retval

void* VectorOfUchar::end()

AutoIt:
    VectorOfUchar.end() -> retval

uchar VectorOfUchar::get_Item( size_t vIndex )

AutoIt:
    VectorOfUchar.Item( $vIndex ) -> retval
    VectorOfUchar( $vIndex ) -> retval

void VectorOfUchar::put_Item( size_t vIndex
                              uchar  vItem )

AutoIt:
    VectorOfUchar.Item( $vIndex ) = $vItem

static VectorOfRect VectorOfRect::create()

AutoIt:
    VectorOfRect.create() -> <VectorOfRect object>

static VectorOfRect VectorOfRect::create( size_t size )

AutoIt:
    VectorOfRect.create( $size ) -> <VectorOfRect object>

static VectorOfRect VectorOfRect::create( VectorOfRect other )

AutoIt:
    VectorOfRect.create( $other ) -> <VectorOfRect object>

std::vector<int> VectorOfRect::Keys()

AutoIt:
    VectorOfRect.Keys() -> retval

VectorOfRect VectorOfRect::Items()

AutoIt:
    VectorOfRect.Items() -> retval

void VectorOfRect::push_back( cv::Rect value )

AutoIt:
    VectorOfRect.push_back( $value ) -> None

void VectorOfRect::Add( cv::Rect value )

AutoIt:
    VectorOfRect.Add( $value ) -> None

void VectorOfRect::Remove( size_t index )

AutoIt:
    VectorOfRect.Remove( $index ) -> None

cv::Rect VectorOfRect::at( size_t index )

AutoIt:
    VectorOfRect.at( $index ) -> retval

void VectorOfRect::at( size_t   index
                       cv::Rect value )

AutoIt:
    VectorOfRect.at( $index, $value ) -> None

size_t VectorOfRect::size()

AutoIt:
    VectorOfRect.size() -> retval

bool VectorOfRect::empty()

AutoIt:
    VectorOfRect.empty() -> retval

void VectorOfRect::clear()

AutoIt:
    VectorOfRect.clear() -> None

void VectorOfRect::push_vector( VectorOfRect other )

AutoIt:
    VectorOfRect.push_vector( $other ) -> None

void VectorOfRect::push_vector( VectorOfRect other
                                size_t       count
                                size_t       start = 0 )

AutoIt:
    VectorOfRect.push_vector( $other, $count[, $start] ) -> None

VectorOfRect VectorOfRect::slice( size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRect.slice( [$start[, $count]] ) -> retval

void VectorOfRect::sort( void*  comparator
                         size_t start = 0
                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRect.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfRect::sort_variant( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRect.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfRect::start()

AutoIt:
    VectorOfRect.start() -> retval

void* VectorOfRect::end()

AutoIt:
    VectorOfRect.end() -> retval

cv::Rect VectorOfRect::get_Item( size_t vIndex )

AutoIt:
    VectorOfRect.Item( $vIndex ) -> retval
    VectorOfRect( $vIndex ) -> retval

void VectorOfRect::put_Item( size_t   vIndex
                             cv::Rect vItem )

AutoIt:
    VectorOfRect.Item( $vIndex ) = $vItem

static VectorOfRotatedRect VectorOfRotatedRect::create()

AutoIt:
    VectorOfRotatedRect.create() -> <VectorOfRotatedRect object>

static VectorOfRotatedRect VectorOfRotatedRect::create( size_t size )

AutoIt:
    VectorOfRotatedRect.create( $size ) -> <VectorOfRotatedRect object>

static VectorOfRotatedRect VectorOfRotatedRect::create( VectorOfRotatedRect other )

AutoIt:
    VectorOfRotatedRect.create( $other ) -> <VectorOfRotatedRect object>

std::vector<int> VectorOfRotatedRect::Keys()

AutoIt:
    VectorOfRotatedRect.Keys() -> retval

VectorOfRotatedRect VectorOfRotatedRect::Items()

AutoIt:
    VectorOfRotatedRect.Items() -> retval

void VectorOfRotatedRect::push_back( cv::RotatedRect value )

AutoIt:
    VectorOfRotatedRect.push_back( $value ) -> None

void VectorOfRotatedRect::Add( cv::RotatedRect value )

AutoIt:
    VectorOfRotatedRect.Add( $value ) -> None

void VectorOfRotatedRect::Remove( size_t index )

AutoIt:
    VectorOfRotatedRect.Remove( $index ) -> None

cv::RotatedRect VectorOfRotatedRect::at( size_t index )

AutoIt:
    VectorOfRotatedRect.at( $index ) -> retval

void VectorOfRotatedRect::at( size_t          index
                              cv::RotatedRect value )

AutoIt:
    VectorOfRotatedRect.at( $index, $value ) -> None

size_t VectorOfRotatedRect::size()

AutoIt:
    VectorOfRotatedRect.size() -> retval

bool VectorOfRotatedRect::empty()

AutoIt:
    VectorOfRotatedRect.empty() -> retval

void VectorOfRotatedRect::clear()

AutoIt:
    VectorOfRotatedRect.clear() -> None

void VectorOfRotatedRect::push_vector( VectorOfRotatedRect other )

AutoIt:
    VectorOfRotatedRect.push_vector( $other ) -> None

void VectorOfRotatedRect::push_vector( VectorOfRotatedRect other
                                       size_t              count
                                       size_t              start = 0 )

AutoIt:
    VectorOfRotatedRect.push_vector( $other, $count[, $start] ) -> None

VectorOfRotatedRect VectorOfRotatedRect::slice( size_t start = 0
                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRotatedRect.slice( [$start[, $count]] ) -> retval

void VectorOfRotatedRect::sort( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRotatedRect.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfRotatedRect::sort_variant( void*  comparator
                                        size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRotatedRect.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfRotatedRect::start()

AutoIt:
    VectorOfRotatedRect.start() -> retval

void* VectorOfRotatedRect::end()

AutoIt:
    VectorOfRotatedRect.end() -> retval

cv::RotatedRect VectorOfRotatedRect::get_Item( size_t vIndex )

AutoIt:
    VectorOfRotatedRect.Item( $vIndex ) -> retval
    VectorOfRotatedRect( $vIndex ) -> retval

void VectorOfRotatedRect::put_Item( size_t          vIndex
                                    cv::RotatedRect vItem )

AutoIt:
    VectorOfRotatedRect.Item( $vIndex ) = $vItem

static VectorOfDouble VectorOfDouble::create()

AutoIt:
    VectorOfDouble.create() -> <VectorOfDouble object>

static VectorOfDouble VectorOfDouble::create( size_t size )

AutoIt:
    VectorOfDouble.create( $size ) -> <VectorOfDouble object>

static VectorOfDouble VectorOfDouble::create( VectorOfDouble other )

AutoIt:
    VectorOfDouble.create( $other ) -> <VectorOfDouble object>

std::vector<int> VectorOfDouble::Keys()

AutoIt:
    VectorOfDouble.Keys() -> retval

VectorOfDouble VectorOfDouble::Items()

AutoIt:
    VectorOfDouble.Items() -> retval

void VectorOfDouble::push_back( double value )

AutoIt:
    VectorOfDouble.push_back( $value ) -> None

void VectorOfDouble::Add( double value )

AutoIt:
    VectorOfDouble.Add( $value ) -> None

void VectorOfDouble::Remove( size_t index )

AutoIt:
    VectorOfDouble.Remove( $index ) -> None

double VectorOfDouble::at( size_t index )

AutoIt:
    VectorOfDouble.at( $index ) -> retval

void VectorOfDouble::at( size_t index
                         double value )

AutoIt:
    VectorOfDouble.at( $index, $value ) -> None

size_t VectorOfDouble::size()

AutoIt:
    VectorOfDouble.size() -> retval

bool VectorOfDouble::empty()

AutoIt:
    VectorOfDouble.empty() -> retval

void VectorOfDouble::clear()

AutoIt:
    VectorOfDouble.clear() -> None

void VectorOfDouble::push_vector( VectorOfDouble other )

AutoIt:
    VectorOfDouble.push_vector( $other ) -> None

void VectorOfDouble::push_vector( VectorOfDouble other
                                  size_t         count
                                  size_t         start = 0 )

AutoIt:
    VectorOfDouble.push_vector( $other, $count[, $start] ) -> None

VectorOfDouble VectorOfDouble::slice( size_t start = 0
                                      size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfDouble.slice( [$start[, $count]] ) -> retval

void VectorOfDouble::sort( void*  comparator
                           size_t start = 0
                           size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfDouble.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfDouble::sort_variant( void*  comparator
                                   size_t start = 0
                                   size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfDouble.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfDouble::start()

AutoIt:
    VectorOfDouble.start() -> retval

void* VectorOfDouble::end()

AutoIt:
    VectorOfDouble.end() -> retval

double VectorOfDouble::get_Item( size_t vIndex )

AutoIt:
    VectorOfDouble.Item( $vIndex ) -> retval
    VectorOfDouble( $vIndex ) -> retval

void VectorOfDouble::put_Item( size_t vIndex
                               double vItem )

AutoIt:
    VectorOfDouble.Item( $vIndex ) = $vItem

static VectorOfUMat VectorOfUMat::create()

AutoIt:
    VectorOfUMat.create() -> <VectorOfUMat object>

static VectorOfUMat VectorOfUMat::create( size_t size )

AutoIt:
    VectorOfUMat.create( $size ) -> <VectorOfUMat object>

static VectorOfUMat VectorOfUMat::create( VectorOfUMat other )

AutoIt:
    VectorOfUMat.create( $other ) -> <VectorOfUMat object>

std::vector<int> VectorOfUMat::Keys()

AutoIt:
    VectorOfUMat.Keys() -> retval

VectorOfUMat VectorOfUMat::Items()

AutoIt:
    VectorOfUMat.Items() -> retval

void VectorOfUMat::push_back( cv::UMat value )

AutoIt:
    VectorOfUMat.push_back( $value ) -> None

void VectorOfUMat::Add( cv::UMat value )

AutoIt:
    VectorOfUMat.Add( $value ) -> None

void VectorOfUMat::Remove( size_t index )

AutoIt:
    VectorOfUMat.Remove( $index ) -> None

cv::UMat VectorOfUMat::at( size_t index )

AutoIt:
    VectorOfUMat.at( $index ) -> retval

void VectorOfUMat::at( size_t   index
                       cv::UMat value )

AutoIt:
    VectorOfUMat.at( $index, $value ) -> None

size_t VectorOfUMat::size()

AutoIt:
    VectorOfUMat.size() -> retval

bool VectorOfUMat::empty()

AutoIt:
    VectorOfUMat.empty() -> retval

void VectorOfUMat::clear()

AutoIt:
    VectorOfUMat.clear() -> None

void VectorOfUMat::push_vector( VectorOfUMat other )

AutoIt:
    VectorOfUMat.push_vector( $other ) -> None

void VectorOfUMat::push_vector( VectorOfUMat other
                                size_t       count
                                size_t       start = 0 )

AutoIt:
    VectorOfUMat.push_vector( $other, $count[, $start] ) -> None

VectorOfUMat VectorOfUMat::slice( size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfUMat.slice( [$start[, $count]] ) -> retval

void VectorOfUMat::sort( void*  comparator
                         size_t start = 0
                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfUMat.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfUMat::sort_variant( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfUMat.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfUMat::start()

AutoIt:
    VectorOfUMat.start() -> retval

void* VectorOfUMat::end()

AutoIt:
    VectorOfUMat.end() -> retval

cv::UMat VectorOfUMat::get_Item( size_t vIndex )

AutoIt:
    VectorOfUMat.Item( $vIndex ) -> retval
    VectorOfUMat( $vIndex ) -> retval

void VectorOfUMat::put_Item( size_t   vIndex
                             cv::UMat vItem )

AutoIt:
    VectorOfUMat.Item( $vIndex ) = $vItem

static VectorOfImageFeatures VectorOfImageFeatures::create()

AutoIt:
    VectorOfImageFeatures.create() -> <VectorOfImageFeatures object>

static VectorOfImageFeatures VectorOfImageFeatures::create( size_t size )

AutoIt:
    VectorOfImageFeatures.create( $size ) -> <VectorOfImageFeatures object>

static VectorOfImageFeatures VectorOfImageFeatures::create( VectorOfImageFeatures other )

AutoIt:
    VectorOfImageFeatures.create( $other ) -> <VectorOfImageFeatures object>

std::vector<int> VectorOfImageFeatures::Keys()

AutoIt:
    VectorOfImageFeatures.Keys() -> retval

VectorOfImageFeatures VectorOfImageFeatures::Items()

AutoIt:
    VectorOfImageFeatures.Items() -> retval

void VectorOfImageFeatures::push_back( cv::detail::ImageFeatures value )

AutoIt:
    VectorOfImageFeatures.push_back( $value ) -> None

void VectorOfImageFeatures::Add( cv::detail::ImageFeatures value )

AutoIt:
    VectorOfImageFeatures.Add( $value ) -> None

void VectorOfImageFeatures::Remove( size_t index )

AutoIt:
    VectorOfImageFeatures.Remove( $index ) -> None

cv::detail::ImageFeatures VectorOfImageFeatures::at( size_t index )

AutoIt:
    VectorOfImageFeatures.at( $index ) -> retval

void VectorOfImageFeatures::at( size_t                    index
                                cv::detail::ImageFeatures value )

AutoIt:
    VectorOfImageFeatures.at( $index, $value ) -> None

size_t VectorOfImageFeatures::size()

AutoIt:
    VectorOfImageFeatures.size() -> retval

bool VectorOfImageFeatures::empty()

AutoIt:
    VectorOfImageFeatures.empty() -> retval

void VectorOfImageFeatures::clear()

AutoIt:
    VectorOfImageFeatures.clear() -> None

void VectorOfImageFeatures::push_vector( VectorOfImageFeatures other )

AutoIt:
    VectorOfImageFeatures.push_vector( $other ) -> None

void VectorOfImageFeatures::push_vector( VectorOfImageFeatures other
                                         size_t                count
                                         size_t                start = 0 )

AutoIt:
    VectorOfImageFeatures.push_vector( $other, $count[, $start] ) -> None

VectorOfImageFeatures VectorOfImageFeatures::slice( size_t start = 0
                                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfImageFeatures.slice( [$start[, $count]] ) -> retval

void VectorOfImageFeatures::sort( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfImageFeatures.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfImageFeatures::sort_variant( void*  comparator
                                          size_t start = 0
                                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfImageFeatures.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfImageFeatures::start()

AutoIt:
    VectorOfImageFeatures.start() -> retval

void* VectorOfImageFeatures::end()

AutoIt:
    VectorOfImageFeatures.end() -> retval

cv::detail::ImageFeatures VectorOfImageFeatures::get_Item( size_t vIndex )

AutoIt:
    VectorOfImageFeatures.Item( $vIndex ) -> retval
    VectorOfImageFeatures( $vIndex ) -> retval

void VectorOfImageFeatures::put_Item( size_t                    vIndex
                                      cv::detail::ImageFeatures vItem )

AutoIt:
    VectorOfImageFeatures.Item( $vIndex ) = $vItem

static VectorOfString VectorOfString::create()

AutoIt:
    VectorOfString.create() -> <VectorOfString object>

static VectorOfString VectorOfString::create( size_t size )

AutoIt:
    VectorOfString.create( $size ) -> <VectorOfString object>

static VectorOfString VectorOfString::create( VectorOfString other )

AutoIt:
    VectorOfString.create( $other ) -> <VectorOfString object>

std::vector<int> VectorOfString::Keys()

AutoIt:
    VectorOfString.Keys() -> retval

VectorOfString VectorOfString::Items()

AutoIt:
    VectorOfString.Items() -> retval

void VectorOfString::push_back( std::string value )

AutoIt:
    VectorOfString.push_back( $value ) -> None

void VectorOfString::Add( std::string value )

AutoIt:
    VectorOfString.Add( $value ) -> None

void VectorOfString::Remove( size_t index )

AutoIt:
    VectorOfString.Remove( $index ) -> None

std::string VectorOfString::at( size_t index )

AutoIt:
    VectorOfString.at( $index ) -> retval

void VectorOfString::at( size_t      index
                         std::string value )

AutoIt:
    VectorOfString.at( $index, $value ) -> None

size_t VectorOfString::size()

AutoIt:
    VectorOfString.size() -> retval

bool VectorOfString::empty()

AutoIt:
    VectorOfString.empty() -> retval

void VectorOfString::clear()

AutoIt:
    VectorOfString.clear() -> None

void VectorOfString::push_vector( VectorOfString other )

AutoIt:
    VectorOfString.push_vector( $other ) -> None

void VectorOfString::push_vector( VectorOfString other
                                  size_t         count
                                  size_t         start = 0 )

AutoIt:
    VectorOfString.push_vector( $other, $count[, $start] ) -> None

VectorOfString VectorOfString::slice( size_t start = 0
                                      size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfString.slice( [$start[, $count]] ) -> retval

void VectorOfString::sort( void*  comparator
                           size_t start = 0
                           size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfString.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfString::sort_variant( void*  comparator
                                   size_t start = 0
                                   size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfString.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfString::start()

AutoIt:
    VectorOfString.start() -> retval

void* VectorOfString::end()

AutoIt:
    VectorOfString.end() -> retval

std::string VectorOfString::get_Item( size_t vIndex )

AutoIt:
    VectorOfString.Item( $vIndex ) -> retval
    VectorOfString( $vIndex ) -> retval

void VectorOfString::put_Item( size_t      vIndex
                               std::string vItem )

AutoIt:
    VectorOfString.Item( $vIndex ) = $vItem

static VectorOfMatchesInfo VectorOfMatchesInfo::create()

AutoIt:
    VectorOfMatchesInfo.create() -> <VectorOfMatchesInfo object>

static VectorOfMatchesInfo VectorOfMatchesInfo::create( size_t size )

AutoIt:
    VectorOfMatchesInfo.create( $size ) -> <VectorOfMatchesInfo object>

static VectorOfMatchesInfo VectorOfMatchesInfo::create( VectorOfMatchesInfo other )

AutoIt:
    VectorOfMatchesInfo.create( $other ) -> <VectorOfMatchesInfo object>

std::vector<int> VectorOfMatchesInfo::Keys()

AutoIt:
    VectorOfMatchesInfo.Keys() -> retval

VectorOfMatchesInfo VectorOfMatchesInfo::Items()

AutoIt:
    VectorOfMatchesInfo.Items() -> retval

void VectorOfMatchesInfo::push_back( cv::detail::MatchesInfo value )

AutoIt:
    VectorOfMatchesInfo.push_back( $value ) -> None

void VectorOfMatchesInfo::Add( cv::detail::MatchesInfo value )

AutoIt:
    VectorOfMatchesInfo.Add( $value ) -> None

void VectorOfMatchesInfo::Remove( size_t index )

AutoIt:
    VectorOfMatchesInfo.Remove( $index ) -> None

cv::detail::MatchesInfo VectorOfMatchesInfo::at( size_t index )

AutoIt:
    VectorOfMatchesInfo.at( $index ) -> retval

void VectorOfMatchesInfo::at( size_t                  index
                              cv::detail::MatchesInfo value )

AutoIt:
    VectorOfMatchesInfo.at( $index, $value ) -> None

size_t VectorOfMatchesInfo::size()

AutoIt:
    VectorOfMatchesInfo.size() -> retval

bool VectorOfMatchesInfo::empty()

AutoIt:
    VectorOfMatchesInfo.empty() -> retval

void VectorOfMatchesInfo::clear()

AutoIt:
    VectorOfMatchesInfo.clear() -> None

void VectorOfMatchesInfo::push_vector( VectorOfMatchesInfo other )

AutoIt:
    VectorOfMatchesInfo.push_vector( $other ) -> None

void VectorOfMatchesInfo::push_vector( VectorOfMatchesInfo other
                                       size_t              count
                                       size_t              start = 0 )

AutoIt:
    VectorOfMatchesInfo.push_vector( $other, $count[, $start] ) -> None

VectorOfMatchesInfo VectorOfMatchesInfo::slice( size_t start = 0
                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfMatchesInfo.slice( [$start[, $count]] ) -> retval

void VectorOfMatchesInfo::sort( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfMatchesInfo.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfMatchesInfo::sort_variant( void*  comparator
                                        size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfMatchesInfo.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfMatchesInfo::start()

AutoIt:
    VectorOfMatchesInfo.start() -> retval

void* VectorOfMatchesInfo::end()

AutoIt:
    VectorOfMatchesInfo.end() -> retval

cv::detail::MatchesInfo VectorOfMatchesInfo::get_Item( size_t vIndex )

AutoIt:
    VectorOfMatchesInfo.Item( $vIndex ) -> retval
    VectorOfMatchesInfo( $vIndex ) -> retval

void VectorOfMatchesInfo::put_Item( size_t                  vIndex
                                    cv::detail::MatchesInfo vItem )

AutoIt:
    VectorOfMatchesInfo.Item( $vIndex ) = $vItem

static VectorOfSize VectorOfSize::create()

AutoIt:
    VectorOfSize.create() -> <VectorOfSize object>

static VectorOfSize VectorOfSize::create( size_t size )

AutoIt:
    VectorOfSize.create( $size ) -> <VectorOfSize object>

static VectorOfSize VectorOfSize::create( VectorOfSize other )

AutoIt:
    VectorOfSize.create( $other ) -> <VectorOfSize object>

std::vector<int> VectorOfSize::Keys()

AutoIt:
    VectorOfSize.Keys() -> retval

VectorOfSize VectorOfSize::Items()

AutoIt:
    VectorOfSize.Items() -> retval

void VectorOfSize::push_back( cv::Size value )

AutoIt:
    VectorOfSize.push_back( $value ) -> None

void VectorOfSize::Add( cv::Size value )

AutoIt:
    VectorOfSize.Add( $value ) -> None

void VectorOfSize::Remove( size_t index )

AutoIt:
    VectorOfSize.Remove( $index ) -> None

cv::Size VectorOfSize::at( size_t index )

AutoIt:
    VectorOfSize.at( $index ) -> retval

void VectorOfSize::at( size_t   index
                       cv::Size value )

AutoIt:
    VectorOfSize.at( $index, $value ) -> None

size_t VectorOfSize::size()

AutoIt:
    VectorOfSize.size() -> retval

bool VectorOfSize::empty()

AutoIt:
    VectorOfSize.empty() -> retval

void VectorOfSize::clear()

AutoIt:
    VectorOfSize.clear() -> None

void VectorOfSize::push_vector( VectorOfSize other )

AutoIt:
    VectorOfSize.push_vector( $other ) -> None

void VectorOfSize::push_vector( VectorOfSize other
                                size_t       count
                                size_t       start = 0 )

AutoIt:
    VectorOfSize.push_vector( $other, $count[, $start] ) -> None

VectorOfSize VectorOfSize::slice( size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfSize.slice( [$start[, $count]] ) -> retval

void VectorOfSize::sort( void*  comparator
                         size_t start = 0
                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfSize.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfSize::sort_variant( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfSize.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfSize::start()

AutoIt:
    VectorOfSize.start() -> retval

void* VectorOfSize::end()

AutoIt:
    VectorOfSize.end() -> retval

cv::Size VectorOfSize::get_Item( size_t vIndex )

AutoIt:
    VectorOfSize.Item( $vIndex ) -> retval
    VectorOfSize( $vIndex ) -> retval

void VectorOfSize::put_Item( size_t   vIndex
                             cv::Size vItem )

AutoIt:
    VectorOfSize.Item( $vIndex ) = $vItem

static VectorOfVec2b VectorOfVec2b::create()

AutoIt:
    VectorOfVec2b.create() -> <VectorOfVec2b object>

static VectorOfVec2b VectorOfVec2b::create( size_t size )

AutoIt:
    VectorOfVec2b.create( $size ) -> <VectorOfVec2b object>

static VectorOfVec2b VectorOfVec2b::create( VectorOfVec2b other )

AutoIt:
    VectorOfVec2b.create( $other ) -> <VectorOfVec2b object>

std::vector<int> VectorOfVec2b::Keys()

AutoIt:
    VectorOfVec2b.Keys() -> retval

VectorOfVec2b VectorOfVec2b::Items()

AutoIt:
    VectorOfVec2b.Items() -> retval

void VectorOfVec2b::push_back( cv::Vec2b value )

AutoIt:
    VectorOfVec2b.push_back( $value ) -> None

void VectorOfVec2b::Add( cv::Vec2b value )

AutoIt:
    VectorOfVec2b.Add( $value ) -> None

void VectorOfVec2b::Remove( size_t index )

AutoIt:
    VectorOfVec2b.Remove( $index ) -> None

cv::Vec2b VectorOfVec2b::at( size_t index )

AutoIt:
    VectorOfVec2b.at( $index ) -> retval

void VectorOfVec2b::at( size_t    index
                        cv::Vec2b value )

AutoIt:
    VectorOfVec2b.at( $index, $value ) -> None

size_t VectorOfVec2b::size()

AutoIt:
    VectorOfVec2b.size() -> retval

bool VectorOfVec2b::empty()

AutoIt:
    VectorOfVec2b.empty() -> retval

void VectorOfVec2b::clear()

AutoIt:
    VectorOfVec2b.clear() -> None

void VectorOfVec2b::push_vector( VectorOfVec2b other )

AutoIt:
    VectorOfVec2b.push_vector( $other ) -> None

void VectorOfVec2b::push_vector( VectorOfVec2b other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec2b.push_vector( $other, $count[, $start] ) -> None

VectorOfVec2b VectorOfVec2b::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2b.slice( [$start[, $count]] ) -> retval

void VectorOfVec2b::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2b.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec2b::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2b.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec2b::start()

AutoIt:
    VectorOfVec2b.start() -> retval

void* VectorOfVec2b::end()

AutoIt:
    VectorOfVec2b.end() -> retval

cv::Vec2b VectorOfVec2b::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec2b.Item( $vIndex ) -> retval
    VectorOfVec2b( $vIndex ) -> retval

void VectorOfVec2b::put_Item( size_t    vIndex
                              cv::Vec2b vItem )

AutoIt:
    VectorOfVec2b.Item( $vIndex ) = $vItem

static VectorOfVec3b VectorOfVec3b::create()

AutoIt:
    VectorOfVec3b.create() -> <VectorOfVec3b object>

static VectorOfVec3b VectorOfVec3b::create( size_t size )

AutoIt:
    VectorOfVec3b.create( $size ) -> <VectorOfVec3b object>

static VectorOfVec3b VectorOfVec3b::create( VectorOfVec3b other )

AutoIt:
    VectorOfVec3b.create( $other ) -> <VectorOfVec3b object>

std::vector<int> VectorOfVec3b::Keys()

AutoIt:
    VectorOfVec3b.Keys() -> retval

VectorOfVec3b VectorOfVec3b::Items()

AutoIt:
    VectorOfVec3b.Items() -> retval

void VectorOfVec3b::push_back( cv::Vec3b value )

AutoIt:
    VectorOfVec3b.push_back( $value ) -> None

void VectorOfVec3b::Add( cv::Vec3b value )

AutoIt:
    VectorOfVec3b.Add( $value ) -> None

void VectorOfVec3b::Remove( size_t index )

AutoIt:
    VectorOfVec3b.Remove( $index ) -> None

cv::Vec3b VectorOfVec3b::at( size_t index )

AutoIt:
    VectorOfVec3b.at( $index ) -> retval

void VectorOfVec3b::at( size_t    index
                        cv::Vec3b value )

AutoIt:
    VectorOfVec3b.at( $index, $value ) -> None

size_t VectorOfVec3b::size()

AutoIt:
    VectorOfVec3b.size() -> retval

bool VectorOfVec3b::empty()

AutoIt:
    VectorOfVec3b.empty() -> retval

void VectorOfVec3b::clear()

AutoIt:
    VectorOfVec3b.clear() -> None

void VectorOfVec3b::push_vector( VectorOfVec3b other )

AutoIt:
    VectorOfVec3b.push_vector( $other ) -> None

void VectorOfVec3b::push_vector( VectorOfVec3b other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec3b.push_vector( $other, $count[, $start] ) -> None

VectorOfVec3b VectorOfVec3b::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3b.slice( [$start[, $count]] ) -> retval

void VectorOfVec3b::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3b.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec3b::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3b.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec3b::start()

AutoIt:
    VectorOfVec3b.start() -> retval

void* VectorOfVec3b::end()

AutoIt:
    VectorOfVec3b.end() -> retval

cv::Vec3b VectorOfVec3b::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec3b.Item( $vIndex ) -> retval
    VectorOfVec3b( $vIndex ) -> retval

void VectorOfVec3b::put_Item( size_t    vIndex
                              cv::Vec3b vItem )

AutoIt:
    VectorOfVec3b.Item( $vIndex ) = $vItem

static VectorOfVec4b VectorOfVec4b::create()

AutoIt:
    VectorOfVec4b.create() -> <VectorOfVec4b object>

static VectorOfVec4b VectorOfVec4b::create( size_t size )

AutoIt:
    VectorOfVec4b.create( $size ) -> <VectorOfVec4b object>

static VectorOfVec4b VectorOfVec4b::create( VectorOfVec4b other )

AutoIt:
    VectorOfVec4b.create( $other ) -> <VectorOfVec4b object>

std::vector<int> VectorOfVec4b::Keys()

AutoIt:
    VectorOfVec4b.Keys() -> retval

VectorOfVec4b VectorOfVec4b::Items()

AutoIt:
    VectorOfVec4b.Items() -> retval

void VectorOfVec4b::push_back( cv::Vec4b value )

AutoIt:
    VectorOfVec4b.push_back( $value ) -> None

void VectorOfVec4b::Add( cv::Vec4b value )

AutoIt:
    VectorOfVec4b.Add( $value ) -> None

void VectorOfVec4b::Remove( size_t index )

AutoIt:
    VectorOfVec4b.Remove( $index ) -> None

cv::Vec4b VectorOfVec4b::at( size_t index )

AutoIt:
    VectorOfVec4b.at( $index ) -> retval

void VectorOfVec4b::at( size_t    index
                        cv::Vec4b value )

AutoIt:
    VectorOfVec4b.at( $index, $value ) -> None

size_t VectorOfVec4b::size()

AutoIt:
    VectorOfVec4b.size() -> retval

bool VectorOfVec4b::empty()

AutoIt:
    VectorOfVec4b.empty() -> retval

void VectorOfVec4b::clear()

AutoIt:
    VectorOfVec4b.clear() -> None

void VectorOfVec4b::push_vector( VectorOfVec4b other )

AutoIt:
    VectorOfVec4b.push_vector( $other ) -> None

void VectorOfVec4b::push_vector( VectorOfVec4b other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec4b.push_vector( $other, $count[, $start] ) -> None

VectorOfVec4b VectorOfVec4b::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4b.slice( [$start[, $count]] ) -> retval

void VectorOfVec4b::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4b.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec4b::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4b.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec4b::start()

AutoIt:
    VectorOfVec4b.start() -> retval

void* VectorOfVec4b::end()

AutoIt:
    VectorOfVec4b.end() -> retval

cv::Vec4b VectorOfVec4b::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec4b.Item( $vIndex ) -> retval
    VectorOfVec4b( $vIndex ) -> retval

void VectorOfVec4b::put_Item( size_t    vIndex
                              cv::Vec4b vItem )

AutoIt:
    VectorOfVec4b.Item( $vIndex ) = $vItem

static VectorOfVec2s VectorOfVec2s::create()

AutoIt:
    VectorOfVec2s.create() -> <VectorOfVec2s object>

static VectorOfVec2s VectorOfVec2s::create( size_t size )

AutoIt:
    VectorOfVec2s.create( $size ) -> <VectorOfVec2s object>

static VectorOfVec2s VectorOfVec2s::create( VectorOfVec2s other )

AutoIt:
    VectorOfVec2s.create( $other ) -> <VectorOfVec2s object>

std::vector<int> VectorOfVec2s::Keys()

AutoIt:
    VectorOfVec2s.Keys() -> retval

VectorOfVec2s VectorOfVec2s::Items()

AutoIt:
    VectorOfVec2s.Items() -> retval

void VectorOfVec2s::push_back( cv::Vec2s value )

AutoIt:
    VectorOfVec2s.push_back( $value ) -> None

void VectorOfVec2s::Add( cv::Vec2s value )

AutoIt:
    VectorOfVec2s.Add( $value ) -> None

void VectorOfVec2s::Remove( size_t index )

AutoIt:
    VectorOfVec2s.Remove( $index ) -> None

cv::Vec2s VectorOfVec2s::at( size_t index )

AutoIt:
    VectorOfVec2s.at( $index ) -> retval

void VectorOfVec2s::at( size_t    index
                        cv::Vec2s value )

AutoIt:
    VectorOfVec2s.at( $index, $value ) -> None

size_t VectorOfVec2s::size()

AutoIt:
    VectorOfVec2s.size() -> retval

bool VectorOfVec2s::empty()

AutoIt:
    VectorOfVec2s.empty() -> retval

void VectorOfVec2s::clear()

AutoIt:
    VectorOfVec2s.clear() -> None

void VectorOfVec2s::push_vector( VectorOfVec2s other )

AutoIt:
    VectorOfVec2s.push_vector( $other ) -> None

void VectorOfVec2s::push_vector( VectorOfVec2s other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec2s.push_vector( $other, $count[, $start] ) -> None

VectorOfVec2s VectorOfVec2s::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2s.slice( [$start[, $count]] ) -> retval

void VectorOfVec2s::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2s.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec2s::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2s.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec2s::start()

AutoIt:
    VectorOfVec2s.start() -> retval

void* VectorOfVec2s::end()

AutoIt:
    VectorOfVec2s.end() -> retval

cv::Vec2s VectorOfVec2s::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec2s.Item( $vIndex ) -> retval
    VectorOfVec2s( $vIndex ) -> retval

void VectorOfVec2s::put_Item( size_t    vIndex
                              cv::Vec2s vItem )

AutoIt:
    VectorOfVec2s.Item( $vIndex ) = $vItem

static VectorOfVec3s VectorOfVec3s::create()

AutoIt:
    VectorOfVec3s.create() -> <VectorOfVec3s object>

static VectorOfVec3s VectorOfVec3s::create( size_t size )

AutoIt:
    VectorOfVec3s.create( $size ) -> <VectorOfVec3s object>

static VectorOfVec3s VectorOfVec3s::create( VectorOfVec3s other )

AutoIt:
    VectorOfVec3s.create( $other ) -> <VectorOfVec3s object>

std::vector<int> VectorOfVec3s::Keys()

AutoIt:
    VectorOfVec3s.Keys() -> retval

VectorOfVec3s VectorOfVec3s::Items()

AutoIt:
    VectorOfVec3s.Items() -> retval

void VectorOfVec3s::push_back( cv::Vec3s value )

AutoIt:
    VectorOfVec3s.push_back( $value ) -> None

void VectorOfVec3s::Add( cv::Vec3s value )

AutoIt:
    VectorOfVec3s.Add( $value ) -> None

void VectorOfVec3s::Remove( size_t index )

AutoIt:
    VectorOfVec3s.Remove( $index ) -> None

cv::Vec3s VectorOfVec3s::at( size_t index )

AutoIt:
    VectorOfVec3s.at( $index ) -> retval

void VectorOfVec3s::at( size_t    index
                        cv::Vec3s value )

AutoIt:
    VectorOfVec3s.at( $index, $value ) -> None

size_t VectorOfVec3s::size()

AutoIt:
    VectorOfVec3s.size() -> retval

bool VectorOfVec3s::empty()

AutoIt:
    VectorOfVec3s.empty() -> retval

void VectorOfVec3s::clear()

AutoIt:
    VectorOfVec3s.clear() -> None

void VectorOfVec3s::push_vector( VectorOfVec3s other )

AutoIt:
    VectorOfVec3s.push_vector( $other ) -> None

void VectorOfVec3s::push_vector( VectorOfVec3s other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec3s.push_vector( $other, $count[, $start] ) -> None

VectorOfVec3s VectorOfVec3s::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3s.slice( [$start[, $count]] ) -> retval

void VectorOfVec3s::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3s.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec3s::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3s.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec3s::start()

AutoIt:
    VectorOfVec3s.start() -> retval

void* VectorOfVec3s::end()

AutoIt:
    VectorOfVec3s.end() -> retval

cv::Vec3s VectorOfVec3s::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec3s.Item( $vIndex ) -> retval
    VectorOfVec3s( $vIndex ) -> retval

void VectorOfVec3s::put_Item( size_t    vIndex
                              cv::Vec3s vItem )

AutoIt:
    VectorOfVec3s.Item( $vIndex ) = $vItem

static VectorOfVec4s VectorOfVec4s::create()

AutoIt:
    VectorOfVec4s.create() -> <VectorOfVec4s object>

static VectorOfVec4s VectorOfVec4s::create( size_t size )

AutoIt:
    VectorOfVec4s.create( $size ) -> <VectorOfVec4s object>

static VectorOfVec4s VectorOfVec4s::create( VectorOfVec4s other )

AutoIt:
    VectorOfVec4s.create( $other ) -> <VectorOfVec4s object>

std::vector<int> VectorOfVec4s::Keys()

AutoIt:
    VectorOfVec4s.Keys() -> retval

VectorOfVec4s VectorOfVec4s::Items()

AutoIt:
    VectorOfVec4s.Items() -> retval

void VectorOfVec4s::push_back( cv::Vec4s value )

AutoIt:
    VectorOfVec4s.push_back( $value ) -> None

void VectorOfVec4s::Add( cv::Vec4s value )

AutoIt:
    VectorOfVec4s.Add( $value ) -> None

void VectorOfVec4s::Remove( size_t index )

AutoIt:
    VectorOfVec4s.Remove( $index ) -> None

cv::Vec4s VectorOfVec4s::at( size_t index )

AutoIt:
    VectorOfVec4s.at( $index ) -> retval

void VectorOfVec4s::at( size_t    index
                        cv::Vec4s value )

AutoIt:
    VectorOfVec4s.at( $index, $value ) -> None

size_t VectorOfVec4s::size()

AutoIt:
    VectorOfVec4s.size() -> retval

bool VectorOfVec4s::empty()

AutoIt:
    VectorOfVec4s.empty() -> retval

void VectorOfVec4s::clear()

AutoIt:
    VectorOfVec4s.clear() -> None

void VectorOfVec4s::push_vector( VectorOfVec4s other )

AutoIt:
    VectorOfVec4s.push_vector( $other ) -> None

void VectorOfVec4s::push_vector( VectorOfVec4s other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec4s.push_vector( $other, $count[, $start] ) -> None

VectorOfVec4s VectorOfVec4s::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4s.slice( [$start[, $count]] ) -> retval

void VectorOfVec4s::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4s.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec4s::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4s.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec4s::start()

AutoIt:
    VectorOfVec4s.start() -> retval

void* VectorOfVec4s::end()

AutoIt:
    VectorOfVec4s.end() -> retval

cv::Vec4s VectorOfVec4s::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec4s.Item( $vIndex ) -> retval
    VectorOfVec4s( $vIndex ) -> retval

void VectorOfVec4s::put_Item( size_t    vIndex
                              cv::Vec4s vItem )

AutoIt:
    VectorOfVec4s.Item( $vIndex ) = $vItem

static VectorOfVec2w VectorOfVec2w::create()

AutoIt:
    VectorOfVec2w.create() -> <VectorOfVec2w object>

static VectorOfVec2w VectorOfVec2w::create( size_t size )

AutoIt:
    VectorOfVec2w.create( $size ) -> <VectorOfVec2w object>

static VectorOfVec2w VectorOfVec2w::create( VectorOfVec2w other )

AutoIt:
    VectorOfVec2w.create( $other ) -> <VectorOfVec2w object>

std::vector<int> VectorOfVec2w::Keys()

AutoIt:
    VectorOfVec2w.Keys() -> retval

VectorOfVec2w VectorOfVec2w::Items()

AutoIt:
    VectorOfVec2w.Items() -> retval

void VectorOfVec2w::push_back( cv::Vec2w value )

AutoIt:
    VectorOfVec2w.push_back( $value ) -> None

void VectorOfVec2w::Add( cv::Vec2w value )

AutoIt:
    VectorOfVec2w.Add( $value ) -> None

void VectorOfVec2w::Remove( size_t index )

AutoIt:
    VectorOfVec2w.Remove( $index ) -> None

cv::Vec2w VectorOfVec2w::at( size_t index )

AutoIt:
    VectorOfVec2w.at( $index ) -> retval

void VectorOfVec2w::at( size_t    index
                        cv::Vec2w value )

AutoIt:
    VectorOfVec2w.at( $index, $value ) -> None

size_t VectorOfVec2w::size()

AutoIt:
    VectorOfVec2w.size() -> retval

bool VectorOfVec2w::empty()

AutoIt:
    VectorOfVec2w.empty() -> retval

void VectorOfVec2w::clear()

AutoIt:
    VectorOfVec2w.clear() -> None

void VectorOfVec2w::push_vector( VectorOfVec2w other )

AutoIt:
    VectorOfVec2w.push_vector( $other ) -> None

void VectorOfVec2w::push_vector( VectorOfVec2w other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec2w.push_vector( $other, $count[, $start] ) -> None

VectorOfVec2w VectorOfVec2w::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2w.slice( [$start[, $count]] ) -> retval

void VectorOfVec2w::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2w.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec2w::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2w.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec2w::start()

AutoIt:
    VectorOfVec2w.start() -> retval

void* VectorOfVec2w::end()

AutoIt:
    VectorOfVec2w.end() -> retval

cv::Vec2w VectorOfVec2w::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec2w.Item( $vIndex ) -> retval
    VectorOfVec2w( $vIndex ) -> retval

void VectorOfVec2w::put_Item( size_t    vIndex
                              cv::Vec2w vItem )

AutoIt:
    VectorOfVec2w.Item( $vIndex ) = $vItem

static VectorOfVec3w VectorOfVec3w::create()

AutoIt:
    VectorOfVec3w.create() -> <VectorOfVec3w object>

static VectorOfVec3w VectorOfVec3w::create( size_t size )

AutoIt:
    VectorOfVec3w.create( $size ) -> <VectorOfVec3w object>

static VectorOfVec3w VectorOfVec3w::create( VectorOfVec3w other )

AutoIt:
    VectorOfVec3w.create( $other ) -> <VectorOfVec3w object>

std::vector<int> VectorOfVec3w::Keys()

AutoIt:
    VectorOfVec3w.Keys() -> retval

VectorOfVec3w VectorOfVec3w::Items()

AutoIt:
    VectorOfVec3w.Items() -> retval

void VectorOfVec3w::push_back( cv::Vec3w value )

AutoIt:
    VectorOfVec3w.push_back( $value ) -> None

void VectorOfVec3w::Add( cv::Vec3w value )

AutoIt:
    VectorOfVec3w.Add( $value ) -> None

void VectorOfVec3w::Remove( size_t index )

AutoIt:
    VectorOfVec3w.Remove( $index ) -> None

cv::Vec3w VectorOfVec3w::at( size_t index )

AutoIt:
    VectorOfVec3w.at( $index ) -> retval

void VectorOfVec3w::at( size_t    index
                        cv::Vec3w value )

AutoIt:
    VectorOfVec3w.at( $index, $value ) -> None

size_t VectorOfVec3w::size()

AutoIt:
    VectorOfVec3w.size() -> retval

bool VectorOfVec3w::empty()

AutoIt:
    VectorOfVec3w.empty() -> retval

void VectorOfVec3w::clear()

AutoIt:
    VectorOfVec3w.clear() -> None

void VectorOfVec3w::push_vector( VectorOfVec3w other )

AutoIt:
    VectorOfVec3w.push_vector( $other ) -> None

void VectorOfVec3w::push_vector( VectorOfVec3w other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec3w.push_vector( $other, $count[, $start] ) -> None

VectorOfVec3w VectorOfVec3w::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3w.slice( [$start[, $count]] ) -> retval

void VectorOfVec3w::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3w.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec3w::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3w.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec3w::start()

AutoIt:
    VectorOfVec3w.start() -> retval

void* VectorOfVec3w::end()

AutoIt:
    VectorOfVec3w.end() -> retval

cv::Vec3w VectorOfVec3w::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec3w.Item( $vIndex ) -> retval
    VectorOfVec3w( $vIndex ) -> retval

void VectorOfVec3w::put_Item( size_t    vIndex
                              cv::Vec3w vItem )

AutoIt:
    VectorOfVec3w.Item( $vIndex ) = $vItem

static VectorOfVec4w VectorOfVec4w::create()

AutoIt:
    VectorOfVec4w.create() -> <VectorOfVec4w object>

static VectorOfVec4w VectorOfVec4w::create( size_t size )

AutoIt:
    VectorOfVec4w.create( $size ) -> <VectorOfVec4w object>

static VectorOfVec4w VectorOfVec4w::create( VectorOfVec4w other )

AutoIt:
    VectorOfVec4w.create( $other ) -> <VectorOfVec4w object>

std::vector<int> VectorOfVec4w::Keys()

AutoIt:
    VectorOfVec4w.Keys() -> retval

VectorOfVec4w VectorOfVec4w::Items()

AutoIt:
    VectorOfVec4w.Items() -> retval

void VectorOfVec4w::push_back( cv::Vec4w value )

AutoIt:
    VectorOfVec4w.push_back( $value ) -> None

void VectorOfVec4w::Add( cv::Vec4w value )

AutoIt:
    VectorOfVec4w.Add( $value ) -> None

void VectorOfVec4w::Remove( size_t index )

AutoIt:
    VectorOfVec4w.Remove( $index ) -> None

cv::Vec4w VectorOfVec4w::at( size_t index )

AutoIt:
    VectorOfVec4w.at( $index ) -> retval

void VectorOfVec4w::at( size_t    index
                        cv::Vec4w value )

AutoIt:
    VectorOfVec4w.at( $index, $value ) -> None

size_t VectorOfVec4w::size()

AutoIt:
    VectorOfVec4w.size() -> retval

bool VectorOfVec4w::empty()

AutoIt:
    VectorOfVec4w.empty() -> retval

void VectorOfVec4w::clear()

AutoIt:
    VectorOfVec4w.clear() -> None

void VectorOfVec4w::push_vector( VectorOfVec4w other )

AutoIt:
    VectorOfVec4w.push_vector( $other ) -> None

void VectorOfVec4w::push_vector( VectorOfVec4w other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec4w.push_vector( $other, $count[, $start] ) -> None

VectorOfVec4w VectorOfVec4w::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4w.slice( [$start[, $count]] ) -> retval

void VectorOfVec4w::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4w.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec4w::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4w.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec4w::start()

AutoIt:
    VectorOfVec4w.start() -> retval

void* VectorOfVec4w::end()

AutoIt:
    VectorOfVec4w.end() -> retval

cv::Vec4w VectorOfVec4w::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec4w.Item( $vIndex ) -> retval
    VectorOfVec4w( $vIndex ) -> retval

void VectorOfVec4w::put_Item( size_t    vIndex
                              cv::Vec4w vItem )

AutoIt:
    VectorOfVec4w.Item( $vIndex ) = $vItem

static VectorOfVec2i VectorOfVec2i::create()

AutoIt:
    VectorOfVec2i.create() -> <VectorOfVec2i object>

static VectorOfVec2i VectorOfVec2i::create( size_t size )

AutoIt:
    VectorOfVec2i.create( $size ) -> <VectorOfVec2i object>

static VectorOfVec2i VectorOfVec2i::create( VectorOfVec2i other )

AutoIt:
    VectorOfVec2i.create( $other ) -> <VectorOfVec2i object>

std::vector<int> VectorOfVec2i::Keys()

AutoIt:
    VectorOfVec2i.Keys() -> retval

VectorOfVec2i VectorOfVec2i::Items()

AutoIt:
    VectorOfVec2i.Items() -> retval

void VectorOfVec2i::push_back( cv::Vec2i value )

AutoIt:
    VectorOfVec2i.push_back( $value ) -> None

void VectorOfVec2i::Add( cv::Vec2i value )

AutoIt:
    VectorOfVec2i.Add( $value ) -> None

void VectorOfVec2i::Remove( size_t index )

AutoIt:
    VectorOfVec2i.Remove( $index ) -> None

cv::Vec2i VectorOfVec2i::at( size_t index )

AutoIt:
    VectorOfVec2i.at( $index ) -> retval

void VectorOfVec2i::at( size_t    index
                        cv::Vec2i value )

AutoIt:
    VectorOfVec2i.at( $index, $value ) -> None

size_t VectorOfVec2i::size()

AutoIt:
    VectorOfVec2i.size() -> retval

bool VectorOfVec2i::empty()

AutoIt:
    VectorOfVec2i.empty() -> retval

void VectorOfVec2i::clear()

AutoIt:
    VectorOfVec2i.clear() -> None

void VectorOfVec2i::push_vector( VectorOfVec2i other )

AutoIt:
    VectorOfVec2i.push_vector( $other ) -> None

void VectorOfVec2i::push_vector( VectorOfVec2i other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec2i.push_vector( $other, $count[, $start] ) -> None

VectorOfVec2i VectorOfVec2i::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2i.slice( [$start[, $count]] ) -> retval

void VectorOfVec2i::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2i.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec2i::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2i.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec2i::start()

AutoIt:
    VectorOfVec2i.start() -> retval

void* VectorOfVec2i::end()

AutoIt:
    VectorOfVec2i.end() -> retval

cv::Vec2i VectorOfVec2i::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec2i.Item( $vIndex ) -> retval
    VectorOfVec2i( $vIndex ) -> retval

void VectorOfVec2i::put_Item( size_t    vIndex
                              cv::Vec2i vItem )

AutoIt:
    VectorOfVec2i.Item( $vIndex ) = $vItem

static VectorOfVec3i VectorOfVec3i::create()

AutoIt:
    VectorOfVec3i.create() -> <VectorOfVec3i object>

static VectorOfVec3i VectorOfVec3i::create( size_t size )

AutoIt:
    VectorOfVec3i.create( $size ) -> <VectorOfVec3i object>

static VectorOfVec3i VectorOfVec3i::create( VectorOfVec3i other )

AutoIt:
    VectorOfVec3i.create( $other ) -> <VectorOfVec3i object>

std::vector<int> VectorOfVec3i::Keys()

AutoIt:
    VectorOfVec3i.Keys() -> retval

VectorOfVec3i VectorOfVec3i::Items()

AutoIt:
    VectorOfVec3i.Items() -> retval

void VectorOfVec3i::push_back( cv::Vec3i value )

AutoIt:
    VectorOfVec3i.push_back( $value ) -> None

void VectorOfVec3i::Add( cv::Vec3i value )

AutoIt:
    VectorOfVec3i.Add( $value ) -> None

void VectorOfVec3i::Remove( size_t index )

AutoIt:
    VectorOfVec3i.Remove( $index ) -> None

cv::Vec3i VectorOfVec3i::at( size_t index )

AutoIt:
    VectorOfVec3i.at( $index ) -> retval

void VectorOfVec3i::at( size_t    index
                        cv::Vec3i value )

AutoIt:
    VectorOfVec3i.at( $index, $value ) -> None

size_t VectorOfVec3i::size()

AutoIt:
    VectorOfVec3i.size() -> retval

bool VectorOfVec3i::empty()

AutoIt:
    VectorOfVec3i.empty() -> retval

void VectorOfVec3i::clear()

AutoIt:
    VectorOfVec3i.clear() -> None

void VectorOfVec3i::push_vector( VectorOfVec3i other )

AutoIt:
    VectorOfVec3i.push_vector( $other ) -> None

void VectorOfVec3i::push_vector( VectorOfVec3i other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec3i.push_vector( $other, $count[, $start] ) -> None

VectorOfVec3i VectorOfVec3i::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3i.slice( [$start[, $count]] ) -> retval

void VectorOfVec3i::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3i.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec3i::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3i.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec3i::start()

AutoIt:
    VectorOfVec3i.start() -> retval

void* VectorOfVec3i::end()

AutoIt:
    VectorOfVec3i.end() -> retval

cv::Vec3i VectorOfVec3i::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec3i.Item( $vIndex ) -> retval
    VectorOfVec3i( $vIndex ) -> retval

void VectorOfVec3i::put_Item( size_t    vIndex
                              cv::Vec3i vItem )

AutoIt:
    VectorOfVec3i.Item( $vIndex ) = $vItem

static VectorOfVec4i VectorOfVec4i::create()

AutoIt:
    VectorOfVec4i.create() -> <VectorOfVec4i object>

static VectorOfVec4i VectorOfVec4i::create( size_t size )

AutoIt:
    VectorOfVec4i.create( $size ) -> <VectorOfVec4i object>

static VectorOfVec4i VectorOfVec4i::create( VectorOfVec4i other )

AutoIt:
    VectorOfVec4i.create( $other ) -> <VectorOfVec4i object>

std::vector<int> VectorOfVec4i::Keys()

AutoIt:
    VectorOfVec4i.Keys() -> retval

VectorOfVec4i VectorOfVec4i::Items()

AutoIt:
    VectorOfVec4i.Items() -> retval

void VectorOfVec4i::push_back( cv::Vec4i value )

AutoIt:
    VectorOfVec4i.push_back( $value ) -> None

void VectorOfVec4i::Add( cv::Vec4i value )

AutoIt:
    VectorOfVec4i.Add( $value ) -> None

void VectorOfVec4i::Remove( size_t index )

AutoIt:
    VectorOfVec4i.Remove( $index ) -> None

cv::Vec4i VectorOfVec4i::at( size_t index )

AutoIt:
    VectorOfVec4i.at( $index ) -> retval

void VectorOfVec4i::at( size_t    index
                        cv::Vec4i value )

AutoIt:
    VectorOfVec4i.at( $index, $value ) -> None

size_t VectorOfVec4i::size()

AutoIt:
    VectorOfVec4i.size() -> retval

bool VectorOfVec4i::empty()

AutoIt:
    VectorOfVec4i.empty() -> retval

void VectorOfVec4i::clear()

AutoIt:
    VectorOfVec4i.clear() -> None

void VectorOfVec4i::push_vector( VectorOfVec4i other )

AutoIt:
    VectorOfVec4i.push_vector( $other ) -> None

void VectorOfVec4i::push_vector( VectorOfVec4i other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec4i.push_vector( $other, $count[, $start] ) -> None

VectorOfVec4i VectorOfVec4i::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4i.slice( [$start[, $count]] ) -> retval

void VectorOfVec4i::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4i.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec4i::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4i.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec4i::start()

AutoIt:
    VectorOfVec4i.start() -> retval

void* VectorOfVec4i::end()

AutoIt:
    VectorOfVec4i.end() -> retval

cv::Vec4i VectorOfVec4i::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec4i.Item( $vIndex ) -> retval
    VectorOfVec4i( $vIndex ) -> retval

void VectorOfVec4i::put_Item( size_t    vIndex
                              cv::Vec4i vItem )

AutoIt:
    VectorOfVec4i.Item( $vIndex ) = $vItem

static VectorOfVec6i VectorOfVec6i::create()

AutoIt:
    VectorOfVec6i.create() -> <VectorOfVec6i object>

static VectorOfVec6i VectorOfVec6i::create( size_t size )

AutoIt:
    VectorOfVec6i.create( $size ) -> <VectorOfVec6i object>

static VectorOfVec6i VectorOfVec6i::create( VectorOfVec6i other )

AutoIt:
    VectorOfVec6i.create( $other ) -> <VectorOfVec6i object>

std::vector<int> VectorOfVec6i::Keys()

AutoIt:
    VectorOfVec6i.Keys() -> retval

VectorOfVec6i VectorOfVec6i::Items()

AutoIt:
    VectorOfVec6i.Items() -> retval

void VectorOfVec6i::push_back( cv::Vec6i value )

AutoIt:
    VectorOfVec6i.push_back( $value ) -> None

void VectorOfVec6i::Add( cv::Vec6i value )

AutoIt:
    VectorOfVec6i.Add( $value ) -> None

void VectorOfVec6i::Remove( size_t index )

AutoIt:
    VectorOfVec6i.Remove( $index ) -> None

cv::Vec6i VectorOfVec6i::at( size_t index )

AutoIt:
    VectorOfVec6i.at( $index ) -> retval

void VectorOfVec6i::at( size_t    index
                        cv::Vec6i value )

AutoIt:
    VectorOfVec6i.at( $index, $value ) -> None

size_t VectorOfVec6i::size()

AutoIt:
    VectorOfVec6i.size() -> retval

bool VectorOfVec6i::empty()

AutoIt:
    VectorOfVec6i.empty() -> retval

void VectorOfVec6i::clear()

AutoIt:
    VectorOfVec6i.clear() -> None

void VectorOfVec6i::push_vector( VectorOfVec6i other )

AutoIt:
    VectorOfVec6i.push_vector( $other ) -> None

void VectorOfVec6i::push_vector( VectorOfVec6i other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec6i.push_vector( $other, $count[, $start] ) -> None

VectorOfVec6i VectorOfVec6i::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6i.slice( [$start[, $count]] ) -> retval

void VectorOfVec6i::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6i.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec6i::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6i.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec6i::start()

AutoIt:
    VectorOfVec6i.start() -> retval

void* VectorOfVec6i::end()

AutoIt:
    VectorOfVec6i.end() -> retval

cv::Vec6i VectorOfVec6i::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec6i.Item( $vIndex ) -> retval
    VectorOfVec6i( $vIndex ) -> retval

void VectorOfVec6i::put_Item( size_t    vIndex
                              cv::Vec6i vItem )

AutoIt:
    VectorOfVec6i.Item( $vIndex ) = $vItem

static VectorOfVec8i VectorOfVec8i::create()

AutoIt:
    VectorOfVec8i.create() -> <VectorOfVec8i object>

static VectorOfVec8i VectorOfVec8i::create( size_t size )

AutoIt:
    VectorOfVec8i.create( $size ) -> <VectorOfVec8i object>

static VectorOfVec8i VectorOfVec8i::create( VectorOfVec8i other )

AutoIt:
    VectorOfVec8i.create( $other ) -> <VectorOfVec8i object>

std::vector<int> VectorOfVec8i::Keys()

AutoIt:
    VectorOfVec8i.Keys() -> retval

VectorOfVec8i VectorOfVec8i::Items()

AutoIt:
    VectorOfVec8i.Items() -> retval

void VectorOfVec8i::push_back( cv::Vec8i value )

AutoIt:
    VectorOfVec8i.push_back( $value ) -> None

void VectorOfVec8i::Add( cv::Vec8i value )

AutoIt:
    VectorOfVec8i.Add( $value ) -> None

void VectorOfVec8i::Remove( size_t index )

AutoIt:
    VectorOfVec8i.Remove( $index ) -> None

cv::Vec8i VectorOfVec8i::at( size_t index )

AutoIt:
    VectorOfVec8i.at( $index ) -> retval

void VectorOfVec8i::at( size_t    index
                        cv::Vec8i value )

AutoIt:
    VectorOfVec8i.at( $index, $value ) -> None

size_t VectorOfVec8i::size()

AutoIt:
    VectorOfVec8i.size() -> retval

bool VectorOfVec8i::empty()

AutoIt:
    VectorOfVec8i.empty() -> retval

void VectorOfVec8i::clear()

AutoIt:
    VectorOfVec8i.clear() -> None

void VectorOfVec8i::push_vector( VectorOfVec8i other )

AutoIt:
    VectorOfVec8i.push_vector( $other ) -> None

void VectorOfVec8i::push_vector( VectorOfVec8i other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec8i.push_vector( $other, $count[, $start] ) -> None

VectorOfVec8i VectorOfVec8i::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec8i.slice( [$start[, $count]] ) -> retval

void VectorOfVec8i::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec8i.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec8i::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec8i.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec8i::start()

AutoIt:
    VectorOfVec8i.start() -> retval

void* VectorOfVec8i::end()

AutoIt:
    VectorOfVec8i.end() -> retval

cv::Vec8i VectorOfVec8i::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec8i.Item( $vIndex ) -> retval
    VectorOfVec8i( $vIndex ) -> retval

void VectorOfVec8i::put_Item( size_t    vIndex
                              cv::Vec8i vItem )

AutoIt:
    VectorOfVec8i.Item( $vIndex ) = $vItem

static VectorOfVec2f VectorOfVec2f::create()

AutoIt:
    VectorOfVec2f.create() -> <VectorOfVec2f object>

static VectorOfVec2f VectorOfVec2f::create( size_t size )

AutoIt:
    VectorOfVec2f.create( $size ) -> <VectorOfVec2f object>

static VectorOfVec2f VectorOfVec2f::create( VectorOfVec2f other )

AutoIt:
    VectorOfVec2f.create( $other ) -> <VectorOfVec2f object>

std::vector<int> VectorOfVec2f::Keys()

AutoIt:
    VectorOfVec2f.Keys() -> retval

VectorOfVec2f VectorOfVec2f::Items()

AutoIt:
    VectorOfVec2f.Items() -> retval

void VectorOfVec2f::push_back( cv::Vec2f value )

AutoIt:
    VectorOfVec2f.push_back( $value ) -> None

void VectorOfVec2f::Add( cv::Vec2f value )

AutoIt:
    VectorOfVec2f.Add( $value ) -> None

void VectorOfVec2f::Remove( size_t index )

AutoIt:
    VectorOfVec2f.Remove( $index ) -> None

cv::Vec2f VectorOfVec2f::at( size_t index )

AutoIt:
    VectorOfVec2f.at( $index ) -> retval

void VectorOfVec2f::at( size_t    index
                        cv::Vec2f value )

AutoIt:
    VectorOfVec2f.at( $index, $value ) -> None

size_t VectorOfVec2f::size()

AutoIt:
    VectorOfVec2f.size() -> retval

bool VectorOfVec2f::empty()

AutoIt:
    VectorOfVec2f.empty() -> retval

void VectorOfVec2f::clear()

AutoIt:
    VectorOfVec2f.clear() -> None

void VectorOfVec2f::push_vector( VectorOfVec2f other )

AutoIt:
    VectorOfVec2f.push_vector( $other ) -> None

void VectorOfVec2f::push_vector( VectorOfVec2f other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec2f.push_vector( $other, $count[, $start] ) -> None

VectorOfVec2f VectorOfVec2f::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2f.slice( [$start[, $count]] ) -> retval

void VectorOfVec2f::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2f.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec2f::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2f.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec2f::start()

AutoIt:
    VectorOfVec2f.start() -> retval

void* VectorOfVec2f::end()

AutoIt:
    VectorOfVec2f.end() -> retval

cv::Vec2f VectorOfVec2f::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec2f.Item( $vIndex ) -> retval
    VectorOfVec2f( $vIndex ) -> retval

void VectorOfVec2f::put_Item( size_t    vIndex
                              cv::Vec2f vItem )

AutoIt:
    VectorOfVec2f.Item( $vIndex ) = $vItem

static VectorOfVec3f VectorOfVec3f::create()

AutoIt:
    VectorOfVec3f.create() -> <VectorOfVec3f object>

static VectorOfVec3f VectorOfVec3f::create( size_t size )

AutoIt:
    VectorOfVec3f.create( $size ) -> <VectorOfVec3f object>

static VectorOfVec3f VectorOfVec3f::create( VectorOfVec3f other )

AutoIt:
    VectorOfVec3f.create( $other ) -> <VectorOfVec3f object>

std::vector<int> VectorOfVec3f::Keys()

AutoIt:
    VectorOfVec3f.Keys() -> retval

VectorOfVec3f VectorOfVec3f::Items()

AutoIt:
    VectorOfVec3f.Items() -> retval

void VectorOfVec3f::push_back( cv::Vec3f value )

AutoIt:
    VectorOfVec3f.push_back( $value ) -> None

void VectorOfVec3f::Add( cv::Vec3f value )

AutoIt:
    VectorOfVec3f.Add( $value ) -> None

void VectorOfVec3f::Remove( size_t index )

AutoIt:
    VectorOfVec3f.Remove( $index ) -> None

cv::Vec3f VectorOfVec3f::at( size_t index )

AutoIt:
    VectorOfVec3f.at( $index ) -> retval

void VectorOfVec3f::at( size_t    index
                        cv::Vec3f value )

AutoIt:
    VectorOfVec3f.at( $index, $value ) -> None

size_t VectorOfVec3f::size()

AutoIt:
    VectorOfVec3f.size() -> retval

bool VectorOfVec3f::empty()

AutoIt:
    VectorOfVec3f.empty() -> retval

void VectorOfVec3f::clear()

AutoIt:
    VectorOfVec3f.clear() -> None

void VectorOfVec3f::push_vector( VectorOfVec3f other )

AutoIt:
    VectorOfVec3f.push_vector( $other ) -> None

void VectorOfVec3f::push_vector( VectorOfVec3f other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec3f.push_vector( $other, $count[, $start] ) -> None

VectorOfVec3f VectorOfVec3f::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3f.slice( [$start[, $count]] ) -> retval

void VectorOfVec3f::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3f.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec3f::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3f.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec3f::start()

AutoIt:
    VectorOfVec3f.start() -> retval

void* VectorOfVec3f::end()

AutoIt:
    VectorOfVec3f.end() -> retval

cv::Vec3f VectorOfVec3f::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec3f.Item( $vIndex ) -> retval
    VectorOfVec3f( $vIndex ) -> retval

void VectorOfVec3f::put_Item( size_t    vIndex
                              cv::Vec3f vItem )

AutoIt:
    VectorOfVec3f.Item( $vIndex ) = $vItem

static VectorOfVec4f VectorOfVec4f::create()

AutoIt:
    VectorOfVec4f.create() -> <VectorOfVec4f object>

static VectorOfVec4f VectorOfVec4f::create( size_t size )

AutoIt:
    VectorOfVec4f.create( $size ) -> <VectorOfVec4f object>

static VectorOfVec4f VectorOfVec4f::create( VectorOfVec4f other )

AutoIt:
    VectorOfVec4f.create( $other ) -> <VectorOfVec4f object>

std::vector<int> VectorOfVec4f::Keys()

AutoIt:
    VectorOfVec4f.Keys() -> retval

VectorOfVec4f VectorOfVec4f::Items()

AutoIt:
    VectorOfVec4f.Items() -> retval

void VectorOfVec4f::push_back( cv::Vec4f value )

AutoIt:
    VectorOfVec4f.push_back( $value ) -> None

void VectorOfVec4f::Add( cv::Vec4f value )

AutoIt:
    VectorOfVec4f.Add( $value ) -> None

void VectorOfVec4f::Remove( size_t index )

AutoIt:
    VectorOfVec4f.Remove( $index ) -> None

cv::Vec4f VectorOfVec4f::at( size_t index )

AutoIt:
    VectorOfVec4f.at( $index ) -> retval

void VectorOfVec4f::at( size_t    index
                        cv::Vec4f value )

AutoIt:
    VectorOfVec4f.at( $index, $value ) -> None

size_t VectorOfVec4f::size()

AutoIt:
    VectorOfVec4f.size() -> retval

bool VectorOfVec4f::empty()

AutoIt:
    VectorOfVec4f.empty() -> retval

void VectorOfVec4f::clear()

AutoIt:
    VectorOfVec4f.clear() -> None

void VectorOfVec4f::push_vector( VectorOfVec4f other )

AutoIt:
    VectorOfVec4f.push_vector( $other ) -> None

void VectorOfVec4f::push_vector( VectorOfVec4f other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec4f.push_vector( $other, $count[, $start] ) -> None

VectorOfVec4f VectorOfVec4f::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4f.slice( [$start[, $count]] ) -> retval

void VectorOfVec4f::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4f.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec4f::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4f.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec4f::start()

AutoIt:
    VectorOfVec4f.start() -> retval

void* VectorOfVec4f::end()

AutoIt:
    VectorOfVec4f.end() -> retval

cv::Vec4f VectorOfVec4f::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec4f.Item( $vIndex ) -> retval
    VectorOfVec4f( $vIndex ) -> retval

void VectorOfVec4f::put_Item( size_t    vIndex
                              cv::Vec4f vItem )

AutoIt:
    VectorOfVec4f.Item( $vIndex ) = $vItem

static VectorOfVec6f VectorOfVec6f::create()

AutoIt:
    VectorOfVec6f.create() -> <VectorOfVec6f object>

static VectorOfVec6f VectorOfVec6f::create( size_t size )

AutoIt:
    VectorOfVec6f.create( $size ) -> <VectorOfVec6f object>

static VectorOfVec6f VectorOfVec6f::create( VectorOfVec6f other )

AutoIt:
    VectorOfVec6f.create( $other ) -> <VectorOfVec6f object>

std::vector<int> VectorOfVec6f::Keys()

AutoIt:
    VectorOfVec6f.Keys() -> retval

VectorOfVec6f VectorOfVec6f::Items()

AutoIt:
    VectorOfVec6f.Items() -> retval

void VectorOfVec6f::push_back( cv::Vec6f value )

AutoIt:
    VectorOfVec6f.push_back( $value ) -> None

void VectorOfVec6f::Add( cv::Vec6f value )

AutoIt:
    VectorOfVec6f.Add( $value ) -> None

void VectorOfVec6f::Remove( size_t index )

AutoIt:
    VectorOfVec6f.Remove( $index ) -> None

cv::Vec6f VectorOfVec6f::at( size_t index )

AutoIt:
    VectorOfVec6f.at( $index ) -> retval

void VectorOfVec6f::at( size_t    index
                        cv::Vec6f value )

AutoIt:
    VectorOfVec6f.at( $index, $value ) -> None

size_t VectorOfVec6f::size()

AutoIt:
    VectorOfVec6f.size() -> retval

bool VectorOfVec6f::empty()

AutoIt:
    VectorOfVec6f.empty() -> retval

void VectorOfVec6f::clear()

AutoIt:
    VectorOfVec6f.clear() -> None

void VectorOfVec6f::push_vector( VectorOfVec6f other )

AutoIt:
    VectorOfVec6f.push_vector( $other ) -> None

void VectorOfVec6f::push_vector( VectorOfVec6f other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec6f.push_vector( $other, $count[, $start] ) -> None

VectorOfVec6f VectorOfVec6f::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6f.slice( [$start[, $count]] ) -> retval

void VectorOfVec6f::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6f.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec6f::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6f.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec6f::start()

AutoIt:
    VectorOfVec6f.start() -> retval

void* VectorOfVec6f::end()

AutoIt:
    VectorOfVec6f.end() -> retval

cv::Vec6f VectorOfVec6f::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec6f.Item( $vIndex ) -> retval
    VectorOfVec6f( $vIndex ) -> retval

void VectorOfVec6f::put_Item( size_t    vIndex
                              cv::Vec6f vItem )

AutoIt:
    VectorOfVec6f.Item( $vIndex ) = $vItem

static VectorOfVec2d VectorOfVec2d::create()

AutoIt:
    VectorOfVec2d.create() -> <VectorOfVec2d object>

static VectorOfVec2d VectorOfVec2d::create( size_t size )

AutoIt:
    VectorOfVec2d.create( $size ) -> <VectorOfVec2d object>

static VectorOfVec2d VectorOfVec2d::create( VectorOfVec2d other )

AutoIt:
    VectorOfVec2d.create( $other ) -> <VectorOfVec2d object>

std::vector<int> VectorOfVec2d::Keys()

AutoIt:
    VectorOfVec2d.Keys() -> retval

VectorOfVec2d VectorOfVec2d::Items()

AutoIt:
    VectorOfVec2d.Items() -> retval

void VectorOfVec2d::push_back( cv::Vec2d value )

AutoIt:
    VectorOfVec2d.push_back( $value ) -> None

void VectorOfVec2d::Add( cv::Vec2d value )

AutoIt:
    VectorOfVec2d.Add( $value ) -> None

void VectorOfVec2d::Remove( size_t index )

AutoIt:
    VectorOfVec2d.Remove( $index ) -> None

cv::Vec2d VectorOfVec2d::at( size_t index )

AutoIt:
    VectorOfVec2d.at( $index ) -> retval

void VectorOfVec2d::at( size_t    index
                        cv::Vec2d value )

AutoIt:
    VectorOfVec2d.at( $index, $value ) -> None

size_t VectorOfVec2d::size()

AutoIt:
    VectorOfVec2d.size() -> retval

bool VectorOfVec2d::empty()

AutoIt:
    VectorOfVec2d.empty() -> retval

void VectorOfVec2d::clear()

AutoIt:
    VectorOfVec2d.clear() -> None

void VectorOfVec2d::push_vector( VectorOfVec2d other )

AutoIt:
    VectorOfVec2d.push_vector( $other ) -> None

void VectorOfVec2d::push_vector( VectorOfVec2d other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec2d.push_vector( $other, $count[, $start] ) -> None

VectorOfVec2d VectorOfVec2d::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2d.slice( [$start[, $count]] ) -> retval

void VectorOfVec2d::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2d.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec2d::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec2d.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec2d::start()

AutoIt:
    VectorOfVec2d.start() -> retval

void* VectorOfVec2d::end()

AutoIt:
    VectorOfVec2d.end() -> retval

cv::Vec2d VectorOfVec2d::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec2d.Item( $vIndex ) -> retval
    VectorOfVec2d( $vIndex ) -> retval

void VectorOfVec2d::put_Item( size_t    vIndex
                              cv::Vec2d vItem )

AutoIt:
    VectorOfVec2d.Item( $vIndex ) = $vItem

static VectorOfVec3d VectorOfVec3d::create()

AutoIt:
    VectorOfVec3d.create() -> <VectorOfVec3d object>

static VectorOfVec3d VectorOfVec3d::create( size_t size )

AutoIt:
    VectorOfVec3d.create( $size ) -> <VectorOfVec3d object>

static VectorOfVec3d VectorOfVec3d::create( VectorOfVec3d other )

AutoIt:
    VectorOfVec3d.create( $other ) -> <VectorOfVec3d object>

std::vector<int> VectorOfVec3d::Keys()

AutoIt:
    VectorOfVec3d.Keys() -> retval

VectorOfVec3d VectorOfVec3d::Items()

AutoIt:
    VectorOfVec3d.Items() -> retval

void VectorOfVec3d::push_back( cv::Vec3d value )

AutoIt:
    VectorOfVec3d.push_back( $value ) -> None

void VectorOfVec3d::Add( cv::Vec3d value )

AutoIt:
    VectorOfVec3d.Add( $value ) -> None

void VectorOfVec3d::Remove( size_t index )

AutoIt:
    VectorOfVec3d.Remove( $index ) -> None

cv::Vec3d VectorOfVec3d::at( size_t index )

AutoIt:
    VectorOfVec3d.at( $index ) -> retval

void VectorOfVec3d::at( size_t    index
                        cv::Vec3d value )

AutoIt:
    VectorOfVec3d.at( $index, $value ) -> None

size_t VectorOfVec3d::size()

AutoIt:
    VectorOfVec3d.size() -> retval

bool VectorOfVec3d::empty()

AutoIt:
    VectorOfVec3d.empty() -> retval

void VectorOfVec3d::clear()

AutoIt:
    VectorOfVec3d.clear() -> None

void VectorOfVec3d::push_vector( VectorOfVec3d other )

AutoIt:
    VectorOfVec3d.push_vector( $other ) -> None

void VectorOfVec3d::push_vector( VectorOfVec3d other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec3d.push_vector( $other, $count[, $start] ) -> None

VectorOfVec3d VectorOfVec3d::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3d.slice( [$start[, $count]] ) -> retval

void VectorOfVec3d::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3d.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec3d::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec3d.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec3d::start()

AutoIt:
    VectorOfVec3d.start() -> retval

void* VectorOfVec3d::end()

AutoIt:
    VectorOfVec3d.end() -> retval

cv::Vec3d VectorOfVec3d::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec3d.Item( $vIndex ) -> retval
    VectorOfVec3d( $vIndex ) -> retval

void VectorOfVec3d::put_Item( size_t    vIndex
                              cv::Vec3d vItem )

AutoIt:
    VectorOfVec3d.Item( $vIndex ) = $vItem

static VectorOfVec4d VectorOfVec4d::create()

AutoIt:
    VectorOfVec4d.create() -> <VectorOfVec4d object>

static VectorOfVec4d VectorOfVec4d::create( size_t size )

AutoIt:
    VectorOfVec4d.create( $size ) -> <VectorOfVec4d object>

static VectorOfVec4d VectorOfVec4d::create( VectorOfVec4d other )

AutoIt:
    VectorOfVec4d.create( $other ) -> <VectorOfVec4d object>

std::vector<int> VectorOfVec4d::Keys()

AutoIt:
    VectorOfVec4d.Keys() -> retval

VectorOfVec4d VectorOfVec4d::Items()

AutoIt:
    VectorOfVec4d.Items() -> retval

void VectorOfVec4d::push_back( cv::Vec4d value )

AutoIt:
    VectorOfVec4d.push_back( $value ) -> None

void VectorOfVec4d::Add( cv::Vec4d value )

AutoIt:
    VectorOfVec4d.Add( $value ) -> None

void VectorOfVec4d::Remove( size_t index )

AutoIt:
    VectorOfVec4d.Remove( $index ) -> None

cv::Vec4d VectorOfVec4d::at( size_t index )

AutoIt:
    VectorOfVec4d.at( $index ) -> retval

void VectorOfVec4d::at( size_t    index
                        cv::Vec4d value )

AutoIt:
    VectorOfVec4d.at( $index, $value ) -> None

size_t VectorOfVec4d::size()

AutoIt:
    VectorOfVec4d.size() -> retval

bool VectorOfVec4d::empty()

AutoIt:
    VectorOfVec4d.empty() -> retval

void VectorOfVec4d::clear()

AutoIt:
    VectorOfVec4d.clear() -> None

void VectorOfVec4d::push_vector( VectorOfVec4d other )

AutoIt:
    VectorOfVec4d.push_vector( $other ) -> None

void VectorOfVec4d::push_vector( VectorOfVec4d other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec4d.push_vector( $other, $count[, $start] ) -> None

VectorOfVec4d VectorOfVec4d::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4d.slice( [$start[, $count]] ) -> retval

void VectorOfVec4d::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4d.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec4d::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec4d.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec4d::start()

AutoIt:
    VectorOfVec4d.start() -> retval

void* VectorOfVec4d::end()

AutoIt:
    VectorOfVec4d.end() -> retval

cv::Vec4d VectorOfVec4d::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec4d.Item( $vIndex ) -> retval
    VectorOfVec4d( $vIndex ) -> retval

void VectorOfVec4d::put_Item( size_t    vIndex
                              cv::Vec4d vItem )

AutoIt:
    VectorOfVec4d.Item( $vIndex ) = $vItem

static VectorOfVec6d VectorOfVec6d::create()

AutoIt:
    VectorOfVec6d.create() -> <VectorOfVec6d object>

static VectorOfVec6d VectorOfVec6d::create( size_t size )

AutoIt:
    VectorOfVec6d.create( $size ) -> <VectorOfVec6d object>

static VectorOfVec6d VectorOfVec6d::create( VectorOfVec6d other )

AutoIt:
    VectorOfVec6d.create( $other ) -> <VectorOfVec6d object>

std::vector<int> VectorOfVec6d::Keys()

AutoIt:
    VectorOfVec6d.Keys() -> retval

VectorOfVec6d VectorOfVec6d::Items()

AutoIt:
    VectorOfVec6d.Items() -> retval

void VectorOfVec6d::push_back( cv::Vec6d value )

AutoIt:
    VectorOfVec6d.push_back( $value ) -> None

void VectorOfVec6d::Add( cv::Vec6d value )

AutoIt:
    VectorOfVec6d.Add( $value ) -> None

void VectorOfVec6d::Remove( size_t index )

AutoIt:
    VectorOfVec6d.Remove( $index ) -> None

cv::Vec6d VectorOfVec6d::at( size_t index )

AutoIt:
    VectorOfVec6d.at( $index ) -> retval

void VectorOfVec6d::at( size_t    index
                        cv::Vec6d value )

AutoIt:
    VectorOfVec6d.at( $index, $value ) -> None

size_t VectorOfVec6d::size()

AutoIt:
    VectorOfVec6d.size() -> retval

bool VectorOfVec6d::empty()

AutoIt:
    VectorOfVec6d.empty() -> retval

void VectorOfVec6d::clear()

AutoIt:
    VectorOfVec6d.clear() -> None

void VectorOfVec6d::push_vector( VectorOfVec6d other )

AutoIt:
    VectorOfVec6d.push_vector( $other ) -> None

void VectorOfVec6d::push_vector( VectorOfVec6d other
                                 size_t        count
                                 size_t        start = 0 )

AutoIt:
    VectorOfVec6d.push_vector( $other, $count[, $start] ) -> None

VectorOfVec6d VectorOfVec6d::slice( size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6d.slice( [$start[, $count]] ) -> retval

void VectorOfVec6d::sort( void*  comparator
                          size_t start = 0
                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6d.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVec6d::sort_variant( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVec6d.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVec6d::start()

AutoIt:
    VectorOfVec6d.start() -> retval

void* VectorOfVec6d::end()

AutoIt:
    VectorOfVec6d.end() -> retval

cv::Vec6d VectorOfVec6d::get_Item( size_t vIndex )

AutoIt:
    VectorOfVec6d.Item( $vIndex ) -> retval
    VectorOfVec6d( $vIndex ) -> retval

void VectorOfVec6d::put_Item( size_t    vIndex
                              cv::Vec6d vItem )

AutoIt:
    VectorOfVec6d.Item( $vIndex ) = $vItem

static VectorOfPoint2f VectorOfPoint2f::create()

AutoIt:
    VectorOfPoint2f.create() -> <VectorOfPoint2f object>

static VectorOfPoint2f VectorOfPoint2f::create( size_t size )

AutoIt:
    VectorOfPoint2f.create( $size ) -> <VectorOfPoint2f object>

static VectorOfPoint2f VectorOfPoint2f::create( VectorOfPoint2f other )

AutoIt:
    VectorOfPoint2f.create( $other ) -> <VectorOfPoint2f object>

std::vector<int> VectorOfPoint2f::Keys()

AutoIt:
    VectorOfPoint2f.Keys() -> retval

VectorOfPoint2f VectorOfPoint2f::Items()

AutoIt:
    VectorOfPoint2f.Items() -> retval

void VectorOfPoint2f::push_back( cv::Point2f value )

AutoIt:
    VectorOfPoint2f.push_back( $value ) -> None

void VectorOfPoint2f::Add( cv::Point2f value )

AutoIt:
    VectorOfPoint2f.Add( $value ) -> None

void VectorOfPoint2f::Remove( size_t index )

AutoIt:
    VectorOfPoint2f.Remove( $index ) -> None

cv::Point2f VectorOfPoint2f::at( size_t index )

AutoIt:
    VectorOfPoint2f.at( $index ) -> retval

void VectorOfPoint2f::at( size_t      index
                          cv::Point2f value )

AutoIt:
    VectorOfPoint2f.at( $index, $value ) -> None

size_t VectorOfPoint2f::size()

AutoIt:
    VectorOfPoint2f.size() -> retval

bool VectorOfPoint2f::empty()

AutoIt:
    VectorOfPoint2f.empty() -> retval

void VectorOfPoint2f::clear()

AutoIt:
    VectorOfPoint2f.clear() -> None

void VectorOfPoint2f::push_vector( VectorOfPoint2f other )

AutoIt:
    VectorOfPoint2f.push_vector( $other ) -> None

void VectorOfPoint2f::push_vector( VectorOfPoint2f other
                                   size_t          count
                                   size_t          start = 0 )

AutoIt:
    VectorOfPoint2f.push_vector( $other, $count[, $start] ) -> None

VectorOfPoint2f VectorOfPoint2f::slice( size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPoint2f.slice( [$start[, $count]] ) -> retval

void VectorOfPoint2f::sort( void*  comparator
                            size_t start = 0
                            size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPoint2f.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfPoint2f::sort_variant( void*  comparator
                                    size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPoint2f.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfPoint2f::start()

AutoIt:
    VectorOfPoint2f.start() -> retval

void* VectorOfPoint2f::end()

AutoIt:
    VectorOfPoint2f.end() -> retval

cv::Point2f VectorOfPoint2f::get_Item( size_t vIndex )

AutoIt:
    VectorOfPoint2f.Item( $vIndex ) -> retval
    VectorOfPoint2f( $vIndex ) -> retval

void VectorOfPoint2f::put_Item( size_t      vIndex
                                cv::Point2f vItem )

AutoIt:
    VectorOfPoint2f.Item( $vIndex ) = $vItem

static VectorOfVectorOfPoint2f VectorOfVectorOfPoint2f::create()

AutoIt:
    VectorOfVectorOfPoint2f.create() -> <VectorOfVectorOfPoint2f object>

static VectorOfVectorOfPoint2f VectorOfVectorOfPoint2f::create( size_t size )

AutoIt:
    VectorOfVectorOfPoint2f.create( $size ) -> <VectorOfVectorOfPoint2f object>

static VectorOfVectorOfPoint2f VectorOfVectorOfPoint2f::create( VectorOfVectorOfPoint2f other )

AutoIt:
    VectorOfVectorOfPoint2f.create( $other ) -> <VectorOfVectorOfPoint2f object>

std::vector<int> VectorOfVectorOfPoint2f::Keys()

AutoIt:
    VectorOfVectorOfPoint2f.Keys() -> retval

VectorOfVectorOfPoint2f VectorOfVectorOfPoint2f::Items()

AutoIt:
    VectorOfVectorOfPoint2f.Items() -> retval

void VectorOfVectorOfPoint2f::push_back( std::vector<cv::Point2f> value )

AutoIt:
    VectorOfVectorOfPoint2f.push_back( $value ) -> None

void VectorOfVectorOfPoint2f::Add( std::vector<cv::Point2f> value )

AutoIt:
    VectorOfVectorOfPoint2f.Add( $value ) -> None

void VectorOfVectorOfPoint2f::Remove( size_t index )

AutoIt:
    VectorOfVectorOfPoint2f.Remove( $index ) -> None

std::vector<cv::Point2f> VectorOfVectorOfPoint2f::at( size_t index )

AutoIt:
    VectorOfVectorOfPoint2f.at( $index ) -> retval

void VectorOfVectorOfPoint2f::at( size_t                   index
                                  std::vector<cv::Point2f> value )

AutoIt:
    VectorOfVectorOfPoint2f.at( $index, $value ) -> None

size_t VectorOfVectorOfPoint2f::size()

AutoIt:
    VectorOfVectorOfPoint2f.size() -> retval

bool VectorOfVectorOfPoint2f::empty()

AutoIt:
    VectorOfVectorOfPoint2f.empty() -> retval

void VectorOfVectorOfPoint2f::clear()

AutoIt:
    VectorOfVectorOfPoint2f.clear() -> None

void VectorOfVectorOfPoint2f::push_vector( VectorOfVectorOfPoint2f other )

AutoIt:
    VectorOfVectorOfPoint2f.push_vector( $other ) -> None

void VectorOfVectorOfPoint2f::push_vector( VectorOfVectorOfPoint2f other
                                           size_t                  count
                                           size_t                  start = 0 )

AutoIt:
    VectorOfVectorOfPoint2f.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfPoint2f VectorOfVectorOfPoint2f::slice( size_t start = 0
                                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfPoint2f.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfPoint2f::sort( void*  comparator
                                    size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfPoint2f.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfPoint2f::sort_variant( void*  comparator
                                            size_t start = 0
                                            size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfPoint2f.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfPoint2f::start()

AutoIt:
    VectorOfVectorOfPoint2f.start() -> retval

void* VectorOfVectorOfPoint2f::end()

AutoIt:
    VectorOfVectorOfPoint2f.end() -> retval

std::vector<cv::Point2f> VectorOfVectorOfPoint2f::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfPoint2f.Item( $vIndex ) -> retval
    VectorOfVectorOfPoint2f( $vIndex ) -> retval

void VectorOfVectorOfPoint2f::put_Item( size_t                   vIndex
                                        std::vector<cv::Point2f> vItem )

AutoIt:
    VectorOfVectorOfPoint2f.Item( $vIndex ) = $vItem

static VectorOfRect2d VectorOfRect2d::create()

AutoIt:
    VectorOfRect2d.create() -> <VectorOfRect2d object>

static VectorOfRect2d VectorOfRect2d::create( size_t size )

AutoIt:
    VectorOfRect2d.create( $size ) -> <VectorOfRect2d object>

static VectorOfRect2d VectorOfRect2d::create( VectorOfRect2d other )

AutoIt:
    VectorOfRect2d.create( $other ) -> <VectorOfRect2d object>

std::vector<int> VectorOfRect2d::Keys()

AutoIt:
    VectorOfRect2d.Keys() -> retval

VectorOfRect2d VectorOfRect2d::Items()

AutoIt:
    VectorOfRect2d.Items() -> retval

void VectorOfRect2d::push_back( cv::Rect2d value )

AutoIt:
    VectorOfRect2d.push_back( $value ) -> None

void VectorOfRect2d::Add( cv::Rect2d value )

AutoIt:
    VectorOfRect2d.Add( $value ) -> None

void VectorOfRect2d::Remove( size_t index )

AutoIt:
    VectorOfRect2d.Remove( $index ) -> None

cv::Rect2d VectorOfRect2d::at( size_t index )

AutoIt:
    VectorOfRect2d.at( $index ) -> retval

void VectorOfRect2d::at( size_t     index
                         cv::Rect2d value )

AutoIt:
    VectorOfRect2d.at( $index, $value ) -> None

size_t VectorOfRect2d::size()

AutoIt:
    VectorOfRect2d.size() -> retval

bool VectorOfRect2d::empty()

AutoIt:
    VectorOfRect2d.empty() -> retval

void VectorOfRect2d::clear()

AutoIt:
    VectorOfRect2d.clear() -> None

void VectorOfRect2d::push_vector( VectorOfRect2d other )

AutoIt:
    VectorOfRect2d.push_vector( $other ) -> None

void VectorOfRect2d::push_vector( VectorOfRect2d other
                                  size_t         count
                                  size_t         start = 0 )

AutoIt:
    VectorOfRect2d.push_vector( $other, $count[, $start] ) -> None

VectorOfRect2d VectorOfRect2d::slice( size_t start = 0
                                      size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRect2d.slice( [$start[, $count]] ) -> retval

void VectorOfRect2d::sort( void*  comparator
                           size_t start = 0
                           size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRect2d.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfRect2d::sort_variant( void*  comparator
                                   size_t start = 0
                                   size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfRect2d.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfRect2d::start()

AutoIt:
    VectorOfRect2d.start() -> retval

void* VectorOfRect2d::end()

AutoIt:
    VectorOfRect2d.end() -> retval

cv::Rect2d VectorOfRect2d::get_Item( size_t vIndex )

AutoIt:
    VectorOfRect2d.Item( $vIndex ) -> retval
    VectorOfRect2d( $vIndex ) -> retval

void VectorOfRect2d::put_Item( size_t     vIndex
                               cv::Rect2d vItem )

AutoIt:
    VectorOfRect2d.Item( $vIndex ) = $vItem

static VectorOfVectorOfMat VectorOfVectorOfMat::create()

AutoIt:
    VectorOfVectorOfMat.create() -> <VectorOfVectorOfMat object>

static VectorOfVectorOfMat VectorOfVectorOfMat::create( size_t size )

AutoIt:
    VectorOfVectorOfMat.create( $size ) -> <VectorOfVectorOfMat object>

static VectorOfVectorOfMat VectorOfVectorOfMat::create( VectorOfVectorOfMat other )

AutoIt:
    VectorOfVectorOfMat.create( $other ) -> <VectorOfVectorOfMat object>

std::vector<int> VectorOfVectorOfMat::Keys()

AutoIt:
    VectorOfVectorOfMat.Keys() -> retval

VectorOfVectorOfMat VectorOfVectorOfMat::Items()

AutoIt:
    VectorOfVectorOfMat.Items() -> retval

void VectorOfVectorOfMat::push_back( std::vector<cv::Mat> value )

AutoIt:
    VectorOfVectorOfMat.push_back( $value ) -> None

void VectorOfVectorOfMat::Add( std::vector<cv::Mat> value )

AutoIt:
    VectorOfVectorOfMat.Add( $value ) -> None

void VectorOfVectorOfMat::Remove( size_t index )

AutoIt:
    VectorOfVectorOfMat.Remove( $index ) -> None

std::vector<cv::Mat> VectorOfVectorOfMat::at( size_t index )

AutoIt:
    VectorOfVectorOfMat.at( $index ) -> retval

void VectorOfVectorOfMat::at( size_t               index
                              std::vector<cv::Mat> value )

AutoIt:
    VectorOfVectorOfMat.at( $index, $value ) -> None

size_t VectorOfVectorOfMat::size()

AutoIt:
    VectorOfVectorOfMat.size() -> retval

bool VectorOfVectorOfMat::empty()

AutoIt:
    VectorOfVectorOfMat.empty() -> retval

void VectorOfVectorOfMat::clear()

AutoIt:
    VectorOfVectorOfMat.clear() -> None

void VectorOfVectorOfMat::push_vector( VectorOfVectorOfMat other )

AutoIt:
    VectorOfVectorOfMat.push_vector( $other ) -> None

void VectorOfVectorOfMat::push_vector( VectorOfVectorOfMat other
                                       size_t              count
                                       size_t              start = 0 )

AutoIt:
    VectorOfVectorOfMat.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfMat VectorOfVectorOfMat::slice( size_t start = 0
                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfMat.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfMat::sort( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfMat.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfMat::sort_variant( void*  comparator
                                        size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfMat.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfMat::start()

AutoIt:
    VectorOfVectorOfMat.start() -> retval

void* VectorOfVectorOfMat::end()

AutoIt:
    VectorOfVectorOfMat.end() -> retval

std::vector<cv::Mat> VectorOfVectorOfMat::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfMat.Item( $vIndex ) -> retval
    VectorOfVectorOfMat( $vIndex ) -> retval

void VectorOfVectorOfMat::put_Item( size_t               vIndex
                                    std::vector<cv::Mat> vItem )

AutoIt:
    VectorOfVectorOfMat.Item( $vIndex ) = $vItem

static VectorOfVectorOfInt VectorOfVectorOfInt::create()

AutoIt:
    VectorOfVectorOfInt.create() -> <VectorOfVectorOfInt object>

static VectorOfVectorOfInt VectorOfVectorOfInt::create( size_t size )

AutoIt:
    VectorOfVectorOfInt.create( $size ) -> <VectorOfVectorOfInt object>

static VectorOfVectorOfInt VectorOfVectorOfInt::create( VectorOfVectorOfInt other )

AutoIt:
    VectorOfVectorOfInt.create( $other ) -> <VectorOfVectorOfInt object>

std::vector<int> VectorOfVectorOfInt::Keys()

AutoIt:
    VectorOfVectorOfInt.Keys() -> retval

VectorOfVectorOfInt VectorOfVectorOfInt::Items()

AutoIt:
    VectorOfVectorOfInt.Items() -> retval

void VectorOfVectorOfInt::push_back( std::vector<int> value )

AutoIt:
    VectorOfVectorOfInt.push_back( $value ) -> None

void VectorOfVectorOfInt::Add( std::vector<int> value )

AutoIt:
    VectorOfVectorOfInt.Add( $value ) -> None

void VectorOfVectorOfInt::Remove( size_t index )

AutoIt:
    VectorOfVectorOfInt.Remove( $index ) -> None

std::vector<int> VectorOfVectorOfInt::at( size_t index )

AutoIt:
    VectorOfVectorOfInt.at( $index ) -> retval

void VectorOfVectorOfInt::at( size_t           index
                              std::vector<int> value )

AutoIt:
    VectorOfVectorOfInt.at( $index, $value ) -> None

size_t VectorOfVectorOfInt::size()

AutoIt:
    VectorOfVectorOfInt.size() -> retval

bool VectorOfVectorOfInt::empty()

AutoIt:
    VectorOfVectorOfInt.empty() -> retval

void VectorOfVectorOfInt::clear()

AutoIt:
    VectorOfVectorOfInt.clear() -> None

void VectorOfVectorOfInt::push_vector( VectorOfVectorOfInt other )

AutoIt:
    VectorOfVectorOfInt.push_vector( $other ) -> None

void VectorOfVectorOfInt::push_vector( VectorOfVectorOfInt other
                                       size_t              count
                                       size_t              start = 0 )

AutoIt:
    VectorOfVectorOfInt.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfInt VectorOfVectorOfInt::slice( size_t start = 0
                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfInt.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfInt::sort( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfInt.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfInt::sort_variant( void*  comparator
                                        size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfInt.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfInt::start()

AutoIt:
    VectorOfVectorOfInt.start() -> retval

void* VectorOfVectorOfInt::end()

AutoIt:
    VectorOfVectorOfInt.end() -> retval

std::vector<int> VectorOfVectorOfInt::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfInt.Item( $vIndex ) -> retval
    VectorOfVectorOfInt( $vIndex ) -> retval

void VectorOfVectorOfInt::put_Item( size_t           vIndex
                                    std::vector<int> vItem )

AutoIt:
    VectorOfVectorOfInt.Item( $vIndex ) = $vItem

static VectorOfVectorOfVectorOfInt VectorOfVectorOfVectorOfInt::create()

AutoIt:
    VectorOfVectorOfVectorOfInt.create() -> <VectorOfVectorOfVectorOfInt object>

static VectorOfVectorOfVectorOfInt VectorOfVectorOfVectorOfInt::create( size_t size )

AutoIt:
    VectorOfVectorOfVectorOfInt.create( $size ) -> <VectorOfVectorOfVectorOfInt object>

static VectorOfVectorOfVectorOfInt VectorOfVectorOfVectorOfInt::create( VectorOfVectorOfVectorOfInt other )

AutoIt:
    VectorOfVectorOfVectorOfInt.create( $other ) -> <VectorOfVectorOfVectorOfInt object>

std::vector<int> VectorOfVectorOfVectorOfInt::Keys()

AutoIt:
    VectorOfVectorOfVectorOfInt.Keys() -> retval

VectorOfVectorOfVectorOfInt VectorOfVectorOfVectorOfInt::Items()

AutoIt:
    VectorOfVectorOfVectorOfInt.Items() -> retval

void VectorOfVectorOfVectorOfInt::push_back( std::vector<std::vector<int>> value )

AutoIt:
    VectorOfVectorOfVectorOfInt.push_back( $value ) -> None

void VectorOfVectorOfVectorOfInt::Add( std::vector<std::vector<int>> value )

AutoIt:
    VectorOfVectorOfVectorOfInt.Add( $value ) -> None

void VectorOfVectorOfVectorOfInt::Remove( size_t index )

AutoIt:
    VectorOfVectorOfVectorOfInt.Remove( $index ) -> None

std::vector<std::vector<int>> VectorOfVectorOfVectorOfInt::at( size_t index )

AutoIt:
    VectorOfVectorOfVectorOfInt.at( $index ) -> retval

void VectorOfVectorOfVectorOfInt::at( size_t                        index
                                      std::vector<std::vector<int>> value )

AutoIt:
    VectorOfVectorOfVectorOfInt.at( $index, $value ) -> None

size_t VectorOfVectorOfVectorOfInt::size()

AutoIt:
    VectorOfVectorOfVectorOfInt.size() -> retval

bool VectorOfVectorOfVectorOfInt::empty()

AutoIt:
    VectorOfVectorOfVectorOfInt.empty() -> retval

void VectorOfVectorOfVectorOfInt::clear()

AutoIt:
    VectorOfVectorOfVectorOfInt.clear() -> None

void VectorOfVectorOfVectorOfInt::push_vector( VectorOfVectorOfVectorOfInt other )

AutoIt:
    VectorOfVectorOfVectorOfInt.push_vector( $other ) -> None

void VectorOfVectorOfVectorOfInt::push_vector( VectorOfVectorOfVectorOfInt other
                                               size_t                      count
                                               size_t                      start = 0 )

AutoIt:
    VectorOfVectorOfVectorOfInt.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfVectorOfInt VectorOfVectorOfVectorOfInt::slice( size_t start = 0
                                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfVectorOfInt.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfVectorOfInt::sort( void*  comparator
                                        size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfVectorOfInt.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfVectorOfInt::sort_variant( void*  comparator
                                                size_t start = 0
                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfVectorOfInt.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfVectorOfInt::start()

AutoIt:
    VectorOfVectorOfVectorOfInt.start() -> retval

void* VectorOfVectorOfVectorOfInt::end()

AutoIt:
    VectorOfVectorOfVectorOfInt.end() -> retval

std::vector<std::vector<int>> VectorOfVectorOfVectorOfInt::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfVectorOfInt.Item( $vIndex ) -> retval
    VectorOfVectorOfVectorOfInt( $vIndex ) -> retval

void VectorOfVectorOfVectorOfInt::put_Item( size_t                        vIndex
                                            std::vector<std::vector<int>> vItem )

AutoIt:
    VectorOfVectorOfVectorOfInt.Item( $vIndex ) = $vItem

static VectorOfVectorOfPoint VectorOfVectorOfPoint::create()

AutoIt:
    VectorOfVectorOfPoint.create() -> <VectorOfVectorOfPoint object>

static VectorOfVectorOfPoint VectorOfVectorOfPoint::create( size_t size )

AutoIt:
    VectorOfVectorOfPoint.create( $size ) -> <VectorOfVectorOfPoint object>

static VectorOfVectorOfPoint VectorOfVectorOfPoint::create( VectorOfVectorOfPoint other )

AutoIt:
    VectorOfVectorOfPoint.create( $other ) -> <VectorOfVectorOfPoint object>

std::vector<int> VectorOfVectorOfPoint::Keys()

AutoIt:
    VectorOfVectorOfPoint.Keys() -> retval

VectorOfVectorOfPoint VectorOfVectorOfPoint::Items()

AutoIt:
    VectorOfVectorOfPoint.Items() -> retval

void VectorOfVectorOfPoint::push_back( std::vector<cv::Point> value )

AutoIt:
    VectorOfVectorOfPoint.push_back( $value ) -> None

void VectorOfVectorOfPoint::Add( std::vector<cv::Point> value )

AutoIt:
    VectorOfVectorOfPoint.Add( $value ) -> None

void VectorOfVectorOfPoint::Remove( size_t index )

AutoIt:
    VectorOfVectorOfPoint.Remove( $index ) -> None

std::vector<cv::Point> VectorOfVectorOfPoint::at( size_t index )

AutoIt:
    VectorOfVectorOfPoint.at( $index ) -> retval

void VectorOfVectorOfPoint::at( size_t                 index
                                std::vector<cv::Point> value )

AutoIt:
    VectorOfVectorOfPoint.at( $index, $value ) -> None

size_t VectorOfVectorOfPoint::size()

AutoIt:
    VectorOfVectorOfPoint.size() -> retval

bool VectorOfVectorOfPoint::empty()

AutoIt:
    VectorOfVectorOfPoint.empty() -> retval

void VectorOfVectorOfPoint::clear()

AutoIt:
    VectorOfVectorOfPoint.clear() -> None

void VectorOfVectorOfPoint::push_vector( VectorOfVectorOfPoint other )

AutoIt:
    VectorOfVectorOfPoint.push_vector( $other ) -> None

void VectorOfVectorOfPoint::push_vector( VectorOfVectorOfPoint other
                                         size_t                count
                                         size_t                start = 0 )

AutoIt:
    VectorOfVectorOfPoint.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfPoint VectorOfVectorOfPoint::slice( size_t start = 0
                                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfPoint.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfPoint::sort( void*  comparator
                                  size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfPoint.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfPoint::sort_variant( void*  comparator
                                          size_t start = 0
                                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfPoint.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfPoint::start()

AutoIt:
    VectorOfVectorOfPoint.start() -> retval

void* VectorOfVectorOfPoint::end()

AutoIt:
    VectorOfVectorOfPoint.end() -> retval

std::vector<cv::Point> VectorOfVectorOfPoint::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfPoint.Item( $vIndex ) -> retval
    VectorOfVectorOfPoint( $vIndex ) -> retval

void VectorOfVectorOfPoint::put_Item( size_t                 vIndex
                                      std::vector<cv::Point> vItem )

AutoIt:
    VectorOfVectorOfPoint.Item( $vIndex ) = $vItem

static VectorOfVectorOfKeyPoint VectorOfVectorOfKeyPoint::create()

AutoIt:
    VectorOfVectorOfKeyPoint.create() -> <VectorOfVectorOfKeyPoint object>

static VectorOfVectorOfKeyPoint VectorOfVectorOfKeyPoint::create( size_t size )

AutoIt:
    VectorOfVectorOfKeyPoint.create( $size ) -> <VectorOfVectorOfKeyPoint object>

static VectorOfVectorOfKeyPoint VectorOfVectorOfKeyPoint::create( VectorOfVectorOfKeyPoint other )

AutoIt:
    VectorOfVectorOfKeyPoint.create( $other ) -> <VectorOfVectorOfKeyPoint object>

std::vector<int> VectorOfVectorOfKeyPoint::Keys()

AutoIt:
    VectorOfVectorOfKeyPoint.Keys() -> retval

VectorOfVectorOfKeyPoint VectorOfVectorOfKeyPoint::Items()

AutoIt:
    VectorOfVectorOfKeyPoint.Items() -> retval

void VectorOfVectorOfKeyPoint::push_back( std::vector<cv::KeyPoint> value )

AutoIt:
    VectorOfVectorOfKeyPoint.push_back( $value ) -> None

void VectorOfVectorOfKeyPoint::Add( std::vector<cv::KeyPoint> value )

AutoIt:
    VectorOfVectorOfKeyPoint.Add( $value ) -> None

void VectorOfVectorOfKeyPoint::Remove( size_t index )

AutoIt:
    VectorOfVectorOfKeyPoint.Remove( $index ) -> None

std::vector<cv::KeyPoint> VectorOfVectorOfKeyPoint::at( size_t index )

AutoIt:
    VectorOfVectorOfKeyPoint.at( $index ) -> retval

void VectorOfVectorOfKeyPoint::at( size_t                    index
                                   std::vector<cv::KeyPoint> value )

AutoIt:
    VectorOfVectorOfKeyPoint.at( $index, $value ) -> None

size_t VectorOfVectorOfKeyPoint::size()

AutoIt:
    VectorOfVectorOfKeyPoint.size() -> retval

bool VectorOfVectorOfKeyPoint::empty()

AutoIt:
    VectorOfVectorOfKeyPoint.empty() -> retval

void VectorOfVectorOfKeyPoint::clear()

AutoIt:
    VectorOfVectorOfKeyPoint.clear() -> None

void VectorOfVectorOfKeyPoint::push_vector( VectorOfVectorOfKeyPoint other )

AutoIt:
    VectorOfVectorOfKeyPoint.push_vector( $other ) -> None

void VectorOfVectorOfKeyPoint::push_vector( VectorOfVectorOfKeyPoint other
                                            size_t                   count
                                            size_t                   start = 0 )

AutoIt:
    VectorOfVectorOfKeyPoint.push_vector( $other, $count[, $start] ) -> None

VectorOfVectorOfKeyPoint VectorOfVectorOfKeyPoint::slice( size_t start = 0
                                                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfKeyPoint.slice( [$start[, $count]] ) -> retval

void VectorOfVectorOfKeyPoint::sort( void*  comparator
                                     size_t start = 0
                                     size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfKeyPoint.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfVectorOfKeyPoint::sort_variant( void*  comparator
                                             size_t start = 0
                                             size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfVectorOfKeyPoint.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfVectorOfKeyPoint::start()

AutoIt:
    VectorOfVectorOfKeyPoint.start() -> retval

void* VectorOfVectorOfKeyPoint::end()

AutoIt:
    VectorOfVectorOfKeyPoint.end() -> retval

std::vector<cv::KeyPoint> VectorOfVectorOfKeyPoint::get_Item( size_t vIndex )

AutoIt:
    VectorOfVectorOfKeyPoint.Item( $vIndex ) -> retval
    VectorOfVectorOfKeyPoint( $vIndex ) -> retval

void VectorOfVectorOfKeyPoint::put_Item( size_t                    vIndex
                                         std::vector<cv::KeyPoint> vItem )

AutoIt:
    VectorOfVectorOfKeyPoint.Item( $vIndex ) = $vItem

static VectorOfCameraParams VectorOfCameraParams::create()

AutoIt:
    VectorOfCameraParams.create() -> <VectorOfCameraParams object>

static VectorOfCameraParams VectorOfCameraParams::create( size_t size )

AutoIt:
    VectorOfCameraParams.create( $size ) -> <VectorOfCameraParams object>

static VectorOfCameraParams VectorOfCameraParams::create( VectorOfCameraParams other )

AutoIt:
    VectorOfCameraParams.create( $other ) -> <VectorOfCameraParams object>

std::vector<int> VectorOfCameraParams::Keys()

AutoIt:
    VectorOfCameraParams.Keys() -> retval

VectorOfCameraParams VectorOfCameraParams::Items()

AutoIt:
    VectorOfCameraParams.Items() -> retval

void VectorOfCameraParams::push_back( cv::detail::CameraParams value )

AutoIt:
    VectorOfCameraParams.push_back( $value ) -> None

void VectorOfCameraParams::Add( cv::detail::CameraParams value )

AutoIt:
    VectorOfCameraParams.Add( $value ) -> None

void VectorOfCameraParams::Remove( size_t index )

AutoIt:
    VectorOfCameraParams.Remove( $index ) -> None

cv::detail::CameraParams VectorOfCameraParams::at( size_t index )

AutoIt:
    VectorOfCameraParams.at( $index ) -> retval

void VectorOfCameraParams::at( size_t                   index
                               cv::detail::CameraParams value )

AutoIt:
    VectorOfCameraParams.at( $index, $value ) -> None

size_t VectorOfCameraParams::size()

AutoIt:
    VectorOfCameraParams.size() -> retval

bool VectorOfCameraParams::empty()

AutoIt:
    VectorOfCameraParams.empty() -> retval

void VectorOfCameraParams::clear()

AutoIt:
    VectorOfCameraParams.clear() -> None

void VectorOfCameraParams::push_vector( VectorOfCameraParams other )

AutoIt:
    VectorOfCameraParams.push_vector( $other ) -> None

void VectorOfCameraParams::push_vector( VectorOfCameraParams other
                                        size_t               count
                                        size_t               start = 0 )

AutoIt:
    VectorOfCameraParams.push_vector( $other, $count[, $start] ) -> None

VectorOfCameraParams VectorOfCameraParams::slice( size_t start = 0
                                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfCameraParams.slice( [$start[, $count]] ) -> retval

void VectorOfCameraParams::sort( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfCameraParams.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfCameraParams::sort_variant( void*  comparator
                                         size_t start = 0
                                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfCameraParams.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfCameraParams::start()

AutoIt:
    VectorOfCameraParams.start() -> retval

void* VectorOfCameraParams::end()

AutoIt:
    VectorOfCameraParams.end() -> retval

cv::detail::CameraParams VectorOfCameraParams::get_Item( size_t vIndex )

AutoIt:
    VectorOfCameraParams.Item( $vIndex ) -> retval
    VectorOfCameraParams( $vIndex ) -> retval

void VectorOfCameraParams::put_Item( size_t                   vIndex
                                     cv::detail::CameraParams vItem )

AutoIt:
    VectorOfCameraParams.Item( $vIndex ) = $vItem

static VectorOfGCompileArg VectorOfGCompileArg::create()

AutoIt:
    VectorOfGCompileArg.create() -> <VectorOfGCompileArg object>

static VectorOfGCompileArg VectorOfGCompileArg::create( size_t size )

AutoIt:
    VectorOfGCompileArg.create( $size ) -> <VectorOfGCompileArg object>

static VectorOfGCompileArg VectorOfGCompileArg::create( VectorOfGCompileArg other )

AutoIt:
    VectorOfGCompileArg.create( $other ) -> <VectorOfGCompileArg object>

std::vector<int> VectorOfGCompileArg::Keys()

AutoIt:
    VectorOfGCompileArg.Keys() -> retval

VectorOfGCompileArg VectorOfGCompileArg::Items()

AutoIt:
    VectorOfGCompileArg.Items() -> retval

void VectorOfGCompileArg::push_back( cv::GCompileArg value )

AutoIt:
    VectorOfGCompileArg.push_back( $value ) -> None

void VectorOfGCompileArg::Add( cv::GCompileArg value )

AutoIt:
    VectorOfGCompileArg.Add( $value ) -> None

void VectorOfGCompileArg::Remove( size_t index )

AutoIt:
    VectorOfGCompileArg.Remove( $index ) -> None

cv::GCompileArg VectorOfGCompileArg::at( size_t index )

AutoIt:
    VectorOfGCompileArg.at( $index ) -> retval

void VectorOfGCompileArg::at( size_t          index
                              cv::GCompileArg value )

AutoIt:
    VectorOfGCompileArg.at( $index, $value ) -> None

size_t VectorOfGCompileArg::size()

AutoIt:
    VectorOfGCompileArg.size() -> retval

bool VectorOfGCompileArg::empty()

AutoIt:
    VectorOfGCompileArg.empty() -> retval

void VectorOfGCompileArg::clear()

AutoIt:
    VectorOfGCompileArg.clear() -> None

void VectorOfGCompileArg::push_vector( VectorOfGCompileArg other )

AutoIt:
    VectorOfGCompileArg.push_vector( $other ) -> None

void VectorOfGCompileArg::push_vector( VectorOfGCompileArg other
                                       size_t              count
                                       size_t              start = 0 )

AutoIt:
    VectorOfGCompileArg.push_vector( $other, $count[, $start] ) -> None

VectorOfGCompileArg VectorOfGCompileArg::slice( size_t start = 0
                                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGCompileArg.slice( [$start[, $count]] ) -> retval

void VectorOfGCompileArg::sort( void*  comparator
                                size_t start = 0
                                size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGCompileArg.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfGCompileArg::sort_variant( void*  comparator
                                        size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGCompileArg.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfGCompileArg::start()

AutoIt:
    VectorOfGCompileArg.start() -> retval

void* VectorOfGCompileArg::end()

AutoIt:
    VectorOfGCompileArg.end() -> retval

cv::GCompileArg VectorOfGCompileArg::get_Item( size_t vIndex )

AutoIt:
    VectorOfGCompileArg.Item( $vIndex ) -> retval
    VectorOfGCompileArg( $vIndex ) -> retval

void VectorOfGCompileArg::put_Item( size_t          vIndex
                                    cv::GCompileArg vItem )

AutoIt:
    VectorOfGCompileArg.Item( $vIndex ) = $vItem

static VectorOfGRunArg VectorOfGRunArg::create()

AutoIt:
    VectorOfGRunArg.create() -> <VectorOfGRunArg object>

static VectorOfGRunArg VectorOfGRunArg::create( size_t size )

AutoIt:
    VectorOfGRunArg.create( $size ) -> <VectorOfGRunArg object>

static VectorOfGRunArg VectorOfGRunArg::create( VectorOfGRunArg other )

AutoIt:
    VectorOfGRunArg.create( $other ) -> <VectorOfGRunArg object>

std::vector<int> VectorOfGRunArg::Keys()

AutoIt:
    VectorOfGRunArg.Keys() -> retval

VectorOfGRunArg VectorOfGRunArg::Items()

AutoIt:
    VectorOfGRunArg.Items() -> retval

void VectorOfGRunArg::push_back( cv::GRunArg value )

AutoIt:
    VectorOfGRunArg.push_back( $value ) -> None

void VectorOfGRunArg::Add( cv::GRunArg value )

AutoIt:
    VectorOfGRunArg.Add( $value ) -> None

void VectorOfGRunArg::Remove( size_t index )

AutoIt:
    VectorOfGRunArg.Remove( $index ) -> None

cv::GRunArg VectorOfGRunArg::at( size_t index )

AutoIt:
    VectorOfGRunArg.at( $index ) -> retval

void VectorOfGRunArg::at( size_t      index
                          cv::GRunArg value )

AutoIt:
    VectorOfGRunArg.at( $index, $value ) -> None

size_t VectorOfGRunArg::size()

AutoIt:
    VectorOfGRunArg.size() -> retval

bool VectorOfGRunArg::empty()

AutoIt:
    VectorOfGRunArg.empty() -> retval

void VectorOfGRunArg::clear()

AutoIt:
    VectorOfGRunArg.clear() -> None

void VectorOfGRunArg::push_vector( VectorOfGRunArg other )

AutoIt:
    VectorOfGRunArg.push_vector( $other ) -> None

void VectorOfGRunArg::push_vector( VectorOfGRunArg other
                                   size_t          count
                                   size_t          start = 0 )

AutoIt:
    VectorOfGRunArg.push_vector( $other, $count[, $start] ) -> None

VectorOfGRunArg VectorOfGRunArg::slice( size_t start = 0
                                        size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGRunArg.slice( [$start[, $count]] ) -> retval

void VectorOfGRunArg::sort( void*  comparator
                            size_t start = 0
                            size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGRunArg.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfGRunArg::sort_variant( void*  comparator
                                    size_t start = 0
                                    size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGRunArg.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfGRunArg::start()

AutoIt:
    VectorOfGRunArg.start() -> retval

void* VectorOfGRunArg::end()

AutoIt:
    VectorOfGRunArg.end() -> retval

cv::GRunArg VectorOfGRunArg::get_Item( size_t vIndex )

AutoIt:
    VectorOfGRunArg.Item( $vIndex ) -> retval
    VectorOfGRunArg( $vIndex ) -> retval

void VectorOfGRunArg::put_Item( size_t      vIndex
                                cv::GRunArg vItem )

AutoIt:
    VectorOfGRunArg.Item( $vIndex ) = $vItem

static VectorOfGMetaArg VectorOfGMetaArg::create()

AutoIt:
    VectorOfGMetaArg.create() -> <VectorOfGMetaArg object>

static VectorOfGMetaArg VectorOfGMetaArg::create( size_t size )

AutoIt:
    VectorOfGMetaArg.create( $size ) -> <VectorOfGMetaArg object>

static VectorOfGMetaArg VectorOfGMetaArg::create( VectorOfGMetaArg other )

AutoIt:
    VectorOfGMetaArg.create( $other ) -> <VectorOfGMetaArg object>

std::vector<int> VectorOfGMetaArg::Keys()

AutoIt:
    VectorOfGMetaArg.Keys() -> retval

VectorOfGMetaArg VectorOfGMetaArg::Items()

AutoIt:
    VectorOfGMetaArg.Items() -> retval

void VectorOfGMetaArg::push_back( GMetaArg value )

AutoIt:
    VectorOfGMetaArg.push_back( $value ) -> None

void VectorOfGMetaArg::Add( GMetaArg value )

AutoIt:
    VectorOfGMetaArg.Add( $value ) -> None

void VectorOfGMetaArg::Remove( size_t index )

AutoIt:
    VectorOfGMetaArg.Remove( $index ) -> None

GMetaArg VectorOfGMetaArg::at( size_t index )

AutoIt:
    VectorOfGMetaArg.at( $index ) -> retval

void VectorOfGMetaArg::at( size_t   index
                           GMetaArg value )

AutoIt:
    VectorOfGMetaArg.at( $index, $value ) -> None

size_t VectorOfGMetaArg::size()

AutoIt:
    VectorOfGMetaArg.size() -> retval

bool VectorOfGMetaArg::empty()

AutoIt:
    VectorOfGMetaArg.empty() -> retval

void VectorOfGMetaArg::clear()

AutoIt:
    VectorOfGMetaArg.clear() -> None

void VectorOfGMetaArg::push_vector( VectorOfGMetaArg other )

AutoIt:
    VectorOfGMetaArg.push_vector( $other ) -> None

void VectorOfGMetaArg::push_vector( VectorOfGMetaArg other
                                    size_t           count
                                    size_t           start = 0 )

AutoIt:
    VectorOfGMetaArg.push_vector( $other, $count[, $start] ) -> None

VectorOfGMetaArg VectorOfGMetaArg::slice( size_t start = 0
                                          size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGMetaArg.slice( [$start[, $count]] ) -> retval

void VectorOfGMetaArg::sort( void*  comparator
                             size_t start = 0
                             size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGMetaArg.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfGMetaArg::sort_variant( void*  comparator
                                     size_t start = 0
                                     size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGMetaArg.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfGMetaArg::start()

AutoIt:
    VectorOfGMetaArg.start() -> retval

void* VectorOfGMetaArg::end()

AutoIt:
    VectorOfGMetaArg.end() -> retval

GMetaArg VectorOfGMetaArg::get_Item( size_t vIndex )

AutoIt:
    VectorOfGMetaArg.Item( $vIndex ) -> retval
    VectorOfGMetaArg( $vIndex ) -> retval

void VectorOfGMetaArg::put_Item( size_t   vIndex
                                 GMetaArg vItem )

AutoIt:
    VectorOfGMetaArg.Item( $vIndex ) = $vItem

static VectorOfGNetParam VectorOfGNetParam::create()

AutoIt:
    VectorOfGNetParam.create() -> <VectorOfGNetParam object>

static VectorOfGNetParam VectorOfGNetParam::create( size_t size )

AutoIt:
    VectorOfGNetParam.create( $size ) -> <VectorOfGNetParam object>

static VectorOfGNetParam VectorOfGNetParam::create( VectorOfGNetParam other )

AutoIt:
    VectorOfGNetParam.create( $other ) -> <VectorOfGNetParam object>

std::vector<int> VectorOfGNetParam::Keys()

AutoIt:
    VectorOfGNetParam.Keys() -> retval

VectorOfGNetParam VectorOfGNetParam::Items()

AutoIt:
    VectorOfGNetParam.Items() -> retval

void VectorOfGNetParam::push_back( cv::gapi::GNetParam value )

AutoIt:
    VectorOfGNetParam.push_back( $value ) -> None

void VectorOfGNetParam::Add( cv::gapi::GNetParam value )

AutoIt:
    VectorOfGNetParam.Add( $value ) -> None

void VectorOfGNetParam::Remove( size_t index )

AutoIt:
    VectorOfGNetParam.Remove( $index ) -> None

cv::gapi::GNetParam VectorOfGNetParam::at( size_t index )

AutoIt:
    VectorOfGNetParam.at( $index ) -> retval

void VectorOfGNetParam::at( size_t              index
                            cv::gapi::GNetParam value )

AutoIt:
    VectorOfGNetParam.at( $index, $value ) -> None

size_t VectorOfGNetParam::size()

AutoIt:
    VectorOfGNetParam.size() -> retval

bool VectorOfGNetParam::empty()

AutoIt:
    VectorOfGNetParam.empty() -> retval

void VectorOfGNetParam::clear()

AutoIt:
    VectorOfGNetParam.clear() -> None

void VectorOfGNetParam::push_vector( VectorOfGNetParam other )

AutoIt:
    VectorOfGNetParam.push_vector( $other ) -> None

void VectorOfGNetParam::push_vector( VectorOfGNetParam other
                                     size_t            count
                                     size_t            start = 0 )

AutoIt:
    VectorOfGNetParam.push_vector( $other, $count[, $start] ) -> None

VectorOfGNetParam VectorOfGNetParam::slice( size_t start = 0
                                            size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGNetParam.slice( [$start[, $count]] ) -> retval

void VectorOfGNetParam::sort( void*  comparator
                              size_t start = 0
                              size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGNetParam.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfGNetParam::sort_variant( void*  comparator
                                      size_t start = 0
                                      size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfGNetParam.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfGNetParam::start()

AutoIt:
    VectorOfGNetParam.start() -> retval

void* VectorOfGNetParam::end()

AutoIt:
    VectorOfGNetParam.end() -> retval

cv::gapi::GNetParam VectorOfGNetParam::get_Item( size_t vIndex )

AutoIt:
    VectorOfGNetParam.Item( $vIndex ) -> retval
    VectorOfGNetParam( $vIndex ) -> retval

void VectorOfGNetParam::put_Item( size_t              vIndex
                                  cv::gapi::GNetParam vItem )

AutoIt:
    VectorOfGNetParam.Item( $vIndex ) = $vItem

static VectorOfPrim VectorOfPrim::create()

AutoIt:
    VectorOfPrim.create() -> <VectorOfPrim object>

static VectorOfPrim VectorOfPrim::create( size_t size )

AutoIt:
    VectorOfPrim.create( $size ) -> <VectorOfPrim object>

static VectorOfPrim VectorOfPrim::create( VectorOfPrim other )

AutoIt:
    VectorOfPrim.create( $other ) -> <VectorOfPrim object>

std::vector<int> VectorOfPrim::Keys()

AutoIt:
    VectorOfPrim.Keys() -> retval

VectorOfPrim VectorOfPrim::Items()

AutoIt:
    VectorOfPrim.Items() -> retval

void VectorOfPrim::push_back( cv::gapi::wip::draw::Prim value )

AutoIt:
    VectorOfPrim.push_back( $value ) -> None

void VectorOfPrim::Add( cv::gapi::wip::draw::Prim value )

AutoIt:
    VectorOfPrim.Add( $value ) -> None

void VectorOfPrim::Remove( size_t index )

AutoIt:
    VectorOfPrim.Remove( $index ) -> None

cv::gapi::wip::draw::Prim VectorOfPrim::at( size_t index )

AutoIt:
    VectorOfPrim.at( $index ) -> retval

void VectorOfPrim::at( size_t                    index
                       cv::gapi::wip::draw::Prim value )

AutoIt:
    VectorOfPrim.at( $index, $value ) -> None

size_t VectorOfPrim::size()

AutoIt:
    VectorOfPrim.size() -> retval

bool VectorOfPrim::empty()

AutoIt:
    VectorOfPrim.empty() -> retval

void VectorOfPrim::clear()

AutoIt:
    VectorOfPrim.clear() -> None

void VectorOfPrim::push_vector( VectorOfPrim other )

AutoIt:
    VectorOfPrim.push_vector( $other ) -> None

void VectorOfPrim::push_vector( VectorOfPrim other
                                size_t       count
                                size_t       start = 0 )

AutoIt:
    VectorOfPrim.push_vector( $other, $count[, $start] ) -> None

VectorOfPrim VectorOfPrim::slice( size_t start = 0
                                  size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPrim.slice( [$start[, $count]] ) -> retval

void VectorOfPrim::sort( void*  comparator
                         size_t start = 0
                         size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPrim.sort( $comparator[, $start[, $count]] ) -> None

void VectorOfPrim::sort_variant( void*  comparator
                                 size_t start = 0
                                 size_t count = this->__self->get()->size() )

AutoIt:
    VectorOfPrim.sort_variant( $comparator[, $start[, $count]] ) -> None

void* VectorOfPrim::start()

AutoIt:
    VectorOfPrim.start() -> retval

void* VectorOfPrim::end()

AutoIt:
    VectorOfPrim.end() -> retval

cv::gapi::wip::draw::Prim VectorOfPrim::get_Item( size_t vIndex )

AutoIt:
    VectorOfPrim.Item( $vIndex ) -> retval
    VectorOfPrim( $vIndex ) -> retval

void VectorOfPrim::put_Item( size_t                    vIndex
                             cv::gapi::wip::draw::Prim vItem )

AutoIt:
    VectorOfPrim.Item( $vIndex ) = $vItem
